{
	"source": "https://docs.gitlab.com/",
	"crawledAt": "2026-02-02T06:03:24.905Z",
	"summary": {
		"pagesAttempted": 10,
		"pagesExtracted": 5,
		"pagesSkipped": 5,
		"totalTokensEstimate": 68477,
		"startTime": "2026-02-02T06:03:14.237Z",
		"endTime": "2026-02-02T06:03:24.895Z"
	},
	"pages": [
		{
			"url": "https://docs.gitlab.com/",
			"title": "GitLab Docs",
			"markdown": "[Go to GitLab Docs homepage](https://docs.gitlab.com/)\n\n[What's new?](https://about.gitlab.com/releases/whats-new/)\n\n[What's new?](https://about.gitlab.com/releases/whats-new/) [Get free trial](https://gitlab.com/-/trial_registrations/new?glm_source=docs.gitlab.com&amp;glm_content=navigation-cta-docs)\n\n## Find GitLab answers fast\n\n- [Get started](https://docs.gitlab.com/user/get_started/)\n- [CI/CD reference](https://docs.gitlab.com/ci/yaml/)\n- [SSH keys](https://docs.gitlab.com/user/ssh/)\n- [Personal access tokens](https://docs.gitlab.com/user/profile/personal_access_tokens/)\n- [Common Git commands](https://docs.gitlab.com/topics/git/commands/)\n\n[Use GitLab\n\nGet to know the GitLab end-to-end workflow.](https://docs.gitlab.com/user/)[Learn GitLab with tutorials\n\nHelp learn key GitLab workflows by following guided instructions.](https://docs.gitlab.com/tutorials/)[Subscribe to GitLab\n\nChoose and manage the subscription that's right for you and your organization.](https://docs.gitlab.com/subscriptions/)[GitLab Duo\n\nGet help from a suite of AI-native features while you work in GitLab.](https://docs.gitlab.com/user/gitlab_duo/)[Administer GitLab\n\nLearn how to install, configure, update, and maintain your GitLab instance.](https://docs.gitlab.com/administration/)[Extend with GitLab\n\nConnect GitLab to your tools and workflows to build a customized development environment.](https://docs.gitlab.com/api/)[Solutions architecture\n\nUse these reference solutions to integrate GitLab with your people, process, and technology.](https://docs.gitlab.com/solutions/)[Contribute to development\n\nLearn how to contribute to the development of the GitLab product.](https://docs.gitlab.com/development/)\n\n## Get started with GitLab\n\nIf you’re new to GitLab, get started learning about how GitLab works.\n\n[### Get started with Git\n\nWork with the Git version control system.](https://docs.gitlab.com/topics/git/get_started/)[### Get started with GitLab Duo (Classic)\n\nUse AI-native features throughout your development lifecycle.](https://docs.gitlab.com/user/get_started/getting_started_gitlab_duo/)[### Get started organizing work with projects\n\nConfigure projects to suit your organization.](https://docs.gitlab.com/user/get_started/get_started_projects/)[### Get started planning work\n\nPlan and execute on work.](https://docs.gitlab.com/user/get_started/get_started_planning_work/)[### Get started managing code\n\nBuild, track, and deliver the code for your project.](https://docs.gitlab.com/user/get_started/get_started_managing_code/)[### Get started with GitLab CI/CD\n\nBuild and test your application.](https://docs.gitlab.com/ci/)[### Get started securing your application\n\nTest your application and resolve vulnerabilities.](https://docs.gitlab.com/user/application_security/get-started-security/)[### Get started deploying and releasing your application\n\nDeploy and manage dependencies.](https://docs.gitlab.com/user/get_started/get_started_deploy_release/)[### Get started managing your infrastructure\n\nEmploy best practices for managing your infrastructure.](https://docs.gitlab.com/user/get_started/get_started_managing_infrastructure/)[### Get started with monitoring your application in GitLab\n\nMonitor your app and respond to incidents.](https://docs.gitlab.com/user/get_started/get_started_monitoring/)[### Get started extending GitLab\n\nInteract programmatically with GitLab.](https://docs.gitlab.com/api/get_started/get_started_extending/)\n\n## Reference architectures\n\nScale your GitLab installation by using the recommended configurations.\n\n[1,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/1k_users/)\n\n[2,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/2k_users/)\n\n[3,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/3k_users/)\n\n[5,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/5k_users/)\n\n[10,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/10k_users/)\n\n[25,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/25k_users/)\n\n[50,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/50k_users/)\n\n## Install GitLab Self-Managed\n\nYou've got options. [See them all](https://docs.gitlab.com/install/install_methods/)\n\n### Install on Linux\n\nThe Linux package includes services and tools to install GitLab without laborious configuration.\n\n[Use the Linux package](https://docs.gitlab.com/install/package/)\n\n### Install on Kubernetes\n\nIf you're using cluster management, we recommend the Helm chart or the Operator for installing cloud-native GitLab.\n\n[Use the Helm chart](https://docs.gitlab.com/charts/) [Use the Operator](https://docs.gitlab.com/operator/)\n\n[### Install with Docker\n\nGitLab maintains a set of official Docker images based on the Linux package.](https://docs.gitlab.com/install/docker/)[### Self-compile\n\nIf the Linux package isn't available for your distribution, you can self-compile GitLab.](https://docs.gitlab.com/install/self_compiled/)[### Install from cloud provider\n\nInstall directly from platforms like AWS, Azure, and GCP.](https://docs.gitlab.com/install/cloud_providers/)",
			"chunks": [
				{
					"id": "home_chunk_1",
					"content": "[Go to GitLab Docs homepage](https://docs.gitlab.com/)\n\n[What's new?](https://about.gitlab.com/releases/whats-new/)\n\n[What's new?](https://about.gitlab.com/releases/whats-new/) [Get free trial](https://gitlab.com/-/trial_registrations/new?glm_source=docs.gitlab.com&amp;glm_content=navigation-cta-docs)",
					"tokensEstimate": 75,
					"sourceUrl": "https://docs.gitlab.com/",
					"pageTitle": "GitLab Docs"
				},
				{
					"id": "home_chunk_2",
					"content": "## Find GitLab answers fast\n\n- [Get started](https://docs.gitlab.com/user/get_started/)\n- [CI/CD reference](https://docs.gitlab.com/ci/yaml/)\n- [SSH keys](https://docs.gitlab.com/user/ssh/)\n- [Personal access tokens](https://docs.gitlab.com/user/profile/personal_access_tokens/)\n- [Common Git commands](https://docs.gitlab.com/topics/git/commands/)\n\n[Use GitLab\n\nGet to know the GitLab end-to-end workflow.](https://docs.gitlab.com/user/)[Learn GitLab with tutorials\n\nHelp learn key GitLab workflows by following guided instructions.](https://docs.gitlab.com/tutorials/)[Subscribe to GitLab\n\nChoose and manage the subscription that's right for you and your organization.](https://docs.gitlab.com/subscriptions/)[GitLab Duo\n\nGet help from a suite of AI-native features while you work in GitLab.](https://docs.gitlab.com/user/gitlab_duo/)[Administer GitLab\n\nLearn how to install, configure, update, and maintain your GitLab instance.](https://docs.gitlab.com/administration/)[Extend with GitLab\n\nConnect GitLab to your tools and workflows to build a customized development environment.](https://docs.gitlab.com/api/)[Solutions architecture\n\nUse these reference solutions to integrate GitLab with your people, process, and technology.](https://docs.gitlab.com/solutions/)[Contribute to development\n\nLearn how to contribute to the development of the GitLab product.](https://docs.gitlab.com/development/)",
					"tokensEstimate": 348,
					"sourceUrl": "https://docs.gitlab.com/",
					"pageTitle": "GitLab Docs"
				},
				{
					"id": "home_chunk_3",
					"content": "## Get started with GitLab\n\nIf you’re new to GitLab, get started learning about how GitLab works.\n\n[### Get started with Git\n\nWork with the Git version control system.](https://docs.gitlab.com/topics/git/get_started/)[### Get started with GitLab Duo (Classic)\n\nUse AI-native features throughout your development lifecycle.](https://docs.gitlab.com/user/get_started/getting_started_gitlab_duo/)[### Get started organizing work with projects\n\nConfigure projects to suit your organization.](https://docs.gitlab.com/user/get_started/get_started_projects/)[### Get started planning work\n\nPlan and execute on work.](https://docs.gitlab.com/user/get_started/get_started_planning_work/)[### Get started managing code\n\nBuild, track, and deliver the code for your project.](https://docs.gitlab.com/user/get_started/get_started_managing_code/)[### Get started with GitLab CI/CD\n\nBuild and test your application.](https://docs.gitlab.com/ci/)[### Get started securing your application\n\nTest your application and resolve vulnerabilities.](https://docs.gitlab.com/user/application_security/get-started-security/)[### Get started deploying and releasing your application\n\nDeploy and manage dependencies.](https://docs.gitlab.com/user/get_started/get_started_deploy_release/)[### Get started managing your infrastructure\n\nEmploy best practices for managing your infrastructure.](https://docs.gitlab.com/user/get_started/get_started_managing_infrastructure/)[### Get started with monitoring your application in GitLab\n\nMonitor your app and respond to incidents.](https://docs.gitlab.com/user/get_started/get_started_monitoring/)[### Get started extending GitLab\n\nInteract programmatically with GitLab.](https://docs.gitlab.com/api/get_started/get_started_extending/)",
					"tokensEstimate": 434,
					"sourceUrl": "https://docs.gitlab.com/",
					"pageTitle": "GitLab Docs"
				},
				{
					"id": "home_chunk_4",
					"content": "## Reference architectures\n\nScale your GitLab installation by using the recommended configurations.\n\n[1,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/1k_users/)\n\n[2,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/2k_users/)\n\n[3,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/3k_users/)\n\n[5,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/5k_users/)\n\n[10,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/10k_users/)\n\n[25,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/25k_users/)\n\n[50,000\n\nusers](https://docs.gitlab.com/administration/reference_architectures/50k_users/)\n\n## Install GitLab Self-Managed\n\nYou've got options. [See them all](https://docs.gitlab.com/install/install_methods/)\n\n### Install on Linux\n\nThe Linux package includes services and tools to install GitLab without laborious configuration.\n\n[Use the Linux package](https://docs.gitlab.com/install/package/)",
					"tokensEstimate": 255,
					"sourceUrl": "https://docs.gitlab.com/",
					"pageTitle": "GitLab Docs"
				},
				{
					"id": "home_chunk_5",
					"content": "### Install on Kubernetes\n\nIf you're using cluster management, we recommend the Helm chart or the Operator for installing cloud-native GitLab.\n\n[Use the Helm chart](https://docs.gitlab.com/charts/) [Use the Operator](https://docs.gitlab.com/operator/)\n\n[### Install with Docker\n\nGitLab maintains a set of official Docker images based on the Linux package.](https://docs.gitlab.com/install/docker/)[### Self-compile\n\nIf the Linux package isn't available for your distribution, you can self-compile GitLab.](https://docs.gitlab.com/install/self_compiled/)[### Install from cloud provider\n\nInstall directly from platforms like AWS, Azure, and GCP.](https://docs.gitlab.com/install/cloud_providers/)",
					"tokensEstimate": 173,
					"sourceUrl": "https://docs.gitlab.com/",
					"pageTitle": "GitLab Docs"
				}
			],
			"metadata": {
				"url": "https://docs.gitlab.com/",
				"title": "GitLab Docs",
				"depth": 0,
				"crawledAt": "2026-02-02T06:03:16.848Z",
				"tokensEstimate": 1285
			}
		},
		{
			"url": "https://docs.gitlab.com/user/profile/personal_access_tokens",
			"title": "Personal access tokens | GitLab Docs",
			"markdown": "- Tier: Free, Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nPersonal access tokens can be an alternative to [OAuth2](https://docs.gitlab.com/api/oauth2/) and used to:\n\n- Authenticate with the GitLab API.- Authenticate with Git using HTTP Basic Authentication.\n\nIn both cases, you authenticate with a personal access token in place of your password. Username is not evaluated as part of the authentication process.\n\nPersonal access tokens are:\n\n- Required when [two-factor authentication (2FA)](https://docs.gitlab.com/user/profile/account/two_factor_authentication/)or [SAML](https://docs.gitlab.com/integration/saml/#password-generation-for-users-created-through-saml)is enabled.- Used with a GitLab username to authenticate with GitLab features that require usernames. For example, [GitLab-managed Terraform state backend](https://docs.gitlab.com/user/infrastructure/iac/terraform_state/#use-your-gitlab-backend-as-a-remote-data-source)and [Docker container registry](https://docs.gitlab.com/user/packages/container_registry/authenticate_with_container_registry/),- Similar to [project access tokens](https://docs.gitlab.com/user/project/settings/project_access_tokens/)and [group access tokens](https://docs.gitlab.com/user/group/settings/group_access_tokens/), but are attached to a user rather than a project or group.\n\nThough required, GitLab usernames are ignored when authenticating with a personal access token. There is an [issue for tracking](https://gitlab.com/gitlab-org/gitlab/-/issues/212953) to make GitLab use the username.\n\nFor examples of how you can use a personal access token to authenticate with the API, see [REST API authentication](https://docs.gitlab.com/api/rest/authentication/#personal-project-and-group-access-tokens).\n\nAlternately, GitLab administrators can use the API to create impersonation tokens. Use impersonation tokens to automate authentication as a specific user.\n\n## Create a personal access token\n\nThe availability of the extended maximum allowable lifetime limit is controlled by a feature flag. For more information, see the history.\n\nYou can create as many personal access tokens as you like.\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **Personal access tokens**.- Select **Add new token**.- In **Token name**, enter a name for the token.- Optional. In **Token description**, enter a description for the token.- In **Expiration date**, enter an expiration date for the token.\n - The token expires on that date at midnight UTC. A token with the expiration date of 2024-01-01 expires at 00:00:00 UTC on 2024-01-01.- If you do not enter an expiry date, the expiry date is automatically set to 365 days later than the current date.- By default, this date can be a maximum of 365 days later than the current date. In GitLab 17.6 or later, you can extend this limit to 400 days.- Select the [desired scopes](https://docs.gitlab.com/user/profile/personal_access_tokens/#personal-access-token-scopes).- Select **Create personal access token**.\n\nSave the personal access token somewhere safe. After you leave the page, you no longer have access to the token.\n\n### Prefill personal access token details\n\nYou can prefill the details of the personal access token by appending the name, description, and list of scopes to the URL. For example:\n\n```text\nhttps://gitlab.example.com/-/user_settings/personal_access_tokens?name=Example+Access+token&description=My+description&scopes=api,read_user\n```\n\nPersonal access tokens must be treated carefully. Read our [token security considerations](https://docs.gitlab.com/security/tokens/#security-considerations) for guidance on managing personal access tokens (for example, setting a short expiry and using minimal scopes).\n\n## Rotate a personal access token\n\nRotating a token creates a new token with fresh credentials while invalidating the previous version. Rotated tokens maintain the same permissions and scope as the original. The old token becomes inactive immediately, and both versions remain in the system for audit purposes.\n\nTo rotate a personal access token:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **Personal access tokens**.- Next to an active token, select the vertical ellipsis ( ellipsis\\_v).- Select **Rotate**( retry).- On the confirmation dialog, select **Rotate**.\n\n## Revoke a personal access token\n\nRevoking a token immediately invalidates it, preventing any further use for authentication or authorization. Revoked tokens remain in the system to maintain an audit trail of token history. You cannot permanently delete tokens, but you can filter token lists to show only active tokens.\n\nTo revoke a personal access token:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **Personal access tokens**.- Next to an active token, select the vertical ellipsis ( ellipsis\\_v ).- Select **Revoke** ( remove ).- On the confirmation dialog, select **Revoke**. These actions cannot be undone. Any tools that rely on a revoked or rotated access token will stop working.\n\n## Disable personal access tokens\n\n- Tier: Premium, Ultimate- Offering: GitLab Self-Managed, GitLab Dedicated\n\nPrerequisites:\n\n- You must be an administrator.\n\nDepending on your GitLab version, you can use either the application settings API or the Admin UI to disable personal access tokens.\n\n### Use the application settings API\n\nIn GitLab 15.7 and later, you can use the [`disable_personal_access_tokens` attribute in the application settings API](https://docs.gitlab.com/api/settings/#available-settings) to disable personal access tokens.\n\nAfter you have used the API to disable personal access tokens, those tokens cannot be used in subsequent API calls to manage this setting. To re-enable personal access tokens, you must use the [GitLab Rails console](https://docs.gitlab.com/administration/operations/rails_console/). You can also upgrade to GitLab 17.3 or later so you can use the Admin UI instead.\n\n### Use the Admin UI\n\nPrerequisites:\n\n- Administrator access.\n\nIn GitLab 17.3 and later, you can use the Admin UI to disable personal access tokens:\n\n- In the upper-right corner, select **Admin**.- Select **Settings**> **General**.- Expand **Visibility and access controls**.- Select the **Disable personal access tokens**checkbox.- Select **Save changes**.\n\n### Disable personal access tokens for enterprise users\n\nPrerequisites:\n\n- You must have the Owner role for the group that the enterprise user belongs to.\n\nDisabling the personal access tokens of a group’s [enterprise users](https://docs.gitlab.com/user/enterprise_user/):\n\n- Stops the enterprise users from creating new personal access tokens. This behavior applies even if an enterprise user is also an administrator of the group.- Disables the existing personal access tokens of the enterprise users.\n\nDisabling personal access tokens for enterprise users does not disable personal access tokens for [service accounts](https://docs.gitlab.com/user/profile/service_accounts/).\n\nTo disable the enterprise users’ personal access tokens:\n\n- On the top bar, select **Search or go to**and find your group.- Select **Settings**> **General**.- Expand **Permissions and group features**.- Under **Personal access tokens**, select **Disable personal access tokens**.- Select **Save changes**.\n\nWhen you delete or block an enterprise user account, their personal access tokens are automatically revoked.\n\n## View token usage information\n\nToken usage information updates periodically. The time the token was last used updates every 10 minutes, and the most recently used IP address updates every minute. GitLab considers a token used when the token:\n\n- Authenticates with the [REST](https://docs.gitlab.com/api/rest/)or [GraphQL](https://docs.gitlab.com/api/graphql/)APIs.- Performs a Git operation.\n\nTo view the last time a token was used, and the IP addresses from where the token was used:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **Personal access tokens**.- In the **Active personal access tokens**area, view the **Last Used**date and **Last Used IPs**for the relevant token. **Last Used IPs**shows the last five distinct IP addresses.\n\n## Personal access token scopes\n\nA personal access token can perform actions based on the assigned scopes.\n\nScope\n\nAccess\n\n`api`\n\nGrants complete read/write access to the API, including all groups and projects, the container registry, the dependency proxy, and the package registry. Also grants complete read/write access to the registry and repository using Git over HTTP.\n\n`read_user`\n\nGrants read-only access to the authenticated user’s profile through the `/user` API endpoint, which includes username, public email, and full name. Also grants access to read-only API endpoints under [`/users`](https://docs.gitlab.com/api/users/).\n\n`read_api`\n\nGrants read access to the API, including all groups and projects, the container registry, and the package registry.\n\n`read_repository`\n\nGrants read-only access to repositories on private projects using Git-over-HTTP or the Repository Files API.\n\n`write_repository`\n\nGrants read-write access to repositories on private projects using Git-over-HTTP (not using the API).\n\n`read_registry`\n\nGrants read-only (pull) access to [container registry](https://docs.gitlab.com/user/packages/container_registry/) images if a project is private and authorization is required. Available only when the container registry is enabled.\n\n`write_registry`\n\nGrants read-write (push) access to [container registry](https://docs.gitlab.com/user/packages/container_registry/) images if a project is private and authorization is required. Available only when the container registry is enabled.\n\n`read_virtual_registry`\n\nIf a project is private and authorization is required, grants read-only (pull) access to container images through the [dependency proxy](https://docs.gitlab.com/user/packages/dependency_proxy/). Available only when the dependency proxy is enabled.\n\n`write_virtual_registry`\n\nIf a project is private and authorization is required, grants read (pull), write (push), and delete access to container images through the [dependency proxy](https://docs.gitlab.com/user/packages/dependency_proxy/). Available only when the dependency proxy is enabled.\n\n`sudo`\n\nGrants permission to perform API actions as any user in the system, when authenticated as an administrator.\n\n`admin_mode`\n\nGrants permission to perform API actions when [Admin Mode](https://docs.gitlab.com/administration/settings/sign_in_restrictions/#admin-mode) is enabled. [Introduced](https://gitlab.com/gitlab-org/gitlab/-/merge_requests/107875) in GitLab 15.8. Available only to administrators on GitLab Self-Managed instances.\n\n`create_runner`\n\nGrants permission to create runners.\n\n`manage_runner`\n\nGrants permission to manage runners.\n\n`ai_features`\n\nThis scope:\n\\- Grants permission to perform API actions for features like GitLab Duo, Code Suggestions API and GitLab Duo Chat API.\n\\- Does not work for GitLab Self-Managed versions 16.5, 16.6, and 16.7.\nFor GitLab Duo plugin for JetBrains, this scope:\n\\- Supports users with AI features enabled in the GitLab Duo plugin for JetBrains.\n\\- Addresses a security vulnerability in JetBrains IDE plugins that could expose personal access tokens.\n\\- Is designed to minimize potential risks for GitLab Duo plugin users by limiting the impact of compromised tokens.\nFor all other extensions, see the individual scope requirements in their documentation.\n\n`k8s_proxy`\n\nGrants permission to perform Kubernetes API calls using the agent for Kubernetes.\n\n`self_rotate`\n\nGrants permission to rotate this token using the [personal access token API](https://docs.gitlab.com/api/personal_access_tokens/#rotate-a-personal-access-token). Does not allow rotation of other tokens.\n\n`read_service_ping`\n\nGrant access to download Service Ping payload through the API when authenticated as an admin use.\n\nIf you enabled [external authorization](https://docs.gitlab.com/administration/settings/external_authorization/), personal access tokens cannot access container or package registries. If you use personal access tokens to access these registries, this measure breaks this use of these tokens. Disable external authorization to use personal access tokens with container or package registries.\n\n## Access token expiration\n\nThe availability of the extended maximum allowable lifetime limit is controlled by a feature flag. For more information, see the history.\n\nPersonal access tokens expire on the date you define, at midnight, 00:00 AM UTC. A token with the expiration date of 2024-01-01 expires at 00:00:00 UTC on 2024-01-01.\n\n- GitLab runs a check at 1:00 AM UTC every day to identify personal access tokens that expire soon. The owners of these tokens are [notified by email](https://docs.gitlab.com/user/profile/personal_access_tokens/#personal-access-token-expiry-emails).- GitLab runs a check at 02:00 AM UTC every day to identify personal access tokens that expire on the current date. The owners of these tokens are notified by email.- In GitLab Ultimate, administrators can [limit the allowable lifetime of access tokens](https://docs.gitlab.com/administration/settings/account_and_limit_settings/#limit-the-lifetime-of-access-tokens). If not set, the maximum allowable lifetime of a personal access token is 365 days. In GitLab 17.6 or later, you can extend this limit to 400 days.- In GitLab Free and Premium, the maximum allowable lifetime of a personal access token is 365 days. In GitLab 17.6 or later, you can extend this limit to 400 days.- If you do not set an expiry date when creating a personal access token, the expiry date is set to the [maximum allowed lifetime for the token](https://docs.gitlab.com/administration/settings/account_and_limit_settings/#limit-the-lifetime-of-access-tokens). If the maximum allowed lifetime is not set, the default expiry date is 365 days from the date of creation.\n\nWhether your existing personal access tokens have expiry dates automatically applied depends on what GitLab offering you have, and when you upgraded to GitLab 16.0 or later:\n\n- On GitLab.com, during the 16.0 milestone, existing personal access tokens without an expiry date were automatically given an expiry date of 365 days later than the current date.- On GitLab Self-Managed, if you upgraded from GitLab 15.11 or earlier to GitLab 16.0 or later:\n - On or before July 23, 2024, existing personal access tokens without an expiry date were automatically given an expiry date of 365 days later than the current date. This change is a breaking change.- On or after July 24, 2024, existing personal access tokens without an expiry date did not have an expiry date set.\n\nOn GitLab Self-Managed, if you do a new install of one of the following GitLab versions, your existing personal access tokens do not have expiry dates automatically applied:\n\n- 16.0.9- 16.1.7- 16.2.10- 16.3.8- 16.4.6- 16.5.9- 16.6.9- 16.7.9- 16.8.9- 16.9.10- 16.10.9- 16.11.7- 17.0.5- 17.1.3- 17.2.1\n\n### Personal access token expiry emails\n\nGitLab runs a check every day at 1:00 AM UTC to identify personal access tokens that are expiring in the near future. The owners of these tokens are notified by email when these tokens expire in a certain number of days. The number of days differs depending on the version of GitLab:\n\n- In GitLab 17.6 and later, personal access token owners are notified by email when the check identifies their personal access tokens as expiring in the next 60 days. An additional email is sent when the check identifies their group access tokens as expiring in the next 30 days.- Personal access token owners are notified by email when the check identifies their group access tokens as expiring in the next seven days.\n\n### Personal access token expiry calendar\n\nYou can subscribe to an iCalendar endpoint which contains events at the expiry date for each token. After signing in, this endpoint is available at `/-/user_settings/personal_access_tokens.ics`.\n\n### Create a service account personal access token with no expiry date\n\nYou can [create a personal access token for a service account](https://docs.gitlab.com/api/service_accounts/#create-a-personal-access-token-for-a-group-service-account) with no expiry date. These personal access tokens never expire, unlike non-service account personal access tokens.\n\nAllowing personal access tokens for service accounts to be created with no expiry date only affects tokens created after you change this setting. It does not affect existing tokens.\n\n#### GitLab.com\n\nPrerequisites:\n\n- You must have the Owner role for the top-level group.\n\n- On the top bar, select **Search or go to**and find your group.- Select **Settings**> **General**> **Permissions and group features**.- Clear the **Service account token expiration**checkbox.\n\nYou can now create personal access tokens for a service account user with no expiry date.\n\n#### GitLab Self-Managed\n\nPrerequisites:\n\n- You must be an administrator for your GitLab Self-Managed instance.\n\n- In the upper-right corner, select **Admin**.- Select **Settings**> **General**.- Expand **Account and limit**.- Clear the **Service account token expiration**checkbox.\n\nYou can now create personal access tokens for a service account user with no expiry date.\n\n## Use DPoP with personal access tokens\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed\n\nThe availability of this feature is controlled by a feature flag. For more information, see the history. This feature is available for testing, but not ready for production use.\n\nDemonstrating Proof of Possession (DPoP) enhances the security of your personal access tokens, and minimizes the effects of unintended token leaks. When you enable this feature on your account, all REST and GraphQL API requests containing a PAT must also provide a signed DPoP header. Creating a signed DPoP header requires your corresponding private SSH key.\n\nIf you enable this feature, all API requests without a valid DPoP header return a `DpopValidationError` error.\n\nDPoP header is not required for Git operations over HTTPS that include an access token.\n\nPrerequisites:\n\n- You must [add at least one public SSH key](https://docs.gitlab.com/user/ssh/#add-an-ssh-key-to-your-gitlab-account)to your account, with a **Usage type**of **Signing**or **Authentication & Signing**.\n - Your SSH key type must be RSA.- You must have installed and configured the [GitLab CLI](https://docs.gitlab.com/editor_extensions/gitlab_cli/)for your GitLab account.\n\nTo require DPoP on all calls to the REST and GraphQL APIs:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **Personal access tokens**.- Go to the **Use Demonstrating Proof of Possession (DPoP)** section, and select **Enable DPoP**.- Select **Save changes**.- To generate a DPoP header with the [GitLab CLI](https://docs.gitlab.com/editor_extensions/gitlab_cli/), run this command in your terminal. Replace `<your_access_token>` with your access token, and `~/.ssh/id_rsa` with the location of your private key: ```text\nglab auth dpop-gen --pat \"<your_access_token>\" --private-key ~/.ssh/id_rsa\n```\n\nThe DPoP header you generated in the CLI can be used:\n\n- With the REST API: ```bash\ncurl --header \"PRIVATE-TOKEN: <your_access_token>\" \\\n --header \"DPoP: <dpop-from-glab>\" \\\n\"https://gitlab.example.com/api/v4/projects\"\n```- With GraphQL: ```bash\ncurl --request POST \\\n --header \"Content-Type: application/json\" \\\n --header \"PRIVATE-TOKEN: <your_access_token>\" \\\n --header \"DPoP: <dpop-from-glab>\" \\\n --data '{\n\"query\": \"query { currentUser { id } }\"\n}' \\\n\"https://gitlab.example.com/api/graphql\"\n```\n\nTo learn more about DPoP, see the blueprint [Sender Constraining Personal Access Tokens](https://gitlab.com/gitlab-com/gl-security/product-security/appsec/security-feature-blueprints/-/tree/main/sender_constraining_access_tokens).\n\n## Create a personal access token programmatically\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab Self-Managed, GitLab Dedicated\n\nYou can create a predetermined personal access token as part of your tests or automation.\n\nPrerequisites:\n\n- You need sufficient access to run a [Rails console session](https://docs.gitlab.com/administration/operations/rails_console/#starting-a-rails-console-session)for your GitLab instance.\n\nTo create a personal access token programmatically:\n\n- Open a Rails console: ```text\nsudo gitlab-rails console\n```- Run the following commands to reference the username, the token, and the scopes. The token must be 20 characters long. The scopes must be valid and are visible [in the source code](https://gitlab.com/gitlab-org/gitlab/-/blob/master/lib/gitlab/auth.rb). For example, to create a token that belongs to a user with username `automation-bot` and expires in a year: ```text\nuser = User.find_by_username('automation-bot')\ntoken = user.personal_access_tokens.create(scopes: ['read_user', 'read_repository'], name: 'Automation token', expires_at: 365.days.from_now)\ntoken.set_token('token-string-here123')\ntoken.save!\n```\n\nThis code can be shortened into a single-line shell command by using the [Rails runner](https://docs.gitlab.com/administration/operations/rails_console/#using-the-rails-runner):\n\n```text\nsudo gitlab-rails runner \"token = User.find_by_username('automation-bot').personal_access_tokens.create(scopes: ['read_user', 'read_repository'], name: 'Automation token', expires_at: 365.days.from_now); token.set_token('token-string-here123'); token.save!\"\n```\n\n## Revoke a personal access token programmatically\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab Self-Managed, GitLab Dedicated\n\nYou can programmatically revoke a personal access token as part of your tests or automation.\n\nPrerequisites:\n\n- You need sufficient access to run a [Rails console session](https://docs.gitlab.com/administration/operations/rails_console/#starting-a-rails-console-session)for your GitLab instance.\n\nTo revoke a token programmatically:\n\n- Open a Rails console: ```text\nsudo gitlab-rails console\n```- To revoke a token of `token-string-here123`, run the following commands: ```text\ntoken = PersonalAccessToken.find_by_token('token-string-here123')\ntoken.revoke!\n```\n\nThis code can be shortened into a single-line shell command using the [Rails runner](https://docs.gitlab.com/administration/operations/rails_console/#using-the-rails-runner):\n\n```text\nsudo gitlab-rails runner \"PersonalAccessToken.find_by_token('token-string-here123').revoke!\"\n```\n\n## Clone repository using personal access token\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab Self-Managed, GitLab Dedicated\n\nTo clone a repository when SSH is disabled, clone it using a personal access token by running the following command:\n\n```bash\ngit clone https://<username>:<personal_token>@gitlab.com/gitlab-org/gitlab.git\n```\n\nThis method saves your personal access token in your bash history. To avoid this, run the following command:\n\n```bash\ngit clone https://<username>@gitlab.com/gitlab-org/gitlab.git\n```\n\nWhen asked for your password for `https://gitlab.com`, enter your personal access token.\n\nThe `username` in the `clone` command:\n\n- Can be any string value.- Must not be an empty string.\n\nRemember this if you set up an automation pipeline that depends on authentication.\n\n## Troubleshooting\n\n### Unrevoke a personal access token\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab Self-Managed, GitLab Dedicated\n\nIf a personal access token is revoked accidentally by any method, administrators can unrevoke that token. By default, a daily job deletes revoked tokens at 1:00 AM system time.\n\nRunning the following commands changes data directly. This could be damaging if not done correctly, or under the right conditions. You should first run these commands in a test environment with a backup of the instance ready to be restored, just in case.\n\n- Open a [Rails console](https://docs.gitlab.com/administration/operations/rails_console/#starting-a-rails-console-session).- Unrevoke the token: ```text\ntoken = PersonalAccessToken.find_by_token('<token_string>')\ntoken.update!(revoked:false)\n``` For example, to unrevoke a token of `token-string-here123`: ```text\ntoken = PersonalAccessToken.find_by_token('token-string-here123')\ntoken.update!(revoked:false)\n```\n\n## Alternatives to personal access tokens\n\nFor Git over HTTPS, an alternative to personal access tokens is to use an OAuth credential helper.\n\nFor authentication in CI/CD jobs, consider:\n\n- [CI/CD job tokens](https://docs.gitlab.com/ci/jobs/ci_job_token/)with [fine-grained permissions](https://docs.gitlab.com/ci/jobs/fine_grained_permissions/)for pipeline authentication- [Project access tokens](https://docs.gitlab.com/user/project/settings/project_access_tokens/)with minimal required permissions for project-specific automation\n\n- [Group access tokens](https://docs.gitlab.com/user/group/settings/group_access_tokens/)\n- [Project access tokens](https://docs.gitlab.com/user/project/settings/project_access_tokens/)\n- [Personal access tokens API](https://docs.gitlab.com/api/personal_access_tokens/)",
			"chunks": [
				{
					"id": "user_profile_personal_access_tokens_chunk_1",
					"content": "- Tier: Free, Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nPersonal access tokens can be an alternative to [OAuth2](https://docs.gitlab.com/api/oauth2/) and used to:\n\n- Authenticate with the GitLab API.- Authenticate with Git using HTTP Basic Authentication.\n\nIn both cases, you authenticate with a personal access token in place of your password. Username is not evaluated as part of the authentication process.\n\nPersonal access tokens are:\n\n- Required when [two-factor authentication (2FA)](https://docs.gitlab.com/user/profile/account/two_factor_authentication/)or [SAML](https://docs.gitlab.com/integration/saml/#password-generation-for-users-created-through-saml)is enabled.- Used with a GitLab username to authenticate with GitLab features that require usernames. For example, [GitLab-managed Terraform state backend](https://docs.gitlab.com/user/infrastructure/iac/terraform_state/#use-your-gitlab-backend-as-a-remote-data-source)and [Docker container registry](https://docs.gitlab.com/user/packages/container_registry/authenticate_with_container_registry/),- Similar to [project access tokens](https://docs.gitlab.com/user/project/settings/project_access_tokens/)and [group access tokens](https://docs.gitlab.com/user/group/settings/group_access_tokens/), but are attached to a user rather than a project or group.\n\nThough required, GitLab usernames are ignored when authenticating with a personal access token. There is an [issue for tracking](https://gitlab.com/gitlab-org/gitlab/-/issues/212953) to make GitLab use the username.\n\nFor examples of how you can use a personal access token to authenticate with the API, see [REST API authentication](https://docs.gitlab.com/api/rest/authentication/#personal-project-and-group-access-tokens).\n\nAlternately, GitLab administrators can use the API to create impersonation tokens. Use impersonation tokens to automate authentication as a specific user.",
					"tokensEstimate": 483,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_2",
					"content": "## Create a personal access token\n\nThe availability of the extended maximum allowable lifetime limit is controlled by a feature flag. For more information, see the history.\n\nYou can create as many personal access tokens as you like.\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **Personal access tokens**.- Select **Add new token**.- In **Token name**, enter a name for the token.- Optional. In **Token description**, enter a description for the token.- In **Expiration date**, enter an expiration date for the token.\n - The token expires on that date at midnight UTC. A token with the expiration date of 2024-01-01 expires at 00:00:00 UTC on 2024-01-01.- If you do not enter an expiry date, the expiry date is automatically set to 365 days later than the current date.- By default, this date can be a maximum of 365 days later than the current date. In GitLab 17.6 or later, you can extend this limit to 400 days.- Select the [desired scopes](https://docs.gitlab.com/user/profile/personal_access_tokens/#personal-access-token-scopes).- Select **Create personal access token**.\n\nSave the personal access token somewhere safe. After you leave the page, you no longer have access to the token.",
					"tokensEstimate": 312,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_3",
					"content": "### Prefill personal access token details\n\nYou can prefill the details of the personal access token by appending the name, description, and list of scopes to the URL. For example:\n\n```text\nhttps://gitlab.example.com/-/user_settings/personal_access_tokens?name=Example+Access+token&description=My+description&scopes=api,read_user\n```\n\nPersonal access tokens must be treated carefully. Read our [token security considerations](https://docs.gitlab.com/security/tokens/#security-considerations) for guidance on managing personal access tokens (for example, setting a short expiry and using minimal scopes).",
					"tokensEstimate": 150,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_4",
					"content": "## Rotate a personal access token\n\nRotating a token creates a new token with fresh credentials while invalidating the previous version. Rotated tokens maintain the same permissions and scope as the original. The old token becomes inactive immediately, and both versions remain in the system for audit purposes.\n\nTo rotate a personal access token:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **Personal access tokens**.- Next to an active token, select the vertical ellipsis ( ellipsis\\_v).- Select **Rotate**( retry).- On the confirmation dialog, select **Rotate**.",
					"tokensEstimate": 156,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_5",
					"content": "## Revoke a personal access token\n\nRevoking a token immediately invalidates it, preventing any further use for authentication or authorization. Revoked tokens remain in the system to maintain an audit trail of token history. You cannot permanently delete tokens, but you can filter token lists to show only active tokens.\n\nTo revoke a personal access token:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **Personal access tokens**.- Next to an active token, select the vertical ellipsis ( ellipsis\\_v ).- Select **Revoke** ( remove ).- On the confirmation dialog, select **Revoke**. These actions cannot be undone. Any tools that rely on a revoked or rotated access token will stop working.\n\n## Disable personal access tokens\n\n- Tier: Premium, Ultimate- Offering: GitLab Self-Managed, GitLab Dedicated\n\nPrerequisites:\n\n- You must be an administrator.\n\nDepending on your GitLab version, you can use either the application settings API or the Admin UI to disable personal access tokens.",
					"tokensEstimate": 259,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_6",
					"content": "### Use the application settings API\n\nIn GitLab 15.7 and later, you can use the [`disable_personal_access_tokens` attribute in the application settings API](https://docs.gitlab.com/api/settings/#available-settings) to disable personal access tokens.\n\nAfter you have used the API to disable personal access tokens, those tokens cannot be used in subsequent API calls to manage this setting. To re-enable personal access tokens, you must use the [GitLab Rails console](https://docs.gitlab.com/administration/operations/rails_console/). You can also upgrade to GitLab 17.3 or later so you can use the Admin UI instead.\n\n### Use the Admin UI\n\nPrerequisites:\n\n- Administrator access.\n\nIn GitLab 17.3 and later, you can use the Admin UI to disable personal access tokens:\n\n- In the upper-right corner, select **Admin**.- Select **Settings**> **General**.- Expand **Visibility and access controls**.- Select the **Disable personal access tokens**checkbox.- Select **Save changes**.",
					"tokensEstimate": 242,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_7",
					"content": "### Disable personal access tokens for enterprise users\n\nPrerequisites:\n\n- You must have the Owner role for the group that the enterprise user belongs to.\n\nDisabling the personal access tokens of a group’s [enterprise users](https://docs.gitlab.com/user/enterprise_user/):\n\n- Stops the enterprise users from creating new personal access tokens. This behavior applies even if an enterprise user is also an administrator of the group.- Disables the existing personal access tokens of the enterprise users.\n\nDisabling personal access tokens for enterprise users does not disable personal access tokens for [service accounts](https://docs.gitlab.com/user/profile/service_accounts/).\n\nTo disable the enterprise users’ personal access tokens:\n\n- On the top bar, select **Search or go to**and find your group.- Select **Settings**> **General**.- Expand **Permissions and group features**.- Under **Personal access tokens**, select **Disable personal access tokens**.- Select **Save changes**.\n\nWhen you delete or block an enterprise user account, their personal access tokens are automatically revoked.",
					"tokensEstimate": 272,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_8",
					"content": "## View token usage information\n\nToken usage information updates periodically. The time the token was last used updates every 10 minutes, and the most recently used IP address updates every minute. GitLab considers a token used when the token:\n\n- Authenticates with the [REST](https://docs.gitlab.com/api/rest/)or [GraphQL](https://docs.gitlab.com/api/graphql/)APIs.- Performs a Git operation.\n\nTo view the last time a token was used, and the IP addresses from where the token was used:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **Personal access tokens**.- In the **Active personal access tokens**area, view the **Last Used**date and **Last Used IPs**for the relevant token. **Last Used IPs**shows the last five distinct IP addresses.",
					"tokensEstimate": 199,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_9",
					"content": "## Personal access token scopes\n\n\n\nA personal access token can perform actions based on the assigned scopes.\n\nScope\n\nAccess\n\n`api`\n\nGrants complete read/write access to the API, including all groups and projects, the container registry, the dependency proxy, and the package registry. Also grants complete read/write access to the registry and repository using Git over HTTP.\n\n`read_user`\n\nGrants read-only access to the authenticated user’s profile through the `/user` API endpoint, which includes username, public email, and full name. Also grants access to read-only API endpoints under [`/users`](https://docs.gitlab.com/api/users/).\n\n`read_api`\n\nGrants read access to the API, including all groups and projects, the container registry, and the package registry.\n\n`read_repository`\n\nGrants read-only access to repositories on private projects using Git-over-HTTP or the Repository Files API.\n\n`write_repository`\n\nGrants read-write access to repositories on private projects using Git-over-HTTP (not using the API).\n\n`read_registry`\n\nGrants read-only (pull) access to [container registry](https://docs.gitlab.com/user/packages/container_registry/) images if a project is private and authorization is required. Available only when the container registry is enabled.\n\n`write_registry`\n\nGrants read-write (push) access to [container registry](https://docs.gitlab.com/user/packages/container_registry/) images if a project is private and authorization is required. Available only when the container registry is enabled.\n\n`read_virtual_registry`\n\nIf a project is private and authorization is required, grants read-only (pull) access to container images through the [dependency proxy](https://docs.gitlab.com/user/packages/dependency_proxy/). Available only when the dependency proxy is enabled.\n\n`write_virtual_registry`\n\nIf a project is private and authorization is required, grants read (pull), write (push), and delete access to container images through the [dependency proxy](https://docs.gitlab.com/user/packages/dependency_proxy/). Available only when the dependency proxy is enabled.\n\n`sudo`\n\nGrants permission to perform API actions as any user in the system, when authenticated as an administrator.\n\n`admin_mode`",
					"tokensEstimate": 549,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_10",
					"content": "Grants permission to perform API actions when [Admin Mode](https://docs.gitlab.com/administration/settings/sign_in_restrictions/#admin-mode) is enabled. [Introduced](https://gitlab.com/gitlab-org/gitlab/-/merge_requests/107875) in GitLab 15.8. Available only to administrators on GitLab Self-Managed instances.\n\n`create_runner`\n\nGrants permission to create runners.\n\n`manage_runner`\n\nGrants permission to manage runners.\n\n`ai_features`\n\nThis scope:\n\\- Grants permission to perform API actions for features like GitLab Duo, Code Suggestions API and GitLab Duo Chat API.\n\\- Does not work for GitLab Self-Managed versions 16.5, 16.6, and 16.7.\nFor GitLab Duo plugin for JetBrains, this scope:\n\\- Supports users with AI features enabled in the GitLab Duo plugin for JetBrains.\n\\- Addresses a security vulnerability in JetBrains IDE plugins that could expose personal access tokens.\n\\- Is designed to minimize potential risks for GitLab Duo plugin users by limiting the impact of compromised tokens.\nFor all other extensions, see the individual scope requirements in their documentation.\n\n`k8s_proxy`\n\nGrants permission to perform Kubernetes API calls using the agent for Kubernetes.\n\n`self_rotate`\n\nGrants permission to rotate this token using the [personal access token API](https://docs.gitlab.com/api/personal_access_tokens/#rotate-a-personal-access-token). Does not allow rotation of other tokens.\n\n`read_service_ping`\n\nGrant access to download Service Ping payload through the API when authenticated as an admin use.\n\nIf you enabled [external authorization](https://docs.gitlab.com/administration/settings/external_authorization/), personal access tokens cannot access container or package registries. If you use personal access tokens to access these registries, this measure breaks this use of these tokens. Disable external authorization to use personal access tokens with container or package registries.",
					"tokensEstimate": 474,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_11",
					"content": "## Access token expiration\n\nThe availability of the extended maximum allowable lifetime limit is controlled by a feature flag. For more information, see the history.\n\nPersonal access tokens expire on the date you define, at midnight, 00:00 AM UTC. A token with the expiration date of 2024-01-01 expires at 00:00:00 UTC on 2024-01-01.\n\n- GitLab runs a check at 1:00 AM UTC every day to identify personal access tokens that expire soon. The owners of these tokens are [notified by email](https://docs.gitlab.com/user/profile/personal_access_tokens/#personal-access-token-expiry-emails).- GitLab runs a check at 02:00 AM UTC every day to identify personal access tokens that expire on the current date. The owners of these tokens are notified by email.- In GitLab Ultimate, administrators can [limit the allowable lifetime of access tokens](https://docs.gitlab.com/administration/settings/account_and_limit_settings/#limit-the-lifetime-of-access-tokens). If not set, the maximum allowable lifetime of a personal access token is 365 days. In GitLab 17.6 or later, you can extend this limit to 400 days.- In GitLab Free and Premium, the maximum allowable lifetime of a personal access token is 365 days. In GitLab 17.6 or later, you can extend this limit to 400 days.- If you do not set an expiry date when creating a personal access token, the expiry date is set to the [maximum allowed lifetime for the token](https://docs.gitlab.com/administration/settings/account_and_limit_settings/#limit-the-lifetime-of-access-tokens). If the maximum allowed lifetime is not set, the default expiry date is 365 days from the date of creation.\n\nWhether your existing personal access tokens have expiry dates automatically applied depends on what GitLab offering you have, and when you upgraded to GitLab 16.0 or later:\n\n- On GitLab.com, during the 16.0 milestone, existing personal access tokens without an expiry date were automatically given an expiry date of 365 days later than the current date.- On GitLab Self-Managed, if you upgraded from GitLab 15.11 or earlier to GitLab 16.0 or later:\n - On or before July 23, 2024, existing personal access tokens without an expiry date were automatically given an expiry date of 365 days later than the current date. This change is a breaking change.- On or after July 24, 2024, existing personal access tokens without an expiry date did not have an expiry date set.\n\nOn GitLab Self-Managed, if you do a new install of one of the following GitLab versions, your existing personal access tokens do not have expiry dates automatically applied:\n\n- 16.0.9- 16.1.7- 16.2.10- 16.3.8- 16.4.6- 16.5.9- 16.6.9- 16.7.9- 16.8.9- 16.9.10- 16.10.9- 16.11.7- 17.0.5- 17.1.3- 17.2.1",
					"tokensEstimate": 672,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_12",
					"content": "### Personal access token expiry emails\n\nGitLab runs a check every day at 1:00 AM UTC to identify personal access tokens that are expiring in the near future. The owners of these tokens are notified by email when these tokens expire in a certain number of days. The number of days differs depending on the version of GitLab:\n\n- In GitLab 17.6 and later, personal access token owners are notified by email when the check identifies their personal access tokens as expiring in the next 60 days. An additional email is sent when the check identifies their group access tokens as expiring in the next 30 days.- Personal access token owners are notified by email when the check identifies their group access tokens as expiring in the next seven days.\n\n### Personal access token expiry calendar\n\nYou can subscribe to an iCalendar endpoint which contains events at the expiry date for each token. After signing in, this endpoint is available at `/-/user_settings/personal_access_tokens.ics`.",
					"tokensEstimate": 245,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_13",
					"content": "### Create a service account personal access token with no expiry date\n\nYou can [create a personal access token for a service account](https://docs.gitlab.com/api/service_accounts/#create-a-personal-access-token-for-a-group-service-account) with no expiry date. These personal access tokens never expire, unlike non-service account personal access tokens.\n\nAllowing personal access tokens for service accounts to be created with no expiry date only affects tokens created after you change this setting. It does not affect existing tokens.\n\n#### GitLab.com\n\nPrerequisites:\n\n- You must have the Owner role for the top-level group.\n\n- On the top bar, select **Search or go to**and find your group.- Select **Settings**> **General**> **Permissions and group features**.- Clear the **Service account token expiration**checkbox.\n\nYou can now create personal access tokens for a service account user with no expiry date.\n\n#### GitLab Self-Managed\n\nPrerequisites:\n\n- You must be an administrator for your GitLab Self-Managed instance.\n\n- In the upper-right corner, select **Admin**.- Select **Settings**> **General**.- Expand **Account and limit**.- Clear the **Service account token expiration**checkbox.\n\nYou can now create personal access tokens for a service account user with no expiry date.",
					"tokensEstimate": 319,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_14",
					"content": "## Use DPoP with personal access tokens\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed\n\nThe availability of this feature is controlled by a feature flag. For more information, see the history. This feature is available for testing, but not ready for production use.\n\nDemonstrating Proof of Possession (DPoP) enhances the security of your personal access tokens, and minimizes the effects of unintended token leaks. When you enable this feature on your account, all REST and GraphQL API requests containing a PAT must also provide a signed DPoP header. Creating a signed DPoP header requires your corresponding private SSH key.\n\nIf you enable this feature, all API requests without a valid DPoP header return a `DpopValidationError` error.\n\nDPoP header is not required for Git operations over HTTPS that include an access token.\n\nPrerequisites:\n\n- You must [add at least one public SSH key](https://docs.gitlab.com/user/ssh/#add-an-ssh-key-to-your-gitlab-account)to your account, with a **Usage type**of **Signing**or **Authentication & Signing**.\n - Your SSH key type must be RSA.- You must have installed and configured the [GitLab CLI](https://docs.gitlab.com/editor_extensions/gitlab_cli/)for your GitLab account.\n\nTo require DPoP on all calls to the REST and GraphQL APIs:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **Personal access tokens**.- Go to the **Use Demonstrating Proof of Possession (DPoP)** section, and select **Enable DPoP**.- Select **Save changes**.- To generate a DPoP header with the [GitLab CLI](https://docs.gitlab.com/editor_extensions/gitlab_cli/), run this command in your terminal. Replace `<your_access_token>` with your access token, and `~/.ssh/id_rsa` with the location of your private key: ```text\nglab auth dpop-gen --pat \"<your_access_token>\" --private-key ~/.ssh/id_rsa\n```\n\nThe DPoP header you generated in the CLI can be used:\n\n- With the REST API: ```bash\ncurl --header \"PRIVATE-TOKEN: <your_access_token>\" \\\n --header \"DPoP: <dpop-from-glab>\" \\\n\"https://gitlab.example.com/api/v4/projects\"\n```- With GraphQL: ```bash\ncurl --request POST \\\n --header \"Content-Type: application/json\" \\\n --header \"PRIVATE-TOKEN: <your_access_token>\" \\\n --header \"DPoP: <dpop-from-glab>\" \\\n --data '{\n\"query\": \"query { currentUser { id } }\"\n}' \\\n\"https://gitlab.example.com/api/graphql\"\n```\n\nTo learn more about DPoP, see the blueprint [Sender Constraining Personal Access Tokens](https://gitlab.com/gitlab-com/gl-security/product-security/appsec/security-feature-blueprints/-/tree/main/sender_constraining_access_tokens).",
					"tokensEstimate": 654,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_15",
					"content": "## Create a personal access token programmatically\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab Self-Managed, GitLab Dedicated\n\nYou can create a predetermined personal access token as part of your tests or automation.\n\nPrerequisites:\n\n- You need sufficient access to run a [Rails console session](https://docs.gitlab.com/administration/operations/rails_console/#starting-a-rails-console-session)for your GitLab instance.\n\nTo create a personal access token programmatically:\n\n- Open a Rails console: ```text\nsudo gitlab-rails console\n```- Run the following commands to reference the username, the token, and the scopes. The token must be 20 characters long. The scopes must be valid and are visible [in the source code](https://gitlab.com/gitlab-org/gitlab/-/blob/master/lib/gitlab/auth.rb). For example, to create a token that belongs to a user with username `automation-bot` and expires in a year: ```text\nuser = User.find_by_username('automation-bot')\ntoken = user.personal_access_tokens.create(scopes: ['read_user', 'read_repository'], name: 'Automation token', expires_at: 365.days.from_now)\ntoken.set_token('token-string-here123')\ntoken.save!\n```\n\nThis code can be shortened into a single-line shell command by using the [Rails runner](https://docs.gitlab.com/administration/operations/rails_console/#using-the-rails-runner):\n\n```text\nsudo gitlab-rails runner \"token = User.find_by_username('automation-bot').personal_access_tokens.create(scopes: ['read_user', 'read_repository'], name: 'Automation token', expires_at: 365.days.from_now); token.set_token('token-string-here123'); token.save!\"\n```",
					"tokensEstimate": 400,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_16",
					"content": "## Revoke a personal access token programmatically\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab Self-Managed, GitLab Dedicated\n\nYou can programmatically revoke a personal access token as part of your tests or automation.\n\nPrerequisites:\n\n- You need sufficient access to run a [Rails console session](https://docs.gitlab.com/administration/operations/rails_console/#starting-a-rails-console-session)for your GitLab instance.\n\nTo revoke a token programmatically:\n\n- Open a Rails console: ```text\nsudo gitlab-rails console\n```- To revoke a token of `token-string-here123`, run the following commands: ```text\ntoken = PersonalAccessToken.find_by_token('token-string-here123')\ntoken.revoke!\n```\n\nThis code can be shortened into a single-line shell command using the [Rails runner](https://docs.gitlab.com/administration/operations/rails_console/#using-the-rails-runner):\n\n```text\nsudo gitlab-rails runner \"PersonalAccessToken.find_by_token('token-string-here123').revoke!\"\n```",
					"tokensEstimate": 243,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_17",
					"content": "## Clone repository using personal access token\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab Self-Managed, GitLab Dedicated\n\nTo clone a repository when SSH is disabled, clone it using a personal access token by running the following command:\n\n```bash\ngit clone https://<username>:<personal_token>@gitlab.com/gitlab-org/gitlab.git\n```\n\nThis method saves your personal access token in your bash history. To avoid this, run the following command:\n\n```bash\ngit clone https://<username>@gitlab.com/gitlab-org/gitlab.git\n```\n\nWhen asked for your password for `https://gitlab.com`, enter your personal access token.\n\nThe `username` in the `clone` command:\n\n- Can be any string value.- Must not be an empty string.\n\nRemember this if you set up an automation pipeline that depends on authentication.\n\n## Troubleshooting",
					"tokensEstimate": 202,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_18",
					"content": "### Unrevoke a personal access token\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab Self-Managed, GitLab Dedicated\n\nIf a personal access token is revoked accidentally by any method, administrators can unrevoke that token. By default, a daily job deletes revoked tokens at 1:00 AM system time.\n\nRunning the following commands changes data directly. This could be damaging if not done correctly, or under the right conditions. You should first run these commands in a test environment with a backup of the instance ready to be restored, just in case.\n\n- Open a [Rails console](https://docs.gitlab.com/administration/operations/rails_console/#starting-a-rails-console-session).- Unrevoke the token: ```text\ntoken = PersonalAccessToken.find_by_token('<token_string>')\ntoken.update!(revoked:false)\n``` For example, to unrevoke a token of `token-string-here123`: ```text\ntoken = PersonalAccessToken.find_by_token('token-string-here123')\ntoken.update!(revoked:false)\n```",
					"tokensEstimate": 241,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				},
				{
					"id": "user_profile_personal_access_tokens_chunk_19",
					"content": "## Alternatives to personal access tokens\n\nFor Git over HTTPS, an alternative to personal access tokens is to use an OAuth credential helper.\n\nFor authentication in CI/CD jobs, consider:\n\n- [CI/CD job tokens](https://docs.gitlab.com/ci/jobs/ci_job_token/)with [fine-grained permissions](https://docs.gitlab.com/ci/jobs/fine_grained_permissions/)for pipeline authentication- [Project access tokens](https://docs.gitlab.com/user/project/settings/project_access_tokens/)with minimal required permissions for project-specific automation\n\n- [Group access tokens](https://docs.gitlab.com/user/group/settings/group_access_tokens/)\n- [Project access tokens](https://docs.gitlab.com/user/project/settings/project_access_tokens/)\n- [Personal access tokens API](https://docs.gitlab.com/api/personal_access_tokens/)",
					"tokensEstimate": 200,
					"sourceUrl": "https://docs.gitlab.com/user/profile/personal_access_tokens",
					"pageTitle": "Personal access tokens | GitLab Docs"
				}
			],
			"metadata": {
				"url": "https://docs.gitlab.com/user/profile/personal_access_tokens",
				"title": "Personal access tokens | GitLab Docs",
				"depth": 1,
				"crawledAt": "2026-02-02T06:03:17.769Z",
				"tokensEstimate": 6272
			}
		},
		{
			"url": "https://docs.gitlab.com/user/ssh",
			"title": "Use SSH keys with GitLab",
			"markdown": "- Tier: Free, Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nUse SSH keys to securely authenticate with GitLab without entering your username and password each time you push or pull code.\n\nTo use SSH keys with GitLab, you must:\n\n- Generate an SSH key pair on your local system.- Add your SSH key to your GitLab account.- Verify your connection to GitLab.\n\n## What are SSH keys\n\nSSH uses two keys, a public key and a private key.\n\n- The public key can be distributed.- The private key should be protected.\n\nIt is not possible to reveal confidential data by uploading your public key. When you need to copy or upload your SSH public key, make sure you do not accidentally copy or upload your private key instead.\n\nYou can use your private key to [sign commits](https://docs.gitlab.com/user/project/repository/signed_commits/ssh/), which makes your use of GitLab and your data even more secure. This signature then can be verified by anyone using your public key.\n\nFor details, see [Asymmetric cryptography, also known as public-key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography).\n\n## Prerequisites\n\nTo use SSH to communicate with GitLab, you need:\n\n- The OpenSSH client, which comes pre-installed on GNU/Linux, macOS, and Windows 10.- SSH version 6.5 or later. Earlier versions used an MD5 signature, which is not secure.\n\nTo view the version of SSH installed on your system, run `ssh -V`.\n\n## Supported SSH key types\n\nTo communicate with GitLab, you can use the following SSH key types:\n\nAlgorithm\n\nNotes\n\nED25519 (preferred)\n\nMore secure and performant than RSA keys. Introduced in OpenSSH 6.5 (2014) and available on most operating systems. Might not be fully supported by all FIPS systems. For more information, see [issue 367429](https://gitlab.com/gitlab-org/gitlab/-/issues/367429).\n\nED25519\\_SK\n\nRequires OpenSSH 8.2 or later on both your local client and the GitLab server.\n\nECDSA\\_SK\n\nRequires OpenSSH 8.2 or later on both your local client and the GitLab server.\n\nRSA\n\nLess secure than ED25519. If used, GitLab recommends a key size of at least 4096 bits. Maximum key length is 8192 bits due to Go limitations. Default key size depends on your `ssh-keygen` version.\n\nECDSA\n\n[Security issues](https://leanpub.com/gocrypto/read#leanpub-auto-ecdsa) related to DSA also apply to ECDSA keys.\n\n## Check for existing SSH key pairs\n\nBefore you create a key pair, see if a key pair already exists.\n\n- Go to your home directory.- Go to the `.ssh/`subdirectory. If the `.ssh/`subdirectory doesn’t exist, you are either not in the home directory, or you haven’t used `ssh`before. In the latter case, you need to [generate an SSH key pair](https://docs.gitlab.com/user/ssh/#generate-an-ssh-key-pair).- See if a file with one of the following formats exists: Algorithm\n\nPublic key\n\nPrivate key\n\nED25519 (preferred)\n\n`id_ed25519.pub`\n\n`id_ed25519`\n\nED25519\\_SK\n\n`id_ed25519_sk.pub`\n\n`id_ed25519_sk`\n\nECDSA\\_SK\n\n`id_ecdsa_sk.pub`\n\n`id_ecdsa_sk`\n\nRSA (at least 4096-bit key size)\n\n`id_rsa.pub`\n\n`id_rsa`\n\nDSA (deprecated)\n\n`id_dsa.pub`\n\n`id_dsa`\n\nECDSA\n\n`id_ecdsa.pub`\n\n`id_ecdsa`\n\n## Generate an SSH key pair\n\nIf you do not have an existing SSH key pair, generate a new one:\n\n- Open a terminal.- Run `ssh-keygen -t` with the key type and an optional comment to help identify the key later. A common option is to use your email address as the comment. The comment is included in the `.pub` file. For example, for ED25519: ```text\nssh-keygen -t ed25519 -C \"<comment>\"\n``` For 4096-bit RSA: ```text\nssh-keygen -t rsa -b 4096 -C \"<comment>\"\n```- Press Enter. Output similar to the following is displayed: ```python\nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/home/user/.ssh/id_ed25519):\n```- Accept the suggested filename and directory, unless you are generating a [deploy key](https://docs.gitlab.com/user/project/deploy_keys/) or want to save in a specific directory where you store other keys. You can also dedicate the SSH key pair to a [specific host](https://docs.gitlab.com/user/ssh_advanced/#use-ssh-keys-in-another-directory).- Specify a [passphrase](https://www.ssh.com/academy/ssh/passphrase): ```python\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\n``` A confirmation is displayed, including information about where your files are stored. A public and private key are generated.- Add the private SSH key to `ssh-agent`. For example, for ED25519: ```text\nssh-add ~/.ssh/id_ed25519\n```\n\n## Add an SSH key to your GitLab account\n\nTo use SSH with GitLab, copy your public key to your GitLab account. GitLab cannot access your private key.\n\nWhen you add an SSH key, GitLab checks it against a list of known compromised keys. You cannot add compromised keys because the associated private keys are publicly known and could be used to access accounts. This restriction cannot be configured.\n\nIf your key is blocked, [generate a new SSH key pair](https://docs.gitlab.com/user/ssh/#generate-an-ssh-key-pair).\n\nTo add an SSH key to your GitLab account:\n\n- Copy the contents of your public key file. You can do this manually or use a script. In these examples, replace `id_ed25519.pub` with your filename. For example, for RSA, use `id_rsa.pub`. ```text\ntr -d '\\n' < ~/.ssh/id_ed25519.pub | pbcopy\n```\n\n```text\nxclip -sel clip < ~/.ssh/id_ed25519.pub\n```\n\n```text\ncat ~/.ssh/id_ed25519.pub | clip\n```- Sign in to GitLab.- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **SSH Keys**.- Select **Add new key**.- In the **Key** box, paste the contents of your public key. If you manually copied the key, make sure you copy the entire key, which starts with `ssh-rsa`, `ssh-dss`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, `ecdsa-sha2-nistp521`, `ssh-ed25519`, `sk-ecdsa-sha2-nistp256@openssh.com`, or `sk-ssh-ed25519@openssh.com`, and may end with a comment.- In the **Title** box, type a description, like `Work Laptop` or `Home Workstation`.- Optional. Select the **Usage type** of the key. It can be used either for `Authentication` or `Signing` or both. `Authentication & Signing` is the default value.- Optional. Update **Expiration date** to modify the default expiration date. For more information, see [SSH key expiration](https://docs.gitlab.com/user/ssh/#ssh-key-expiration).- Select **Add key**.\n\n## Verify your SSH connection\n\nVerify that your SSH key was added correctly, and that you can connect to the GitLab instance:\n\n- To ensure you connect to the correct server, identify the SSH host key fingerprint:\n - For GitLab.com, see the [SSH host keys fingerprints](https://docs.gitlab.com/user/gitlab_com/#ssh-host-keys-fingerprints)documentation.- For GitLab Self-Managed or GitLab Dedicated, see `https://gitlab.example.com/help/instance_configuration#ssh-host-keys-fingerprints`where `gitlab.example.com`is the GitLab instance URL.- Open a terminal and run this command:\n - For GitLab.com, use `ssh -T git@gitlab.com`.- For GitLab Self-Managed or GitLab Dedicated, use `ssh -T git@gitlab.example.com`where `gitlab.example.com`is the GitLab instance URL.\n\nBy default, connections use the `git` username, but GitLab Self-Managed or GitLab Dedicated administrators can [change the username](https://docs.gitlab.com/omnibus/settings/configuration.html#change-the-name-of-the-git-user-or-group).\n\n- On your first connection, you might need to verify the authenticity of the GitLab host. Follow the on-screen prompts if you see a message like: ```text\nThe authenticity of host 'gitlab.example.com (35.231.145.151)' can't be established.\nECDSA key fingerprint is SHA256:HbW3g8zUjNSksFbqTiUWPWg2Bq1x8xdGUrliXFzSnUw.\nAre you sure you want to continue connecting (yes/no)?\n``` You should receive a welcome message. ```text\nWelcome to GitLab, <username>!\n``` If the message doesn’t appear, you can [troubleshoot your SSH connection](https://docs.gitlab.com/user/ssh_troubleshooting/#general-ssh-troubleshooting).\n\n## View your SSH keys\n\nTo view the SSH keys for your account:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **SSH Keys**.\n\nYour existing SSH keys are listed at the bottom of the page. The information includes:\n\n- The title for the key- Public fingerprint- Permitted usage types- Creation date- Last used date- Expiry date\n\n## Remove an SSH key\n\nYou can revoke or delete your SSH key to permanently remove it from your account.\n\nRemoving your SSH key has additional implications if you sign your commits with the key. For more information, see [Signed commits with removed SSH keys](https://docs.gitlab.com/user/project/repository/signed_commits/ssh/#signed-commits-with-removed-ssh-keys).\n\n### Revoke an SSH key\n\nIf your SSH key becomes compromised, revoke the key.\n\nPrerequisites:\n\n- The SSH key must have the `Signing`or `Authentication & Signing`usage type.\n\nTo revoke an SSH key:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **SSH Keys**.- Next to the SSH key you want to revoke, select **Revoke**.- Select **Revoke**.\n\n### Delete an SSH key\n\nTo delete an SSH key:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **SSH Keys**.- Next to the key you want to delete, select **Remove**( remove).- Select **Delete**.\n\n## SSH key expiration\n\nYou can set an expiration date when you add an SSH key to your account. This optional setting helps limit the risk of a security breach.\n\nAfter your SSH key expires, you can no longer use it to authenticate or sign commits. You must [generate a new SSH key](https://docs.gitlab.com/user/ssh/#generate-an-ssh-key-pair) and [add it to your account](https://docs.gitlab.com/user/ssh/#add-an-ssh-key-to-your-gitlab-account).\n\nOn GitLab Self-Managed and GitLab Dedicated, administrators can view expiration dates and use them for guidance when [deleting keys](https://docs.gitlab.com/administration/credentials_inventory/#delete-ssh-keys).\n\nGitLab checks daily for expiring SSH keys and sends notifications:\n\n- At 01:00 AM UTC, seven days before expiration.- At 02:00 AM UTC on the expiration date.",
			"chunks": [
				{
					"id": "user_ssh_chunk_1",
					"content": "- Tier: Free, Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nUse SSH keys to securely authenticate with GitLab without entering your username and password each time you push or pull code.\n\nTo use SSH keys with GitLab, you must:\n\n- Generate an SSH key pair on your local system.- Add your SSH key to your GitLab account.- Verify your connection to GitLab.",
					"tokensEstimate": 96,
					"sourceUrl": "https://docs.gitlab.com/user/ssh",
					"pageTitle": "Use SSH keys with GitLab"
				},
				{
					"id": "user_ssh_chunk_2",
					"content": "## What are SSH keys\n\nSSH uses two keys, a public key and a private key.\n\n- The public key can be distributed.- The private key should be protected.\n\nIt is not possible to reveal confidential data by uploading your public key. When you need to copy or upload your SSH public key, make sure you do not accidentally copy or upload your private key instead.\n\nYou can use your private key to [sign commits](https://docs.gitlab.com/user/project/repository/signed_commits/ssh/), which makes your use of GitLab and your data even more secure. This signature then can be verified by anyone using your public key.\n\nFor details, see [Asymmetric cryptography, also known as public-key cryptography](https://en.wikipedia.org/wiki/Public-key_cryptography).\n\n## Prerequisites\n\nTo use SSH to communicate with GitLab, you need:\n\n- The OpenSSH client, which comes pre-installed on GNU/Linux, macOS, and Windows 10.- SSH version 6.5 or later. Earlier versions used an MD5 signature, which is not secure.\n\nTo view the version of SSH installed on your system, run `ssh -V`.",
					"tokensEstimate": 261,
					"sourceUrl": "https://docs.gitlab.com/user/ssh",
					"pageTitle": "Use SSH keys with GitLab"
				},
				{
					"id": "user_ssh_chunk_3",
					"content": "## Supported SSH key types\n\nTo communicate with GitLab, you can use the following SSH key types:\n\nAlgorithm\n\nNotes\n\nED25519 (preferred)\n\nMore secure and performant than RSA keys. Introduced in OpenSSH 6.5 (2014) and available on most operating systems. Might not be fully supported by all FIPS systems. For more information, see [issue 367429](https://gitlab.com/gitlab-org/gitlab/-/issues/367429).\n\nED25519\\_SK\n\nRequires OpenSSH 8.2 or later on both your local client and the GitLab server.\n\nECDSA\\_SK\n\nRequires OpenSSH 8.2 or later on both your local client and the GitLab server.\n\nRSA\n\nLess secure than ED25519. If used, GitLab recommends a key size of at least 4096 bits. Maximum key length is 8192 bits due to Go limitations. Default key size depends on your `ssh-keygen` version.\n\nECDSA\n\n[Security issues](https://leanpub.com/gocrypto/read#leanpub-auto-ecdsa) related to DSA also apply to ECDSA keys.",
					"tokensEstimate": 224,
					"sourceUrl": "https://docs.gitlab.com/user/ssh",
					"pageTitle": "Use SSH keys with GitLab"
				},
				{
					"id": "user_ssh_chunk_4",
					"content": "## Check for existing SSH key pairs\n\nBefore you create a key pair, see if a key pair already exists.\n\n- Go to your home directory.- Go to the `.ssh/`subdirectory. If the `.ssh/`subdirectory doesn’t exist, you are either not in the home directory, or you haven’t used `ssh`before. In the latter case, you need to [generate an SSH key pair](https://docs.gitlab.com/user/ssh/#generate-an-ssh-key-pair).- See if a file with one of the following formats exists: Algorithm\n\nPublic key\n\nPrivate key\n\nED25519 (preferred)\n\n`id_ed25519.pub`\n\n`id_ed25519`\n\nED25519\\_SK\n\n`id_ed25519_sk.pub`\n\n`id_ed25519_sk`\n\nECDSA\\_SK\n\n`id_ecdsa_sk.pub`\n\n`id_ecdsa_sk`\n\nRSA (at least 4096-bit key size)\n\n`id_rsa.pub`\n\n`id_rsa`\n\nDSA (deprecated)\n\n`id_dsa.pub`\n\n`id_dsa`\n\nECDSA\n\n`id_ecdsa.pub`\n\n`id_ecdsa`",
					"tokensEstimate": 189,
					"sourceUrl": "https://docs.gitlab.com/user/ssh",
					"pageTitle": "Use SSH keys with GitLab"
				},
				{
					"id": "user_ssh_chunk_5",
					"content": "## Generate an SSH key pair\n\nIf you do not have an existing SSH key pair, generate a new one:\n\n- Open a terminal.- Run `ssh-keygen -t` with the key type and an optional comment to help identify the key later. A common option is to use your email address as the comment. The comment is included in the `.pub` file. For example, for ED25519: ```text\nssh-keygen -t ed25519 -C \"<comment>\"\n``` For 4096-bit RSA: ```text\nssh-keygen -t rsa -b 4096 -C \"<comment>\"\n```- Press Enter. Output similar to the following is displayed: ```python\nGenerating public/private ed25519 key pair.\nEnter file in which to save the key (/home/user/.ssh/id_ed25519):\n```- Accept the suggested filename and directory, unless you are generating a [deploy key](https://docs.gitlab.com/user/project/deploy_keys/) or want to save in a specific directory where you store other keys. You can also dedicate the SSH key pair to a [specific host](https://docs.gitlab.com/user/ssh_advanced/#use-ssh-keys-in-another-directory).- Specify a [passphrase](https://www.ssh.com/academy/ssh/passphrase): ```python\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\n``` A confirmation is displayed, including information about where your files are stored. A public and private key are generated.- Add the private SSH key to `ssh-agent`. For example, for ED25519: ```text\nssh-add ~/.ssh/id_ed25519\n```",
					"tokensEstimate": 344,
					"sourceUrl": "https://docs.gitlab.com/user/ssh",
					"pageTitle": "Use SSH keys with GitLab"
				},
				{
					"id": "user_ssh_chunk_6",
					"content": "## Add an SSH key to your GitLab account\n\nTo use SSH with GitLab, copy your public key to your GitLab account. GitLab cannot access your private key.\n\nWhen you add an SSH key, GitLab checks it against a list of known compromised keys. You cannot add compromised keys because the associated private keys are publicly known and could be used to access accounts. This restriction cannot be configured.\n\nIf your key is blocked, [generate a new SSH key pair](https://docs.gitlab.com/user/ssh/#generate-an-ssh-key-pair).\n\nTo add an SSH key to your GitLab account:\n\n- Copy the contents of your public key file. You can do this manually or use a script. In these examples, replace `id_ed25519.pub` with your filename. For example, for RSA, use `id_rsa.pub`. ```text\ntr -d '\\n' < ~/.ssh/id_ed25519.pub | pbcopy\n```\n\n```text\nxclip -sel clip < ~/.ssh/id_ed25519.pub\n```\n\n```text\ncat ~/.ssh/id_ed25519.pub | clip\n```- Sign in to GitLab.- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **SSH Keys**.- Select **Add new key**.- In the **Key** box, paste the contents of your public key. If you manually copied the key, make sure you copy the entire key, which starts with `ssh-rsa`, `ssh-dss`, `ecdsa-sha2-nistp256`, `ecdsa-sha2-nistp384`, `ecdsa-sha2-nistp521`, `ssh-ed25519`, `sk-ecdsa-sha2-nistp256@openssh.com`, or `sk-ssh-ed25519@openssh.com`, and may end with a comment.- In the **Title** box, type a description, like `Work Laptop` or `Home Workstation`.- Optional. Select the **Usage type** of the key. It can be used either for `Authentication` or `Signing` or both. `Authentication & Signing` is the default value.- Optional. Update **Expiration date** to modify the default expiration date. For more information, see [SSH key expiration](https://docs.gitlab.com/user/ssh/#ssh-key-expiration).- Select **Add key**.",
					"tokensEstimate": 465,
					"sourceUrl": "https://docs.gitlab.com/user/ssh",
					"pageTitle": "Use SSH keys with GitLab"
				},
				{
					"id": "user_ssh_chunk_7",
					"content": "## Verify your SSH connection\n\nVerify that your SSH key was added correctly, and that you can connect to the GitLab instance:\n\n- To ensure you connect to the correct server, identify the SSH host key fingerprint:\n - For GitLab.com, see the [SSH host keys fingerprints](https://docs.gitlab.com/user/gitlab_com/#ssh-host-keys-fingerprints)documentation.- For GitLab Self-Managed or GitLab Dedicated, see `https://gitlab.example.com/help/instance_configuration#ssh-host-keys-fingerprints`where `gitlab.example.com`is the GitLab instance URL.- Open a terminal and run this command:\n - For GitLab.com, use `ssh -T git@gitlab.com`.- For GitLab Self-Managed or GitLab Dedicated, use `ssh -T git@gitlab.example.com`where `gitlab.example.com`is the GitLab instance URL.\n\nBy default, connections use the `git` username, but GitLab Self-Managed or GitLab Dedicated administrators can [change the username](https://docs.gitlab.com/omnibus/settings/configuration.html#change-the-name-of-the-git-user-or-group).\n\n- On your first connection, you might need to verify the authenticity of the GitLab host. Follow the on-screen prompts if you see a message like: ```text\nThe authenticity of host 'gitlab.example.com (35.231.145.151)' can't be established.\nECDSA key fingerprint is SHA256:HbW3g8zUjNSksFbqTiUWPWg2Bq1x8xdGUrliXFzSnUw.\nAre you sure you want to continue connecting (yes/no)?\n``` You should receive a welcome message. ```text\nWelcome to GitLab, <username>!\n``` If the message doesn’t appear, you can [troubleshoot your SSH connection](https://docs.gitlab.com/user/ssh_troubleshooting/#general-ssh-troubleshooting).\n\n## View your SSH keys\n\nTo view the SSH keys for your account:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **SSH Keys**.\n\nYour existing SSH keys are listed at the bottom of the page. The information includes:\n\n- The title for the key- Public fingerprint- Permitted usage types- Creation date- Last used date- Expiry date\n\n## Remove an SSH key\n\nYou can revoke or delete your SSH key to permanently remove it from your account.\n\nRemoving your SSH key has additional implications if you sign your commits with the key. For more information, see [Signed commits with removed SSH keys](https://docs.gitlab.com/user/project/repository/signed_commits/ssh/#signed-commits-with-removed-ssh-keys).\n\n### Revoke an SSH key\n\nIf your SSH key becomes compromised, revoke the key.\n\nPrerequisites:\n\n- The SSH key must have the `Signing`or `Authentication & Signing`usage type.\n\nTo revoke an SSH key:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **SSH Keys**.- Next to the SSH key you want to revoke, select **Revoke**.- Select **Revoke**.\n\n### Delete an SSH key\n\nTo delete an SSH key:\n\n- In the upper-right corner, select your avatar.- Select **Edit profile**.- On the left sidebar, select **SSH Keys**.- Next to the key you want to delete, select **Remove**( remove).- Select **Delete**.",
					"tokensEstimate": 745,
					"sourceUrl": "https://docs.gitlab.com/user/ssh",
					"pageTitle": "Use SSH keys with GitLab"
				},
				{
					"id": "user_ssh_chunk_8",
					"content": "## SSH key expiration\n\nYou can set an expiration date when you add an SSH key to your account. This optional setting helps limit the risk of a security breach.\n\nAfter your SSH key expires, you can no longer use it to authenticate or sign commits. You must [generate a new SSH key](https://docs.gitlab.com/user/ssh/#generate-an-ssh-key-pair) and [add it to your account](https://docs.gitlab.com/user/ssh/#add-an-ssh-key-to-your-gitlab-account).\n\nOn GitLab Self-Managed and GitLab Dedicated, administrators can view expiration dates and use them for guidance when [deleting keys](https://docs.gitlab.com/administration/credentials_inventory/#delete-ssh-keys).\n\nGitLab checks daily for expiring SSH keys and sends notifications:\n\n- At 01:00 AM UTC, seven days before expiration.- At 02:00 AM UTC on the expiration date.",
					"tokensEstimate": 203,
					"sourceUrl": "https://docs.gitlab.com/user/ssh",
					"pageTitle": "Use SSH keys with GitLab"
				}
			],
			"metadata": {
				"url": "https://docs.gitlab.com/user/ssh",
				"title": "Use SSH keys with GitLab",
				"depth": 1,
				"crawledAt": "2026-02-02T06:03:18.054Z",
				"tokensEstimate": 2525
			}
		},
		{
			"url": "https://docs.gitlab.com/user/get_started",
			"title": "Get started with GitLab",
			"markdown": "* * *\n\n## Get started with GitLab\n\nIf you’re new to GitLab, get started learning about how GitLab works.\n\n[Get started with Git\n\nWork with the Git version control system.](/topics/git/get_started/)[Get started with GitLab Duo\n\nUse AI-native features throughout your development lifecycle.](/user/get_started/getting_started_gitlab_duo/)[Get started organizing work with projects\n\nConfigure projects to suit your organization.](/user/get_started/get_started_projects/)[Get started planning work\n\nPlan and execute on work.](/user/get_started/get_started_planning_work/)[Get started managing code\n\nBuild, track, and deliver the code for your project.](/user/get_started/get_started_managing_code/)[Get started with GitLab CI/CD\n\nBuild and test your application.](/ci/)[Get started with GitLab Runner\n\nSet up and manage GitLab Runner.](/user/get_started/get_started_runner/)[Get started securing your application\n\nTest your application and resolve vulnerabilities.](/user/application_security/get-started-security/)[Get started deploying and releasing your application\n\nDeploy and manage dependencies.](/user/get_started/get_started_deploy_release/)[Get started managing your infrastructure\n\nEmploy best practices for managing your infrastructure.](/user/get_started/get_started_managing_infrastructure/)[Get started with monitoring your application in GitLab\n\nMonitor your app and respond to incidents.](/user/get_started/get_started_monitoring/)[Get started extending GitLab\n\nInteract programmatically with GitLab.](/api/get_started/get_started_extending/)",
			"chunks": [
				{
					"id": "user_get_started_chunk_1",
					"content": "* * *",
					"tokensEstimate": 2,
					"sourceUrl": "https://docs.gitlab.com/user/get_started",
					"pageTitle": "Get started with GitLab"
				},
				{
					"id": "user_get_started_chunk_2",
					"content": "## Get started with GitLab\n\nIf you’re new to GitLab, get started learning about how GitLab works.\n\n[Get started with Git\n\nWork with the Git version control system.](/topics/git/get_started/)[Get started with GitLab Duo\n\nUse AI-native features throughout your development lifecycle.](/user/get_started/getting_started_gitlab_duo/)[Get started organizing work with projects\n\nConfigure projects to suit your organization.](/user/get_started/get_started_projects/)[Get started planning work\n\nPlan and execute on work.](/user/get_started/get_started_planning_work/)[Get started managing code\n\nBuild, track, and deliver the code for your project.](/user/get_started/get_started_managing_code/)[Get started with GitLab CI/CD\n\nBuild and test your application.](/ci/)[Get started with GitLab Runner\n\nSet up and manage GitLab Runner.](/user/get_started/get_started_runner/)[Get started securing your application\n\nTest your application and resolve vulnerabilities.](/user/application_security/get-started-security/)[Get started deploying and releasing your application\n\nDeploy and manage dependencies.](/user/get_started/get_started_deploy_release/)[Get started managing your infrastructure\n\nEmploy best practices for managing your infrastructure.](/user/get_started/get_started_managing_infrastructure/)[Get started with monitoring your application in GitLab\n\nMonitor your app and respond to incidents.](/user/get_started/get_started_monitoring/)[Get started extending GitLab\n\nInteract programmatically with GitLab.](/api/get_started/get_started_extending/)",
					"tokensEstimate": 384,
					"sourceUrl": "https://docs.gitlab.com/user/get_started",
					"pageTitle": "Get started with GitLab"
				}
			],
			"metadata": {
				"url": "https://docs.gitlab.com/user/get_started",
				"title": "Get started with GitLab",
				"depth": 1,
				"crawledAt": "2026-02-02T06:03:18.339Z",
				"tokensEstimate": 385
			}
		},
		{
			"url": "https://docs.gitlab.com/ci/yaml",
			"title": "CI/CD YAML syntax reference | GitLab Docs",
			"markdown": "- Tier: Free, Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nThis document lists the configuration options for the GitLab `.gitlab-ci.yml` file. This file is where you define the CI/CD jobs that make up your pipeline.\n\n- If you are already familiar with [basic CI/CD concepts](https://docs.gitlab.com/ci/), try creating your own `.gitlab-ci.yml`file by following a tutorial that demonstrates a [simple](https://docs.gitlab.com/ci/quick_start/)or [complex](https://docs.gitlab.com/ci/quick_start/tutorial/)pipeline.- For a collection of examples, see [GitLab CI/CD examples](https://docs.gitlab.com/ci/examples/).- To view a large `.gitlab-ci.yml`file used in an enterprise, see the [.gitlab-ci.yml file for gitlab](https://gitlab.com/gitlab-org/gitlab/-/blob/master/.gitlab-ci.yml).\n\nWhen you are editing your `.gitlab-ci.yml` file, you can validate it with the [CI Lint](https://docs.gitlab.com/ci/yaml/lint/) tool.\n\nGitLab CI/CD configuration uses YAML formatting, so the order of keywords is not important unless otherwise specified.\n\nUse [CI/CD expressions](https://docs.gitlab.com/ci/yaml/expressions/) for more dynamic pipeline configuration options.\n\n### Keywords\n\nA GitLab CI/CD pipeline configuration includes:\n\n- [Global keywords](https://docs.gitlab.com/ci/yaml/#global-keywords) that configure pipeline behavior: Keyword\n\nDescription\n\n[`default`](https://docs.gitlab.com/ci/yaml/#default)\n\nCustom default values for job keywords.\n\n[`include`](https://docs.gitlab.com/ci/yaml/#include)\n\nImport configuration from other YAML files.\n\n[`stages`](https://docs.gitlab.com/ci/yaml/#stages)\n\nThe names and order of the pipeline stages.\n\n[`variables`](https://docs.gitlab.com/ci/yaml/#default-variables)\n\nDefine default CI/CD variables for all jobs in the pipeline.\n\n[`workflow`](https://docs.gitlab.com/ci/yaml/#workflow)\n\nControl what types of pipeline run.- [Header keywords](https://docs.gitlab.com/ci/yaml/#header-keywords) Keyword\n\nDescription\n\n[`spec`](https://docs.gitlab.com/ci/yaml/#spec)\n\nDefine specifications for external configuration files.- [Jobs](https://docs.gitlab.com/ci/jobs/) configured with [job keywords](https://docs.gitlab.com/ci/yaml/#job-keywords): Keyword\n\nDescription\n\n[`after_script`](https://docs.gitlab.com/ci/yaml/#after_script)\n\nOverride a set of commands that are executed after job.\n\n[`allow_failure`](https://docs.gitlab.com/ci/yaml/#allow_failure)\n\nAllow job to fail. A failed job does not cause the pipeline to fail.\n\n[`artifacts`](https://docs.gitlab.com/ci/yaml/#artifacts)\n\nList of files and directories to attach to a job on success.\n\n[`before_script`](https://docs.gitlab.com/ci/yaml/#before_script)\n\nOverride a set of commands that are executed before job.\n\n[`cache`](https://docs.gitlab.com/ci/yaml/#cache)\n\nList of files that should be cached between subsequent runs.\n\n[`coverage`](https://docs.gitlab.com/ci/yaml/#coverage)\n\nCode coverage settings for a given job.\n\n[`dast_configuration`](https://docs.gitlab.com/ci/yaml/#dast_configuration)\n\nUse configuration from DAST profiles on a job level.\n\n[`dependencies`](https://docs.gitlab.com/ci/yaml/#dependencies)\n\nRestrict which artifacts are passed to a specific job by providing a list of jobs to fetch artifacts from.\n\n[`environment`](https://docs.gitlab.com/ci/yaml/#environment)\n\nName of an environment to which the job deploys.\n\n[`extends`](https://docs.gitlab.com/ci/yaml/#extends)\n\nConfiguration entries that this job inherits from.\n\n[`identity`](https://docs.gitlab.com/ci/yaml/#identity)\n\nAuthenticate with third party services using identity federation.\n\n[`image`](https://docs.gitlab.com/ci/yaml/#image)\n\nUse Docker images.\n\n[`inherit`](https://docs.gitlab.com/ci/yaml/#inherit)\n\nSelect which global defaults all jobs inherit.\n\n[`interruptible`](https://docs.gitlab.com/ci/yaml/#interruptible)\n\nDefines if a job can be canceled when made redundant by a newer run.\n\n[`manual_confirmation`](https://docs.gitlab.com/ci/yaml/#manual_confirmation)\n\nDefine a custom confirmation message for a manual job.\n\n[`needs`](https://docs.gitlab.com/ci/yaml/#needs)\n\nExecute jobs earlier than the stage ordering.\n\n[`pages`](https://docs.gitlab.com/ci/yaml/#pages)\n\nUpload the result of a job to use with GitLab Pages.\n\n[`parallel`](https://docs.gitlab.com/ci/yaml/#parallel)\n\nHow many instances of a job should be run in parallel.\n\n[`release`](https://docs.gitlab.com/ci/yaml/#release)\n\nInstructs the runner to generate a [release](https://docs.gitlab.com/user/project/releases/) object.\n\n[`resource_group`](https://docs.gitlab.com/ci/yaml/#resource_group)\n\nLimit job concurrency.\n\n[`retry`](https://docs.gitlab.com/ci/yaml/#retry)\n\nWhen and how many times a job can be auto-retried in case of a failure.\n\n[`rules`](https://docs.gitlab.com/ci/yaml/#rules)\n\nList of conditions to evaluate and determine selected attributes of a job, and whether or not it’s created.\n\n[`script`](https://docs.gitlab.com/ci/yaml/#script)\n\nShell script that is executed by a runner.\n\n[`run`](https://docs.gitlab.com/ci/yaml/#run)\n\nRun configuration that is executed by a runner.\n\n[`secrets`](https://docs.gitlab.com/ci/yaml/#secrets)\n\nThe CI/CD secrets the job needs.\n\n[`services`](https://docs.gitlab.com/ci/yaml/#services)\n\nUse Docker services images.\n\n[`stage`](https://docs.gitlab.com/ci/yaml/#stage)\n\nDefines a job stage.\n\n[`start_in`](https://docs.gitlab.com/ci/yaml/#start_in)\n\nDelay job execution for a specified duration. Requires `when: delayed`.\n\n[`tags`](https://docs.gitlab.com/ci/yaml/#tags)\n\nList of tags that are used to select a runner.\n\n[`timeout`](https://docs.gitlab.com/ci/yaml/#timeout)\n\nDefine a custom job-level timeout that takes precedence over the project-wide setting.\n\n[`trigger`](https://docs.gitlab.com/ci/yaml/#trigger)\n\nDefines a downstream pipeline trigger.\n\n[`variables`](https://docs.gitlab.com/ci/yaml/#job-variables)\n\nDefine CI/CD variables for individual jobs.\n\n[`when`](https://docs.gitlab.com/ci/yaml/#when)\n\nWhen to run job.- [Deprecated keywords](https://docs.gitlab.com/ci/yaml/deprecated_keywords/) that are no longer recommended for use.\n\n* * *\n\n### Global keywords\n\nSome keywords are not defined in a job. These keywords control pipeline behavior or import additional pipeline configuration.\n\n* * *\n\n#### `default`\n\nYou can set global defaults for some keywords. Each default keyword is copied to every job that doesn’t already have it defined.\n\nDefault configuration does not merge with job configuration. If the job already has a keyword defined, the job keyword takes precedence and the default configuration for that keyword is not used.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: These keywords can have custom defaults:\n\n- [after_script](https://docs.gitlab.com/ci/yaml/#after_script)\n- [artifacts](https://docs.gitlab.com/ci/yaml/#artifacts)\n- [before_script](https://docs.gitlab.com/ci/yaml/#before_script)\n- [cache](https://docs.gitlab.com/ci/yaml/#cache)\n- [hooks](https://docs.gitlab.com/ci/yaml/#hooks)\n- [id_tokens](https://docs.gitlab.com/ci/yaml/#id_tokens)\n- [image](https://docs.gitlab.com/ci/yaml/#image)\n- [interruptible](https://docs.gitlab.com/ci/yaml/#interruptible)\n- [retry](https://docs.gitlab.com/ci/yaml/#retry)\n- [services](https://docs.gitlab.com/ci/yaml/#services)\n- [tags](https://docs.gitlab.com/ci/yaml/#tags)\n- [timeout](https://docs.gitlab.com/ci/yaml/#timeout), though due to [issue 213634](https://gitlab.com/gitlab-org/gitlab/-/issues/213634)this keyword has no effect.\n\n**Example of `default`**:\n\n```python\ndefault:\nimage: ruby:3.0\nretry: 2\n\nrspec:\nscript: bundle exec rspec\n\nrspec 2.7:\nimage: ruby:2.7\nscript: bundle exec rspec\n```\n\nIn this example:\n\n- `image: ruby:3.0`and `retry: 2`are the default keywords for all jobs in the pipeline.- The `rspec`job does not have `image`or `retry`defined, so it uses the defaults of `image: ruby:3.0`and `retry: 2`.- The `rspec 2.7`job does not have `retry`defined, but it does have `image`explicitly defined. It uses the default `retry: 2`, but ignores the default `image`and uses the `image: ruby:2.7`defined in the job.\n\n**Additional details**:\n\n- Control inheritance of default keywords in jobs with [inherit:default](https://docs.gitlab.com/ci/yaml/#inheritdefault).- Global defaults are not passed to [downstream pipelines](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/), which run independently of the upstream pipeline that triggered the downstream pipeline.\n\n* * *\n\n#### `include`\n\nUse `include` to include external YAML files in your CI/CD configuration. You can split one long `.gitlab-ci.yml` file into multiple files to increase readability, or reduce duplication of the same configuration in multiple places.\n\nYou can also store template files in a central repository and include them in projects.\n\nThe `include` files are:\n\n- Merged with those in the `.gitlab-ci.yml`file.- Always evaluated first and then merged with the content of the `.gitlab-ci.yml`file, regardless of the position of the `include`keyword.\n\nThe time limit to resolve all files is 30 seconds.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: The `include` subkeys:\n\n- [include:component](https://docs.gitlab.com/ci/yaml/#includecomponent)\n- [include:local](https://docs.gitlab.com/ci/yaml/#includelocal)\n- [include:project](https://docs.gitlab.com/ci/yaml/#includeproject)\n- [include:remote](https://docs.gitlab.com/ci/yaml/#includeremote)\n- [include:template](https://docs.gitlab.com/ci/yaml/#includetemplate)\n\nAnd optionally:\n\n- [include:inputs](https://docs.gitlab.com/ci/yaml/#includeinputs)\n- [include:rules](https://docs.gitlab.com/ci/yaml/#includerules)\n- [include:integrity](https://docs.gitlab.com/ci/yaml/#includeintegrity)\n\n**Additional details**:\n\n- Only [certain CI/CD variables](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include)can be used with `include`keywords.- Use merging to customize and override included CI/CD configurations with local- You can override included configuration by having the same job name or global keyword in the `.gitlab-ci.yml`file. The two configurations are merged together, and the configuration in the `.gitlab-ci.yml`file takes precedence over the included configuration.- If you rerun a:\n - Job, the `include`files are not fetched again. All jobs in a pipeline use the configuration fetched when the pipeline was created. Any changes to the source `include`files do not affect job reruns.- Pipeline, the `include`files are fetched again. If they changed after the last pipeline run, the new pipeline uses the changed configuration.- You can have up to 150 includes per pipeline by default, including [nested](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes). Additionally:\n - In [GitLab 16.0 and later](https://gitlab.com/gitlab-org/gitlab/-/issues/207270)users on GitLab Self-Managed can change the [maximum includes](https://docs.gitlab.com/administration/settings/continuous_integration/#set-maximum-includes)value.- In [GitLab 15.10 and later](https://gitlab.com/gitlab-org/gitlab/-/issues/367150)you can have up to 150 includes. In nested includes, the same file can be included multiple times, but duplicated includes count towards the limit.- From [GitLab 14.9 to GitLab 15.9](https://gitlab.com/gitlab-org/gitlab/-/issues/28987), you can have up to 100 includes. The same file can be included multiple times in nested includes, but duplicates are ignored.\n\n* * *\n\n##### `include:component`\n\nUse `include:component` to add a [CI/CD component](https://docs.gitlab.com/ci/components/) to the pipeline configuration.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: The full address of the CI/CD component, formatted as `<fully-qualified-domain-name>/<project-path>/<component-name>@<specific-version>`.\n\n**Example of `include:component`**:\n\n```python\ninclude:\n - component: $CI_SERVER_FQDN/my-org/security-components/secret-detection@1.0\n```\n\n**Related topics**:\n\n- [Use a CI/CD component](https://docs.gitlab.com/ci/components/#use-a-component).\n\n* * *\n\n##### `include:local`\n\nUse `include:local` to include a file that is in the same repository and branch as the configuration file containing the `include` keyword. Use `include:local` instead of symbolic links.\n\n**Keyword type**: Global keyword.\n\n**Supported values**:\n\nA full path relative to the root directory (`/`):\n\n- The YAML file must have the extension `.yml`or `.yaml`.- You can [use * and ** wildcards in the file path](https://docs.gitlab.com/ci/yaml/includes/#use-includelocal-with-wildcard-file-paths).- You can use [certain CI/CD variables](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Example of `include:local`**:\n\n```python\ninclude:\n - local: '/templates/.gitlab-ci-template.yml'\n```\n\nYou can also use shorter syntax to define the path:\n\n```text\ninclude: '.gitlab-ci-production.yml'\n```\n\n**Additional details**:\n\n- The `.gitlab-ci.yml`file and the local file must be on the same branch.- You can’t include local files through Git submodules paths.- `include`configuration is always evaluated based on the location of the file containing the `include`keyword, not the project running the pipeline. If a [nested include](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes)is in a configuration file in a different project, `include: local`checks that other project for the file.\n\n* * *\n\n##### `include:project`\n\nTo include files from another private project on the same GitLab instance, use `include:project` and `include:file`.\n\n**Keyword type**: Global keyword.\n\n**Supported values**:\n\n- `include:project`: The full GitLab project path.- `include:file`A full file path, or array of file paths, relative to the root directory ( `/`). The YAML files must have the `.yml`or `.yaml`extension.- `include:ref`: Optional. The ref to retrieve the file from. Defaults to the `HEAD`of the project when not specified.- You can use [certain CI/CD variables](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Example of `include:project`**:\n\n```python\ninclude:\n - project: 'my-group/my-project'\nfile: '/templates/.gitlab-ci-template.yml'\n - project: 'my-group/my-subgroup/my-project-2'\nfile:\n - '/templates/.builds.yml'\n - '/templates/.tests.yml'\n```\n\nYou can also specify a `ref`:\n\n```python\ninclude:\n - project: 'my-group/my-project'\nref: main # Git branch\nfile: '/templates/.gitlab-ci-template.yml'\n - project: 'my-group/my-project'\nref: v1.0.0 # Git Tag\nfile: '/templates/.gitlab-ci-template.yml'\n - project: 'my-group/my-project'\nref: 787123b47f14b552955ca2786bc9542ae66fee5b # Git SHA\nfile: '/templates/.gitlab-ci-template.yml'\n```\n\n**Additional details**:\n\n- `include`configuration is always evaluated based on the location of the file containing the `include`keyword, not the project running the pipeline. If a [nested include](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes)is in a configuration file in a different project, `include: local`checks that other project for the file.- When the pipeline starts, the `.gitlab-ci.yml`file configuration included by all methods is evaluated. The configuration is a snapshot in time and persists in the database. GitLab does not reflect any changes to the referenced `.gitlab-ci.yml`file configuration until the next pipeline starts.- When you include a YAML file from another private project, the user running the pipeline must be a member of both projects and have the appropriate permissions to run pipelines. A `not found or access denied`error may be displayed if the user does not have access to any of the included files.- Be careful when including another project’s CI/CD configuration file. No pipelines or notifications trigger when CI/CD configuration files change. From a security perspective, this is similar to pulling a third-party dependency. For the `ref`, consider:\n - Using a specific SHA hash, which should be the most stable option. Use the full 40-character SHA hash to ensure the desired commit is referenced, because using a short SHA hash for the `ref`might be ambiguous.- Applying both [protected branch](https://docs.gitlab.com/user/project/repository/branches/protected/)and [protected tag](https://docs.gitlab.com/user/project/protected_tags/#prevent-tag-creation-with-branch-names)rules to the `ref`in the other project. Protected tags and branches are more likely to pass through change management before changing.\n\n* * *\n\n##### `include:remote`\n\nUse `include:remote` with a full URL to include a file from a different location.\n\n**Keyword type**: Global keyword.\n\n**Supported values**:\n\nA public URL accessible by an HTTP/HTTPS `GET` request:\n\n- Authentication with the remote URL is not supported.- The YAML file must have the extension `.yml`or `.yaml`.- You can use [certain CI/CD variables](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Example of `include:remote`**:\n\n```python\ninclude:\n - remote: 'https://gitlab.com/example-project/-/raw/main/.gitlab-ci.yml'\n```\n\n**Additional details**:\n\n- All [nested includes](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes)are executed without context as a public user, so you can only include public projects or templates. No variables are available in the `include`section of nested includes.- Be careful when including another project’s CI/CD configuration file. No pipelines or notifications trigger when the other project’s files change. From a security perspective, this is similar to pulling a third-party dependency. To verify the integrity of the included file, consider using the [integrity](https://docs.gitlab.com/ci/yaml/#includeintegrity)keyword. If you link to another GitLab project you own, consider the use of both [protected branches](https://docs.gitlab.com/user/project/repository/branches/protected/)and [protected tags](https://docs.gitlab.com/user/project/protected_tags/#prevent-tag-creation-with-branch-names)to enforce change management rules.\n\n* * *\n\n##### `include:template`\n\nUse `include:template` to include [`.gitlab-ci.yml` templates](https://gitlab.com/gitlab-org/gitlab/-/tree/master/lib/gitlab/ci/templates).\n\n**Keyword type**: Global keyword.\n\n**Supported values**:\n\nA [CI/CD template](https://docs.gitlab.com/ci/examples/#cicd-templates):\n\n- All templates can be viewed in [lib/gitlab/ci/templates](https://gitlab.com/gitlab-org/gitlab/-/tree/master/lib/gitlab/ci/templates). Not all templates are designed to be used with `include:template`, so check template comments before using one.- You can use [certain CI/CD variables](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Example of `include:template`**:\n\n```bash\n\n## File sourced from the GitLab template collection include:\n - template: Auto-DevOps.gitlab-ci.yml\n```\n\nMultiple `include:template` files:\n\n```python\ninclude:\n - template: Android-Fastlane.gitlab-ci.yml\n - template: Auto-DevOps.gitlab-ci.yml\n```\n\n**Additional details**:\n\n- All [nested includes](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes)are executed without context as a public user, so you can only include public projects or templates. No variables are available in the `include`section of nested includes.\n\n* * *\n\n##### `include:inputs`\n\nUse `include:inputs` to set the values for input parameters when the included configuration uses [`spec:inputs`](https://docs.gitlab.com/ci/yaml/#specinputs) and is added to the pipeline.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: A string, numeric value, or boolean.\n\n**Example of `include:inputs`**:\n\n```python\ninclude:\n - local: 'custom_configuration.yml'\ninputs:\nwebsite: \"My website\"\n```\n\nIn this example:\n\n- The configuration contained in `custom_configuration.yml`is added to the pipeline, with a `website`input set to a value of `My website`for the included configuration.\n\n**Additional details**:\n\n- If the included configuration file uses [spec:inputs:type](https://docs.gitlab.com/ci/yaml/#specinputstype), the input value must match the defined type.- If the included configuration file uses [spec:inputs:options](https://docs.gitlab.com/ci/yaml/#specinputsoptions), the input value must match one of the listed options.\n\n**Related topics**:\n\n- [Set input values when using include](https://docs.gitlab.com/ci/inputs/#for-configuration-added-with-include).\n\n* * *\n\n##### `include:rules`\n\nYou can use [`rules`](https://docs.gitlab.com/ci/yaml/#rules) with `include` to conditionally include other configuration files.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: These `rules` subkeys:\n\n- [rules:if](https://docs.gitlab.com/ci/yaml/#rulesif).- [rules:exists](https://docs.gitlab.com/ci/yaml/#rulesexists).- [rules:changes](https://docs.gitlab.com/ci/yaml/#ruleschanges).\n\nSome [CI/CD variables are supported](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Example of `include:rules`**:\n\n```python\ninclude:\n - local: build_jobs.yml\nrules:\n - if: $INCLUDE_BUILDS == \"true\"\n\ntest-job:\nstage: test\nscript: echo \"This is a test job\"\n```\n\nIn this example, if the `INCLUDE_BUILDS` variable is:\n\n- `true`, the `build_jobs.yml`configuration is included in the pipeline.- Not `true`or does not exist, the `build_jobs.yml`configuration is not included in the pipeline.\n\n**Related topics**:\n\n- Examples of using `include`with:\n - [rules:if](https://docs.gitlab.com/ci/yaml/includes/#include-with-rulesif).- [rules:changes](https://docs.gitlab.com/ci/yaml/includes/#include-with-ruleschanges).- [rules:exists](https://docs.gitlab.com/ci/yaml/includes/#include-with-rulesexists).\n\n* * *\n\n##### `include:integrity`\n\nUse `integrity` with `include:remote` to specify a SHA256 hash of the included remote file. If `integrity` does not match the actual content, the remote file is not processed and the pipeline fails.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: Base64-encoded SHA256 hash of the included content.\n\n**Example of `include:integrity`**:\n\n```python\ninclude:\n - remote: 'https://gitlab.com/example-project/-/raw/main/.gitlab-ci.yml'\nintegrity: 'sha256-L3/GAoKaw0Arw6hDCKeKQlV1QPEgHYxGBHsH4zG1IY8='\n```\n\n* * *\n\n#### `stages`\n\nUse `stages` to define stages that contain groups of jobs. Use [`stage`](https://docs.gitlab.com/ci/yaml/#stage) in a job to configure the job to run in a specific stage.\n\nIf `stages` is not defined in the `.gitlab-ci.yml` file, the default pipeline stages are:\n\n- [.pre](https://docs.gitlab.com/ci/yaml/#stage-pre)- `build`- `test`- `deploy`- [.post](https://docs.gitlab.com/ci/yaml/#stage-post)\n\nThe order of the items in `stages` defines the execution order for jobs:\n\n- Jobs in the same stage run in parallel.- Jobs in the next stage run after the jobs from the previous stage complete successfully.\n\nIf a pipeline contains only jobs in the `.pre` or `.post` stages, it does not run. There must be at least one other job in a different stage.\n\n**Keyword type**: Global keyword.\n\n**Example of `stages`**:\n\n```python\nstages:\n - build\n - test\n - deploy\n```\n\nIn this example:\n\n- All jobs in `build`execute in parallel.- If all jobs in `build`succeed, the `test`jobs execute in parallel.- If all jobs in `test`succeed, the `deploy`jobs execute in parallel.- If all jobs in `deploy`succeed, the pipeline is marked as `passed`.\n\nIf any job fails, the pipeline is marked as `failed` and jobs in later stages do not start. Jobs in the current stage are not stopped and continue to run.\n\n**Additional details**:\n\n- If a job does not specify a [stage](https://docs.gitlab.com/ci/yaml/#stage), the job is assigned the `test`stage.- If a stage is defined but no jobs use it, the stage is not visible in the pipeline, which can help [compliance pipeline configurations](https://docs.gitlab.com/user/compliance/compliance_pipelines/):\n - Stages can be defined in the compliance configuration but remain hidden if not used.- The defined stages become visible when developers use them in job definitions.\n\n**Related topics**:\n\n- To make a job start earlier and ignore the stage order, use the [needs](https://docs.gitlab.com/ci/yaml/#needs)keyword.\n\n* * *\n\n#### `workflow`\n\nUse [`workflow`](https://docs.gitlab.com/ci/yaml/workflow/) to control pipeline behavior.\n\nYou can use some [predefined CI/CD variables](https://docs.gitlab.com/ci/variables/predefined_variables/) in `workflow` configuration, but not variables that are only defined when jobs start.\n\n**Related topics**:\n\n- [workflow: rules examples](https://docs.gitlab.com/ci/yaml/workflow/#workflow-rules-examples)\n- [Switch between branch pipelines and merge request pipelines](https://docs.gitlab.com/ci/yaml/workflow/#switch-between-branch-pipelines-and-merge-request-pipelines)\n\n* * *\n\n##### `workflow:auto_cancel:on_new_commit`\n\nUse `workflow:auto_cancel:on_new_commit` to configure the behavior of the [auto-cancel redundant pipelines](https://docs.gitlab.com/ci/pipelines/settings/#auto-cancel-redundant-pipelines) feature.\n\n**Supported values**:\n\n- `conservative`: Cancel the pipeline, but only if no jobs with `interruptible: false`have started yet. Default when not defined.- `interruptible`: Cancel only jobs with `interruptible: true`.- `none`: Do not auto-cancel any jobs.\n\n**Example of `workflow:auto_cancel:on_new_commit`**:\n\n```python\nworkflow:\nauto_cancel:\non_new_commit: interruptible\n\njob1:\ninterruptible: true\nscript: sleep 60\n\njob2:\ninterruptible: false # Default when not defined.\nscript: sleep 60\n```\n\nIn this example:\n\n- When a new commit is pushed to a branch, GitLab creates a new pipeline and `job1`and `job2`start.- If a new commit is pushed to the branch before the jobs complete, only `job1`is canceled.\n\n* * *\n\n##### `workflow:auto_cancel:on_job_failure`\n\nUse `workflow:auto_cancel:on_job_failure` to configure which jobs should be canceled as soon as one job fails.\n\n**Supported values**:\n\n- `all`: Cancel the pipeline and all running jobs as soon as one job fails.- `none`: Do not auto-cancel any jobs.\n\n**Example of `workflow:auto_cancel:on_job_failure`**:\n\n```python\nstages: [stage_a, stage_b]\n\nworkflow:\nauto_cancel:\non_job_failure: all\n\njob1:\nstage: stage_a\nscript: sleep 60\n\njob2:\nstage: stage_a\nscript:\n - sleep 30\n - exit 1\n\njob3:\nstage: stage_b\nscript:\n - sleep 30\n```\n\nIn this example, if `job2` fails, `job1` is canceled if it is still running and `job3` does not start.\n\n**Related topics**:\n\n- [Auto-cancel the parent pipeline from a downstream pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#auto-cancel-the-parent-pipeline-from-a-downstream-pipeline)\n\n* * *\n\n##### `workflow:name`\n\nYou can use `name` in `workflow:` to define a name for pipelines.\n\nAll pipelines are assigned the defined name. Any leading or trailing spaces in the name are removed.\n\n**Supported values**:\n\n- A string.- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).- A combination of both.\n\n**Examples of `workflow:name`**:\n\nA simple pipeline name with a predefined variable:\n\n```python\nworkflow:\nname: 'Pipeline for branch: $CI_COMMIT_BRANCH'\n```\n\nA configuration with different pipeline names depending on the pipeline conditions:\n\n```python\nvariables:\nPROJECT1_PIPELINE_NAME: 'Default pipeline name' # A default is not required\n\nworkflow:\nname: '$PROJECT1_PIPELINE_NAME'\nrules:\n - if: '$CI_MERGE_REQUEST_LABELS =~ /pipeline:run-in-ruby3/'\nvariables:\nPROJECT1_PIPELINE_NAME: 'Ruby 3 pipeline'\n - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\nvariables:\nPROJECT1_PIPELINE_NAME: 'MR pipeline: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME'\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH # For default branch pipelines, use the default name\n```\n\n**Additional details**:\n\n- If the name is an empty string, the pipeline is not assigned a name. A name consisting of only CI/CD variables could evaluate to an empty string if all the variables are also empty.- `workflow:rules:variables`become [default variables](https://docs.gitlab.com/ci/yaml/#default-variables)available in all jobs, including [trigger](https://docs.gitlab.com/ci/yaml/#trigger)jobs which forward variables to downstream pipelines by default. If the downstream pipeline uses the same variable, the [variable is overwritten](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence)by the upstream variable value. Be sure to either:\n - Use a unique variable name in every project’s pipeline configuration, like `PROJECT1_PIPELINE_NAME`.- Use [inherit:variables](https://docs.gitlab.com/ci/yaml/#inheritvariables)in the trigger job and list the exact variables you want to forward to the downstream pipeline.\n\n* * *\n\n##### `workflow:rules`\n\nThe `rules` keyword in `workflow` is similar to [`rules` defined in jobs](https://docs.gitlab.com/ci/yaml/#rules), but controls whether or not a whole pipeline is created.\n\nWhen no rules evaluate to true, the pipeline does not run.\n\n**Supported values**: You can use some of the same keywords as job-level [`rules`](https://docs.gitlab.com/ci/yaml/#rules):\n\n- [rules: if](https://docs.gitlab.com/ci/yaml/#rulesif).- [rules: changes](https://docs.gitlab.com/ci/yaml/#ruleschanges).- [rules: exists](https://docs.gitlab.com/ci/yaml/#rulesexists).- [when](https://docs.gitlab.com/ci/yaml/#when), can only be `always`or `never`when used with `workflow`.- [variables](https://docs.gitlab.com/ci/yaml/#workflowrulesvariables).\n\n**Example of `workflow:rules`**:\n\n```python\nworkflow:\nrules:\n - if: $CI_COMMIT_TITLE =~ /-draft$/\nwhen: never\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n```\n\nIn this example, pipelines run if the commit title (first line of the commit message) does not end with `-draft` and the pipeline is for either:\n\n- A merge request- The default branch.\n\n**Additional details**:\n\n- If your rules match both branch pipelines (other than the default branch) and merge request pipelines, [duplicate pipelines](https://docs.gitlab.com/ci/jobs/job_rules/#avoid-duplicate-pipelines)can occur.- `start_in`, `allow_failure`, and `needs`are not supported in `workflow:rules`, but do not cause a syntax violation. Though they have no effect, do not use them in `workflow:rules`as it could cause syntax failures in the future. See [issue 436473](https://gitlab.com/gitlab-org/gitlab/-/issues/436473)for more details.\n\n**Related topics**:\n\n- [Common if clauses for workflow:rules](https://docs.gitlab.com/ci/yaml/workflow/#common-if-clauses-for-workflowrules).- [Use rules to run merge request pipelines](https://docs.gitlab.com/ci/pipelines/merge_request_pipelines/#configure-merge-request-pipelines).\n\n* * *\n\n##### `workflow:rules:variables`\n\nYou can use [`variables`](https://docs.gitlab.com/ci/yaml/#variables) in `workflow:rules` to define variables for specific pipeline conditions.\n\nWhen the condition matches, the variable is created and can be used by all jobs in the pipeline. If the variable is already defined at the top level as a default variable, the `workflow` variable takes precedence and overrides the default variable.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: Variable name and value pairs:\n\n- The name can use only numbers, letters, and underscores ( `_`).- The value must be a string.\n\n**Example of `workflow:rules:variables`**:\n\n```python\nvariables:\nDEPLOY_VARIABLE: \"default-deploy\"\n\nworkflow:\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nvariables:\nDEPLOY_VARIABLE: \"deploy-production\" # Override globally-defined DEPLOY_VARIABLE\n - if: $CI_COMMIT_BRANCH =~ /feature/\nvariables:\nIS_A_FEATURE: \"true\" # Define a new variable.\n - if: $CI_COMMIT_BRANCH # Run the pipeline in other cases\n\njob1:\nvariables:\nDEPLOY_VARIABLE: \"job1-default-deploy\"\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nvariables: # Override DEPLOY_VARIABLE defined\nDEPLOY_VARIABLE: \"job1-deploy-production\" # at the job level.\n - when: on_success # Run the job in other cases\nscript:\n - echo \"Run script with $DEPLOY_VARIABLE as an argument\"\n - echo \"Run another script if $IS_A_FEATURE exists\"\n\njob2:\nscript:\n - echo \"Run script with $DEPLOY_VARIABLE as an argument\"\n - echo \"Run another script if $IS_A_FEATURE exists\"\n```\n\nWhen the branch is the default branch:\n\n- job1’s `DEPLOY_VARIABLE`is `job1-deploy-production`.- job2’s `DEPLOY_VARIABLE`is `deploy-production`.\n\nWhen the branch is `feature`:\n\n- job1’s `DEPLOY_VARIABLE`is `job1-default-deploy`, and `IS_A_FEATURE`is `true`.- job2’s `DEPLOY_VARIABLE`is `default-deploy`, and `IS_A_FEATURE`is `true`.\n\nWhen the branch is something else:\n\n- job1’s `DEPLOY_VARIABLE`is `job1-default-deploy`.- job2’s `DEPLOY_VARIABLE`is `default-deploy`.\n\n**Additional details**:\n\n- `workflow:rules:variables`become [default variables](https://docs.gitlab.com/ci/yaml/#variables)available in all jobs, including [trigger](https://docs.gitlab.com/ci/yaml/#trigger)jobs which forward variables to downstream pipelines by default. If the downstream pipeline uses the same variable, the [variable is overwritten](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence)by the upstream variable value. Be sure to either:\n - Use unique variable names in every project’s pipeline configuration, like `PROJECT1_VARIABLE_NAME`.- Use [inherit:variables](https://docs.gitlab.com/ci/yaml/#inheritvariables)in the trigger job and list the exact variables you want to forward to the downstream pipeline.\n\n* * *\n\n##### `workflow:rules:auto_cancel`\n\nUse `workflow:rules:auto_cancel` to configure the behavior of the [`workflow:auto_cancel:on_new_commit`](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit) or the [`workflow:auto_cancel:on_job_failure`](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_job_failure) features.\n\n**Supported values**:\n\n- `on_new_commit`: [workflow:auto_cancel:on_new_commit](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit)- `on_job_failure`: [workflow:auto_cancel:on_job_failure](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_job_failure)\n\n**Example of `workflow:rules:auto_cancel`**:\n\n```python\nworkflow:\nauto_cancel:\non_new_commit: interruptible\non_job_failure: all\nrules:\n - if: $CI_COMMIT_REF_PROTECTED == 'true'\nauto_cancel:\non_new_commit: none\non_job_failure: none\n - when: always # Run the pipeline in other cases\n\ntest-job1:\nscript: sleep 10\ninterruptible: false\n\ntest-job2:\nscript: sleep 10\ninterruptible: true\n```\n\nIn this example, [`workflow:auto_cancel:on_new_commit`](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit) is set to `interruptible` and [`workflow:auto_cancel:on_job_failure`](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_job_failure) is set to `all` for all jobs by default. But if a pipeline runs for a protected branch, the rule overrides the default with `on_new_commit: none` and `on_job_failure: none`. For example, if a pipeline is running for:\n\n- A non-protected branch and a new commit is pushed, `test-job1`continues to run and `test-job2`is canceled.- A protected branch and a new commit is pushed, both `test-job1`and `test-job2`continue to run.\n\n* * *\n\nSome keywords must be defined in a header section of a YAML configuration file. The header must be at the top of the file, separated from the rest of the configuration with `---`.\n\n* * *\n\n#### `spec`\n\nAdd a `spec` section to the header of a YAML file to configure the behavior of a pipeline when a configuration is added to the pipeline with the `include` keyword.\n\nSpecs must be declared at the top of a configuration file, in a header section separated from the rest of the configuration with `---`.\n\n* * *\n\n##### `spec:inputs`\n\nYou can use `spec:inputs` to define [inputs](https://docs.gitlab.com/ci/inputs/) for the CI/CD configuration.\n\nUse the interpolation format `$[[ inputs.input-id ]]` to reference the values outside of the header section. Inputs are evaluated and interpolated when the configuration is fetched during pipeline creation. When using `inputs`, interpolation completes before the configuration is merged with the contents of the `.gitlab-ci.yml` file.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: A hash of strings representing the expected inputs.\n\n**Example of `spec:inputs`**:\n\n```python\nspec:\ninputs:\nenvironment:\njob-stage:\n---\n\nscan-website:\nstage: $[[ inputs.job-stage ]]\nscript: ./scan-website $[[ inputs.environment ]]\n```\n\n**Additional details**:\n\n- Inputs are mandatory unless you use [spec:inputs:default](https://docs.gitlab.com/ci/yaml/#specinputsdefault)to set a default value. Avoid mandatory inputs unless you only use inputs with [include:inputs](https://docs.gitlab.com/ci/yaml/#includeinputs).- Inputs expect strings unless you use [spec:inputs:type](https://docs.gitlab.com/ci/yaml/#specinputstype)to set a different input type.- A string containing an interpolation block must not exceed 1 MB.- The string inside an interpolation block must not exceed 1 KB.- You can define input values [when running a new pipeline](https://docs.gitlab.com/ci/inputs/#for-a-pipeline).\n\n**Related topics**:\n\n- [Define input parameters with spec:inputs](https://docs.gitlab.com/ci/inputs/#define-input-parameters-with-specinputs).\n\n* * *\n\n###### `spec:inputs:default`\n\nInputs are mandatory when included, unless you set a default value with `spec:inputs:default`.\n\nUse `default: ''` to have no default value.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: A string representing the default value, or `''`.\n\n**Example of `spec:inputs:default`**:\n\n```python\nspec:\ninputs:\nwebsite:\nuser:\ndefault: 'test-user'\nflags:\ndefault: ''\n---\n\n## The pipeline configuration would follow...\n```\n\nIn this example:\n\n- `website`is mandatory and must be defined.- `user`is optional. If not defined, the value is `test-user`.- `flags`is optional. If not defined, it has no value.\n\n**Additional details**:\n\n- The pipeline fails with a validation error when the input:\n - Uses both `default`and [options](https://docs.gitlab.com/ci/yaml/#specinputsoptions), but the default value is not one of the listed options.- Uses both `default`and `regex`, but the default value does not match the regular expression.- Value does not match the [type](https://docs.gitlab.com/ci/yaml/#specinputstype).\n\n* * *\n\n###### `spec:inputs:description`\n\nUse `description` to give a description to a specific input. The description does not affect the behavior of the input and is only used to help users of the file understand the input.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: A string representing the description.\n\n**Example of `spec:inputs:description`**:\n\n```python\nspec:\ninputs:\nflags:\ndescription: 'Sample description of the `flags` input details.'\n---\n\n## The pipeline configuration would follow...\n```\n\n* * *\n\n###### `spec:inputs:options`\n\nInputs can use `options` to specify a list of allowed values for an input. The limit is 50 options per input.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: An array of input options. Only string and number [`type`](https://docs.gitlab.com/ci/yaml/#specinputstype) inputs can be used with options.\n\n**Example of `spec:inputs:options`**:\n\n```python\nspec:\ninputs:\nenvironment:\noptions:\n - development\n - staging\n - production\n---\n\n## The pipeline configuration would follow...\n```\n\nIn this example:\n\n- `environment`is mandatory and must be defined with one of the values in the list.\n\n**Additional details**:\n\n- The pipeline fails with a validation error when:\n - The input uses both `options`and [default](https://docs.gitlab.com/ci/yaml/#specinputsdefault), but the default value is not one of the listed options.- Any of the input options do not match the [type](https://docs.gitlab.com/ci/yaml/#specinputstype), which can be either `string`or `number`, but not `boolean`when using `options`.\n\n* * *\n\n###### `spec:inputs:regex`\n\nUse `spec:inputs:regex` to specify a regular expression that the input must match.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: Must be a regular expression.\n\n**Example of `spec:inputs:regex`**:\n\n```python\nspec:\ninputs:\nversion:\nregex: ^v\\d\\.\\d+(\\.\\d+)?$\n---\n\n## The pipeline configuration would follow...\n```\n\nIn this example, inputs of `v1.0` or `v1.2.3` match the regular expression and pass validation. An input of `v1.A.B` does not match the regular expression and fails validation.\n\n**Additional details**:\n\n- `inputs:regex`can only be used with a [type](https://docs.gitlab.com/ci/yaml/#specinputstype)of `string`, not `number`or `boolean`.- Do not enclose the regular expression with the `/`character. For example, use `regex.*`, not `/regex.*/`.- `inputs:regex`uses [RE2](https://github.com/google/re2/wiki/Syntax)to parse regular expressions.- Validation of the input against the regular expression happens before variable expansion. If the input text includes a variable name, the raw value of the input (the variable name) is validated, not the variable value.\n\n* * *\n\n###### `spec:inputs:rules`\n\nUse `spec:inputs:rules` to define conditional `options` and `default` values for an input based on the values of other inputs.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: An array of rule objects. Each rule can have:\n\n- `if`: A conditional expression to check input values, using [$[[ inputs.input-id ]] syntax](https://docs.gitlab.com/ci/inputs/#define-input-parameters-with-specinputs).- `options`: An array of allowed values for the input.- `default`: The default value for the input when this rule matches. Use [default: null](https://docs.gitlab.com/ci/inputs/#allow-user-entered-values-with-default-null)to allow users to enter their own value for the input.\n\n**Example of `spec:inputs:rules`**:\n\n```python\nspec:\ninputs:\nenvironment:\noptions: ['development', 'production']\ndefault: 'development'\n\ninstance_type:\ndescription: 'VM instance size'\nrules:\n - if: $[[ inputs.environment ]] == 'development'\noptions: ['small', 'medium']\ndefault: 'small'\n - if: $[[ inputs.environment ]] == 'production'\noptions: ['large', 'xlarge']\ndefault: 'large'\n---\n\ndeploy:\nscript: echo \"Deploying $[[ inputs.instance_type ]] instance\"\n```\n\nIn this example, when `environment` is `development`, users can only select `small` or `medium` instances. When `environment` is `production`, only `large` or `xlarge` instances are available.\n\n**Additional details**:\n\n- Rules are evaluated in order. The first rule with a matching `if`condition is used.- A rule without an `if`condition acts as a fallback when no other rules match.- Fallback rules must define `options`with at least one value.- All rules with `options`must also define a `default`value that exists in the `options`list.- You cannot use both `rules`and top-level `options`or `default`for the same input.\n\n**Related topics**:\n\n- [Define conditional input options with spec:inputs:rules](https://docs.gitlab.com/ci/inputs/#define-conditional-input-options-with-specinputsrules).\n\n* * *\n\n###### `spec:inputs:type`\n\nBy default, inputs expect strings. Use `spec:inputs:type` to set a different required type for inputs.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: Can be one of:\n\n- `array`, to accept an [array](https://docs.gitlab.com/ci/inputs/#array-type)of inputs.- `string`, to accept string inputs (default when not defined).- `number`, to only accept numeric inputs.- `boolean`, to only accept `true`or `false`inputs.\n\n**Example of `spec:inputs:type`**:\n\n```python\nspec:\ninputs:\njob_name:\nwebsite:\ntype: string\nport:\ntype: number\navailable:\ntype: boolean\narray_input:\ntype: array\n---\n\n## The pipeline configuration would follow...\n```\n\n* * *\n\n##### `spec:include`\n\nUse `spec:include` to include external input definitions from other files. You can share and reuse input definitions across multiple pipeline configurations.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: An array of include locations. Supports `local`, `remote`, and `project` includes only.\n\n**Example of `spec:include`**:\n\n```python\nspec:\ninclude:\n - local: /shared-inputs.yml\ninputs:\nenvironment:\ndefault: production\n---\n\ndeploy:\nscript: echo \"Deploying to $[[ inputs.environment ]]\"\n```\n\nWith multiple includes from different sources:\n\n```python\nspec:\ninclude:\n - local: /base-inputs.yml\n - remote: 'https://example.com/ci/common-inputs.yml'\n - project: 'my-group/shared-configs'\nref: main\nfile: '/ci/team-inputs.yml'\ninputs:\nenvironment:\ndefault: production\n---\n\ndeploy:\nscript: echo \"Deploying to $[[ inputs.environment ]]\"\n```\n\n**Additional details**:\n\n- You cannot use `spec:include`in [CI/CD components](https://docs.gitlab.com/ci/components/#component-spec-section).- External input files must contain only the `inputs`key. Other keys cause validation errors.- External inputs are merged first, then inline inputs are applied.- Inline inputs take precedence over external inputs with the same name.- When you include multiple input files, they are merged in the order specified.- Supports [local](https://docs.gitlab.com/ci/yaml/#includelocal), [remote](https://docs.gitlab.com/ci/yaml/#includeremote), and [project](https://docs.gitlab.com/ci/yaml/#includeproject)include types. Does not support `template`, `component`, or `artifact`includes.\n\n**Related topics**:\n\n- [Use inputs from external files](https://docs.gitlab.com/ci/inputs/#use-inputs-from-external-files).\n\n* * *\n\n##### `spec:component`\n\nUse `spec:component` to define which component context data is available for interpolation in a [CI/CD component](https://docs.gitlab.com/ci/components/).\n\nComponent context provides metadata about the component itself, such as its name, version, and the commit SHA. This allows component templates to reference their own metadata dynamically.\n\nUse the interpolation format `$[[ component.field-name ]]` to reference component context values in the component template.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: An array of strings. Each string must be one of:\n\n- `name`: The component name as specified in the component path.- `sha`: The commit SHA of the component.- `version`: The resolved semantic version from the catalog resource. Returns `null`if:\n - The component is not a catalog resource.- The reference is a branch name or commit SHA (not a released version).- `reference`: The original reference specified after `@`in the component path. For example, `1.0`, `~latest`, a branch name, or a commit SHA.\n\n**Example of `spec:component`**:\n\n```python\nspec:\ncomponent: [name, version, reference]\ninputs:\nimage_tag:\ndefault: latest\n---\n\nbuild-image:\nimage: registry.example.com/$[[ component.name ]]:$[[ component.version ]]\nscript:\n - echo \"Building with component version $[[ component.version ]]\"\n - echo \"Component reference: $[[ component.reference ]]\"\n```\n\n**Additional details**:\n\n- The `version`field resolves to the actual semantic version when using:\n - A full version like `@1.0.0`(returns `1.0.0`)- A partial version like `@1.0`(returns the latest matching version, for example `1.0.2`)- `@~latest`(returns the latest version)- The `reference`field always returns the exact value specified after `@`:\n - `@1.0`returns `1.0`(while `version`might return `1.0.2`)- `@~latest`returns `~latest`(while `version`returns the actual version number)- `@abc123`returns `abc123`(while `version`returns `null`)\n\n**Related topics**:\n\n- [Use component context in components](https://docs.gitlab.com/ci/components/#use-component-context-in-components).\n\n* * *\n\n### Job keywords\n\nThe following topics explain how to use keywords to configure CI/CD pipelines.\n\n* * *\n\n#### `after_script`\n\nUse `after_script` to define an array of commands to run last, after a job’s `before_script` and `script` sections complete. `after_script` commands also run when:\n\n- The job is canceled while the `before_script`or `script`sections are still running.- The job fails with failure type of `script_failure`, but not [other failure types](https://docs.gitlab.com/ci/yaml/#retrywhen).\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:after_script`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `after_script`, the job configuration takes precedence and the default configuration is not used.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: An array including:\n\n- Single line commands.- Long commands [split over multiple lines](https://docs.gitlab.com/ci/yaml/script/#split-long-commands).- [YAML anchors](https://docs.gitlab.com/ci/yaml/yaml_optimization/#yaml-anchors-for-scripts).\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `after_script`**:\n\n```python\njob:\nscript:\n - echo \"An example script section.\"\nafter_script:\n - echo \"Execute this command after the `script` section completes.\"\n```\n\n**Additional details**:\n\nScripts you specify in `after_script` execute in a new shell, separate from any `before_script` or `script` commands. As a result, they:\n\n- Have the current working directory set back to the default (according to the [variables which define how the runner processes Git requests](https://docs.gitlab.com/ci/runners/configure_runners/#configure-runner-behavior-with-variables)).- Don’t have access to changes done by commands defined in the `before_script`or `script`, including:\n - Command aliases and variables exported in `script`scripts.- Changes outside of the working tree (depending on the runner executor), like software installed by a `before_script`or `script`script.- Have a separate timeout. For GitLab Runner 16.4 and later, this defaults to 5 minutes, and can be configured with the [RUNNER_AFTER_SCRIPT_TIMEOUT](https://docs.gitlab.com/ci/runners/configure_runners/#set-script-and-after_script-timeouts)variable. In GitLab 16.3 and earlier, the timeout is hard-coded to 5 minutes.- Don’t affect the job’s exit code. If the `script`section succeeds and the `after_script`times out or fails, the job exits with code `0`( `Job Succeeded`).- There is a known issue with using [CI/CD job tokens](https://docs.gitlab.com/ci/jobs/ci_job_token/)with `after_script`. You can use a job token for authentication in `after_script`commands, but the token immediately becomes invalid if the job is canceled. See [issue](https://gitlab.com/gitlab-org/gitlab/-/issues/473376)for more details.- For jobs that time out:\n - `after_script`commands do not execute by default.- You can [configure timeout values](https://docs.gitlab.com/ci/runners/configure_runners/#ensuring-after_script-execution)to ensure `after_script`runs by setting appropriate `RUNNER_SCRIPT_TIMEOUT`and `RUNNER_AFTER_SCRIPT_TIMEOUT`values that don’t exceed the job’s timeout.- Using `after_script`at the top level, but not in the `default`section, is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#globally-defined-image-services-cache-before_script-after_script).\n\n**Execution timing and file inclusion**:\n\n`after_script` commands execute before cache and artifact upload operations.\n\n- If you configured artifact collection:\n - Files created or modified in `after_script`are included in artifacts.- Changes made in `after_script`are included in cache uploads.- Any files that `after_script`creates or modifies in the specified cache or artifact paths are captured and uploaded. You can use this timing for scenarios like:\n - Generating test reports or coverage data after the main script.- Creating summary files or logs.- Post-processing build outputs.\n\nIn the following example, the only files that are not included are those created or modified after the artifact or cache upload stages:\n\n```python\njob:\nscript:\n - echo \"main\" > output.txt\n - build_something\n\nafter_script:\n - echo \"modified in after_script\" >> output.txt # This WILL be in the artifact\n - generate_test_report > report.html # This WILL be in the artifact\n\nartifacts:\npaths:\n - output.txt\n - report.html\n\ncache:\npaths:\n - output.txt # Will include the \"modified in after_script\" line\n```\n\nFor more information, see [job execution flow](https://docs.gitlab.com/ci/jobs/job_execution/).\n\n**Related topics**:\n\n- [Use after_script with default](https://docs.gitlab.com/ci/yaml/script/#set-a-default-before_script-or-after_script-for-all-jobs)to define a default array of commands that should run after all jobs.- You can configure a job to [skip after_script commands if the job is canceled](https://docs.gitlab.com/ci/yaml/script/#skip-after_script-commands-if-a-job-is-canceled).- You can [ignore non-zero exit codes](https://docs.gitlab.com/ci/yaml/script/#ignore-non-zero-exit-codes).- [Use color codes with after_script](https://docs.gitlab.com/ci/yaml/script/#add-color-codes-to-script-output)to make job logs easier to review.- [Create custom collapsible sections](https://docs.gitlab.com/ci/jobs/job_logs/#custom-collapsible-sections)to simplify job log output.- You can [ignore errors in after_script](https://docs.gitlab.com/ci/runners/configure_runners/#ignore-errors-in-after_script).\n\n* * *\n\n#### `allow_failure`\n\nUse `allow_failure` to determine whether a pipeline should continue running when a job fails.\n\n- To let the pipeline continue running subsequent jobs, use `allow_failure: true`.- To stop the pipeline from running subsequent jobs, use `allow_failure: false`.\n\nWhen jobs are allowed to fail (`allow_failure: true`) an orange warning ( status\\_warning ) indicates that a job failed. However, the pipeline is successful and the associated commit is marked as passed with no warnings.\n\nThis same warning is displayed when:\n\n- All other jobs in the stage are successful.- All other jobs in the pipeline are successful.\n\nThe default value for `allow_failure` is:\n\n- `true`for [manual jobs](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually).- `false`for jobs that use `when: manual`inside [rules](https://docs.gitlab.com/ci/yaml/#rules).- `false`in all other cases.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`or `false`.\n\n**Example of `allow_failure`**:\n\n```python\njob1:\nstage: test\nscript:\n - execute_script_1\n\njob2:\nstage: test\nscript:\n - execute_script_2\nallow_failure: true\n\njob3:\nstage: deploy\nscript:\n - deploy_to_staging\nenvironment: staging\n```\n\nIn this example, `job1` and `job2` run in parallel:\n\n- If `job1`fails, jobs in the `deploy`stage do not start.- If `job2`fails, jobs in the `deploy`stage can still start.\n\n**Additional details**:\n\n- You can use `allow_failure`as a subkey of [rules](https://docs.gitlab.com/ci/yaml/#rulesallow_failure).- If `allow_failure: true`is set, the job is always considered successful, and later jobs with [when: on_failure](https://docs.gitlab.com/ci/yaml/#when)don’t start if this job fails.- You can use `allow_failure: false`with a manual job to create a [blocking manual job](https://docs.gitlab.com/ci/jobs/job_control/#types-of-manual-jobs). A blocked pipeline does not run any jobs in later stages until the manual job is started and completes successfully.\n\n* * *\n\n##### `allow_failure:exit_codes`\n\nUse `allow_failure:exit_codes` to control when a job should be allowed to fail. The job is `allow_failure: true` for any of the listed exit codes, and `allow_failure` false for any other exit code.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A single exit code.- An array of exit codes.\n\n**Example of `allow_failure`**:\n\n```python\ntest_job_1:\nscript:\n - echo \"Run a script that results in exit code 1. This job fails.\"\n - exit 1\nallow_failure:\nexit_codes: 137\n\ntest_job_2:\nscript:\n - echo \"Run a script that results in exit code 137. This job is allowed to fail.\"\n - exit 137\nallow_failure:\nexit_codes:\n - 137\n - 255\n```\n\n* * *\n\n#### `artifacts`\n\nUse `artifacts` to specify which files to save as [job artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/). Job artifacts are a list of files and directories that are attached to the job when it [succeeds, fails, or always](https://docs.gitlab.com/ci/yaml/#artifactswhen).\n\nThe artifacts are sent to GitLab after the job finishes. They are available for download in the GitLab UI if the size is smaller than the [maximum artifact size](https://docs.gitlab.com/user/gitlab_com/#cicd).\n\nBy default, jobs in later stages automatically download all the artifacts created by jobs in earlier stages. You can control artifact download behavior in jobs with [`dependencies`](https://docs.gitlab.com/ci/yaml/#dependencies).\n\nWhen using the [`needs`](https://docs.gitlab.com/ci/yaml/#needs) keyword, jobs can only download artifacts from the jobs defined in the `needs` configuration.\n\nJob artifacts are only collected for successful jobs by default, and artifacts are restored after [caches](https://docs.gitlab.com/ci/yaml/#cache).\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:artifacts`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `artifacts`, the job configuration takes precedence and the default configuration is not used.\n\n[Read more about artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/).\n\n* * *\n\n##### `artifacts:paths`\n\nPaths are relative to the project directory (`$CI_PROJECT_DIR`) and can’t directly link outside it.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of file paths, relative to the project directory.- You can use Wildcards that use [glob](https://en.wikipedia.org/wiki/Glob_%28programming%29)patterns and [doublestar.Glob](https://pkg.go.dev/github.com/bmatcuk/doublestar@v1.2.2?tab=doc#Match)patterns.- For [GitLab Pages job](https://docs.gitlab.com/ci/yaml/#pages):\n - In [GitLab 17.10 and later](https://gitlab.com/gitlab-org/gitlab/-/issues/428018), the [pages.publish](https://docs.gitlab.com/ci/yaml/#pagespublish)path is automatically appended to `artifacts:paths`, so you don’t need to specify it again.- In [GitLab 17.10 and later](https://gitlab.com/gitlab-org/gitlab/-/issues/428018), when the [pages.publish](https://docs.gitlab.com/ci/yaml/#pagespublish)path is not specified, the `public`directory is automatically appended to `artifacts:paths`.\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `artifacts:paths`**:\n\n```python\njob:\nartifacts:\npaths:\n - binaries/\n - .config\n```\n\nThis example creates an artifact with `.config` and all the files in the `binaries` directory.\n\n**Additional details**:\n\n- If not used with [artifacts:name](https://docs.gitlab.com/ci/yaml/#artifactsname), the artifacts file is named `artifacts`, which becomes `artifacts.zip`when downloaded.\n\n**Related topics**:\n\n- To restrict which jobs a specific job fetches artifacts from, see [dependencies](https://docs.gitlab.com/ci/yaml/#dependencies).- [Create job artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/#create-job-artifacts).\n\n* * *\n\n##### `artifacts:exclude`\n\nUse `artifacts:exclude` to prevent files from being added to an artifacts archive.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of file paths, relative to the project directory.- You can use Wildcards that use [glob](https://en.wikipedia.org/wiki/Glob_%28programming%29)or [doublestar.PathMatch](https://pkg.go.dev/github.com/bmatcuk/doublestar@v1.2.2?tab=doc#PathMatch)patterns.\n\n**Example of `artifacts:exclude`**:\n\n```python\nartifacts:\npaths:\n - binaries/\nexclude:\n - binaries/**/*.o\n```\n\nThis example stores all files in `binaries/`, but not `*.o` files located in subdirectories of `binaries/`.\n\n**Additional details**:\n\n- `artifacts:exclude`paths are not searched recursively.- Files matched by [artifacts:untracked](https://docs.gitlab.com/ci/yaml/#artifactsuntracked)can be excluded using `artifacts:exclude`too.\n\n**Related topics**:\n\n- [Exclude files from job artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/#without-excluded-files).\n\n* * *\n\n##### `artifacts:expire_in`\n\nUse `expire_in` to specify how long [job artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/) are stored before they expire and are deleted. The `expire_in` setting does not affect:\n\n- Artifacts from the latest job, unless keeping the latest job artifacts is disabled [at the project level](https://docs.gitlab.com/ci/jobs/job_artifacts/#keep-artifacts-from-most-recent-successful-jobs)or [instance-wide](https://docs.gitlab.com/administration/settings/continuous_integration/#keep-artifacts-from-latest-successful-pipelines).\n\nAfter their expiry, artifacts are deleted hourly by default (using a cron job), and are not accessible anymore.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: The expiry time. If no unit is provided, the time is in seconds. Valid values include:\n\n- `'42'`- `42 seconds`- `3 mins 4 sec`- `2 hrs 20 min`- `2h20min`- `6 mos 1 day`- `47 yrs 6 mos and 4d`- `3 weeks and 2 days`- `never`\n\n**Example of `artifacts:expire_in`**:\n\n```python\njob:\nartifacts:\nexpire_in: 1 week\n```\n\n**Additional details**:\n\n- The expiration time period begins when the artifact is uploaded and stored on GitLab. If the expiry time is not defined, it defaults to the [instance wide setting](https://docs.gitlab.com/administration/settings/continuous_integration/#set-default-artifacts-expiration).- To override the expiration date and protect artifacts from being automatically deleted:\n - Select **Keep**on the job page.- Set the value of `expire_in`to `never`.- If the expiry time is too short, jobs in later stages of a long pipeline might try to fetch expired artifacts from earlier jobs. If the artifacts are expired, jobs that try to fetch them fail with a [could not retrieve the needed artifacts error](https://docs.gitlab.com/ci/jobs/job_artifacts_troubleshooting/#error-message-this-job-could-not-start-because-it-could-not-retrieve-the-needed-artifacts). Set the expiry time to be longer, or use [dependencies](https://docs.gitlab.com/ci/yaml/#dependencies)in later jobs to ensure they don’t try to fetch expired artifacts.- `artifacts:expire_in`doesn’t affect GitLab Pages deployments. To configure Pages deployments’ expiry, use [pages.expire_in](https://docs.gitlab.com/ci/yaml/#pagesexpire_in).\n\n* * *\n\n##### `artifacts:expose_as`\n\nUse the `artifacts:expose_as` keyword to [expose artifacts in the merge request UI](https://docs.gitlab.com/ci/jobs/job_artifacts/#link-to-job-artifacts-in-the-merge-request-ui).\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- The name to display in the merge request UI for the artifacts download link. Must be combined with [artifacts:paths](https://docs.gitlab.com/ci/yaml/#artifactspaths).\n\n**Example of `artifacts:expose_as`**:\n\n```python\ntest:\nscript: [\"echo 'test' > file.txt\"]\nartifacts:\nexpose_as: 'artifact 1'\npaths: ['file.txt']\n```\n\n**Additional details**:\n\n- You can use `expose_as`only once per job, with a maximum of 10 jobs per merge request.- Glob patterns are not supported.- Artifacts are always sent to GitLab. They are displayed in the UI unless `artifacts:paths`values:\n - Use [CI/CD variables](https://docs.gitlab.com/ci/variables/).- Define a directory, but do not end with `/`. For example, `directory/`works with `artifacts:expose_as`, but `directory`does not.- If `artifacts:paths`only includes a single file, the link opens the file directly. In all other cases, the link opens the [artifacts browser](https://docs.gitlab.com/ci/jobs/job_artifacts/#download-job-artifacts).- Linked files are downloaded by default. If [GitLab Pages](https://docs.gitlab.com/administration/pages/)is enabled, you can preview some artifacts file extensions directly in your browser. See [Browse the contents of the artifacts archive](https://docs.gitlab.com/ci/jobs/job_artifacts/#browse-the-contents-of-the-artifacts-archive)for details.\n\n**Related topics**:\n\n- [Expose job artifacts in the merge request UI](https://docs.gitlab.com/ci/jobs/job_artifacts/#link-to-job-artifacts-in-the-merge-request-ui).\n\n* * *\n\n##### `artifacts:name`\n\nUse the `artifacts:name` keyword to define the name of the created artifacts archive. You can specify a unique name for every archive.\n\nIf not defined, the default name is `artifacts`, which becomes `artifacts.zip` when downloaded.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- The name of the artifacts archive. CI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file). Must be combined with [artifacts:paths](https://docs.gitlab.com/ci/yaml/#artifactspaths).\n\n**Example of `artifacts:name`**:\n\nTo create an archive with a name of the current job:\n\n```python\njob:\nartifacts:\nname: \"job1-artifacts-file\"\npaths:\n - binaries/\n```\n\n**Related topics**:\n\n- [Use CI/CD variables to define the artifacts configuration](https://docs.gitlab.com/ci/jobs/job_artifacts/#with-variable-expansion)\n\n* * *\n\n##### `artifacts:public`\n\nUse `artifacts:public` to control whether job artifacts in public pipelines are available for download with the GitLab UI and API by anonymous users, or Guest and Reporter roles.\n\nThis option only affects GitLab UI and API access. CI/CD jobs using job tokens could still access artifacts with the runner API, regardless of this setting. To restrict job token access, configure your project’s [CI/CD visibility settings](https://docs.gitlab.com/user/project/settings/#configure-project-features-and-permissions) to **Only project members**.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `true`(default): Artifacts in a job in public pipelines are available for download by anyone, including anonymous users, or Guest and Reporter roles.- `false`: Artifacts in the job are only available for download by users with at least the Developer role.\n\n**Example of `artifacts:public`**:\n\n```python\njob:\nartifacts:\npublic: false\n```\n\n* * *\n\n##### `artifacts:access`\n\nUse `artifacts:access` to determine who can access the job artifacts from the GitLab UI or API. This option does not prevent you from forwarding artifacts to downstream pipelines.\n\nYou cannot use [`artifacts:public`](https://docs.gitlab.com/ci/yaml/#artifactspublic) and `artifacts:access` in the same job.\n\nThis option only affects GitLab UI and API access. CI/CD jobs using job tokens could still access artifacts with the runner API, regardless of this setting. To restrict job token access, configure your project’s [CI/CD visibility settings](https://docs.gitlab.com/user/project/settings/#configure-project-features-and-permissions) to **Only project members**.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `all`(default): Artifacts in a job in public pipelines are available for download by anyone, including anonymous, guest, and reporter users.- `developer`: Artifacts in the job are only available for download by users with at least the Developer role.- `maintainer`: Artifacts in the job are only available for download by users with at least the Maintainer role.- `none`: Artifacts in the job are not available for download by anyone.\n\n**Example of `artifacts:access`**:\n\n```python\njob:\nartifacts:\naccess: 'developer'\n```\n\n**Additional details**:\n\n- `artifacts:access`affects all [artifacts:reports](https://docs.gitlab.com/ci/yaml/#artifactsreports)too, so you can also restrict access to [artifacts for reports](https://docs.gitlab.com/ci/yaml/artifacts_reports/).\n\n* * *\n\n##### `artifacts:reports`\n\nUse [`artifacts:reports`](https://docs.gitlab.com/ci/yaml/artifacts_reports/) to collect artifacts generated by included templates in jobs.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- See list of available [artifacts reports types](https://docs.gitlab.com/ci/yaml/artifacts_reports/).\n\n**Example of `artifacts:reports`**:\n\n```python\nrspec:\nstage: test\nscript:\n - bundle install\n - rspec --format RspecJunitFormatter --out rspec.xml\nartifacts:\nreports:\njunit: rspec.xml\n```\n\n**Additional details**:\n\n- Combining reports in parent pipelines using [artifacts from child pipelines](https://docs.gitlab.com/ci/yaml/#needspipelinejob)is not supported. Track progress on adding support in [this issue](https://gitlab.com/gitlab-org/gitlab/-/issues/215725).- To be able to browse and download the report output files, include the [artifacts:paths](https://docs.gitlab.com/ci/yaml/#artifactspaths)keyword. This uploads and stores the artifact twice.- Artifacts created for `artifacts: reports`are always uploaded, regardless of the job results (success or failure). You can use [artifacts:expire_in](https://docs.gitlab.com/ci/yaml/#artifactsexpire_in)to set an expiration date for the artifacts.\n\n* * *\n\n##### `artifacts:untracked`\n\nUse `artifacts:untracked` to add all Git untracked files as artifacts (along with the paths defined in `artifacts:paths`). `artifacts:untracked` ignores configuration in the repository’s `.gitignore`, so matching artifacts in `.gitignore` are included.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `true`or `false`(default if not defined).\n\n**Example of `artifacts:untracked`**:\n\nSave all Git untracked files:\n\n```python\njob:\nartifacts:\nuntracked: true\n```\n\n**Related topics**:\n\n- [Add untracked files to artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/#with-untracked-files).\n\n* * *\n\n##### `artifacts:when`\n\nUse `artifacts:when` to upload artifacts on job failure or despite the failure.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `on_success`(default): Upload artifacts only when the job succeeds.- `on_failure`: Upload artifacts only when the job fails.- `always`: Always upload artifacts (except when jobs time out). For example, when [uploading artifacts](https://docs.gitlab.com/ci/testing/unit_test_reports/#add-screenshots-to-test-reports)required to troubleshoot failing tests.\n\n**Example of `artifacts:when`**:\n\n```python\njob:\nartifacts:\nwhen: on_failure\n```\n\n**Additional details**:\n\n- The artifacts created for [artifacts:reports](https://docs.gitlab.com/ci/yaml/#artifactsreports)are always uploaded, regardless of the job results (success or failure). `artifacts:when`does not change this behavior.\n\n* * *\n\n#### `before_script`\n\nUse `before_script` to define an array of commands that should run before each job’s `script` commands, but after [artifacts](https://docs.gitlab.com/ci/yaml/#artifacts) are restored.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: An array including:\n\n- Single line commands.- Long commands [split over multiple lines](https://docs.gitlab.com/ci/yaml/script/#split-long-commands).- [YAML anchors](https://docs.gitlab.com/ci/yaml/yaml_optimization/#yaml-anchors-for-scripts).\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `before_script`**:\n\n```python\njob:\nbefore_script:\n - echo \"Execute this command before any 'script:' commands.\"\nscript:\n - echo \"This command executes after the job's 'before_script' commands.\"\n```\n\n**Additional details**:\n\n- Scripts you specify in `before_script`are concatenated with any scripts you specify in the main [script](https://docs.gitlab.com/ci/yaml/#script). The combined scripts execute together in a single shell.- Using `before_script`at the top level, but not in the `default`section, [is deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#globally-defined-image-services-cache-before_script-after_script).\n\n**Related topics**:\n\n- [Use before_script with default](https://docs.gitlab.com/ci/yaml/script/#set-a-default-before_script-or-after_script-for-all-jobs)to define a default array of commands that should run before the `script`commands in all jobs.\n - Job configuration and default configuration does not merge together. If the pipeline has [default:before_script](https://docs.gitlab.com/ci/yaml/#default)defined, and the job also has `before_script`, the job configuration takes precedence and the default configuration is not used.- You can [ignore non-zero exit codes](https://docs.gitlab.com/ci/yaml/script/#ignore-non-zero-exit-codes).- [Use color codes with before_script](https://docs.gitlab.com/ci/yaml/script/#add-color-codes-to-script-output)to make job logs easier to review.- [Create custom collapsible sections](https://docs.gitlab.com/ci/jobs/job_logs/#custom-collapsible-sections)to simplify job log output.\n\n* * *\n\n#### `cache`\n\nUse `cache` to specify a list of files and directories to cache between jobs. You can only use paths that are in the local working copy.\n\nCaches are:\n\n- Shared between pipelines and jobs.- By default, not shared between [protected](https://docs.gitlab.com/user/project/repository/branches/protected/)and unprotected branches.- Restored before [artifacts](https://docs.gitlab.com/ci/yaml/#artifacts).- Limited to a maximum of four [different caches](https://docs.gitlab.com/ci/caching/#use-multiple-caches).\n\nYou can [disable caching for specific jobs](https://docs.gitlab.com/ci/caching/#disable-cache-for-specific-jobs), for example to override:\n\n- A default cache defined with [default](https://docs.gitlab.com/ci/yaml/#default).- The configuration for a job added with [include](https://docs.gitlab.com/ci/yaml/#include).\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:cache`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `cache`, the job configuration takes precedence and the default configuration is not used.\n\nFor more information about caches, see [Caching in GitLab CI/CD](https://docs.gitlab.com/ci/caching/).\n\nUsing `cache` at the top level, but not in the `default` section, is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#globally-defined-image-services-cache-before_script-after_script).\n\n* * *\n\n##### `cache:paths`\n\nUse the `cache:paths` keyword to choose which files or directories to cache.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of paths relative to the project directory ( `$CI_PROJECT_DIR`). You can use wildcards that use [glob](https://en.wikipedia.org/wiki/Glob_%28programming%29)and [doublestar.Glob](https://pkg.go.dev/github.com/bmatcuk/doublestar@v1.2.2?tab=doc#Match)patterns.\n\n[CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file) are supported.\n\n**Example of `cache:paths`**:\n\nCache all files in `binaries` that end in `.apk` and the `.config` file:\n\n```python\nrspec:\nscript:\n - echo \"This job uses a cache.\"\ncache:\nkey: binaries-cache\npaths:\n - binaries/*.apk\n - .config\n```\n\n**Additional details**:\n\n- The `cache:paths`keyword includes files even if they are untracked or in your `.gitignore`file.\n\n**Related topics**:\n\n- See the [CI/CD caching examples](https://docs.gitlab.com/ci/caching/examples/)for more `cache:paths`examples.\n\n* * *\n\n##### `cache:key`\n\nUse the `cache:key` keyword to give each cache a unique identifying key. All jobs that use the same cache key use the same cache, including in different pipelines.\n\nIf not set, the default key is `default`. All jobs with the `cache` keyword but no `cache:key` share the `default` cache.\n\nMust be used with `cache: paths`, or nothing is cached.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A string.- A predefined [CI/CD variable](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).- A combination of both.\n\n**Example of `cache:key`**:\n\n```python\ncache-job:\nscript:\n - echo \"This job uses a cache.\"\ncache:\nkey: binaries-cache-$CI_COMMIT_REF_SLUG\npaths:\n - binaries/\n```\n\n**Additional details**:\n\n- If you use **Windows Batch** to run your shell scripts you must replace `$` with `%`. For example: `key: %CI_COMMIT_REF_SLUG%`- The `cache:key` value can’t contain:\n - The `/`character, or the equivalent URI-encoded `%2F`.- Only the `.`character (any number), or the equivalent URI-encoded `%2E`.- The cache is shared between jobs, so if you’re using different paths for different jobs, you should also set a different `cache:key`. Otherwise cache content can be overwritten.\n\n**Related topics**:\n\n- You can specify a [fallback cache key](https://docs.gitlab.com/ci/caching/#use-a-fallback-cache-key)to use if the specified `cache:key`is not found.- You can [use multiple cache keys](https://docs.gitlab.com/ci/caching/#use-multiple-caches)in a single job.- See the [CI/CD caching examples](https://docs.gitlab.com/ci/caching/examples/)for more `cache:key`examples.\n\n* * *\n\n###### `cache:key:files`\n\nUse `cache:key:files` to generate a new cache key when the content of the specified files change. If the content remains unchanged, the cache key remains consistent across branches and pipelines. You can reuse caches and rebuild them less often, which speeds up subsequent pipeline runs.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of up to two file paths or patterns.\n\nCI/CD variables are not supported.\n\n**Example of `cache:key:files`**:\n\n```python\ncache-job:\nscript:\n - echo \"This job uses a cache.\"\ncache:\nkey:\nfiles:\n - Gemfile.lock\n - package.json\npaths:\n - vendor/ruby\n - node_modules\n```\n\nThis example creates a cache for Ruby and Node.js dependencies. The cache is tied to the current versions of the `Gemfile.lock` and `package.json` files. When one of these files changes, a new cache key is computed and a new cache is created. Any future job runs that use the same `Gemfile.lock` and `package.json` with `cache:key:files` use the new cache, instead of rebuilding the dependencies.\n\n**Additional details**:\n\n- The cache `key`is a SHA computed from the content of the listed files. If a file doesn’t exist, it’s ignored in the key calculation. If none of the specified files exist, the fallback key is `default`.- Wildcard patterns like `**/package.json`can be used. An [issue](https://gitlab.com/gitlab-org/gitlab/-/issues/301161)exists to increase the number of paths or patterns allowed for a cache key.\n\n* * *\n\n###### `cache:key:files_commits`\n\nUse `cache:key:files_commits` to generate a new cache key when the latest commit changes for the specified files. `cache:key:files_commits` cache keys change whenever the specified files have a new commit, even if the file content remains identical.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of up to two file paths or patterns.\n\n**Example of `cache:key:files_commits`**:\n\n```python\ncache-job:\nscript:\n - echo \"This job uses a commit-based cache.\"\ncache:\nkey:\nfiles_commits:\n - package.json\n - yarn.lock\npaths:\n - node_modules\n```\n\nThis example creates a cache based on the commit history of `package.json` and `yarn.lock`. If the commit history changes for these files, a new cache key is computed and a new cache is created.\n\n**Additional details**:\n\n- The cache `key`is a SHA computed from the most recent commit for each specified file.- If a file doesn’t exist, it’s ignored in the key calculation.- If none of the specified files exist, the fallback key is `default`.- Cannot be used together with [cache:key:files](https://docs.gitlab.com/ci/yaml/#cachekeyfiles)in the same cache configuration.\n\n* * *\n\n###### `cache:key:prefix`\n\nUse `cache:key:prefix` to combine a prefix with the SHA computed for [`cache:key:files`](https://docs.gitlab.com/ci/yaml/#cachekeyfiles).\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A string.- A predefined [CI/CD variable](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).- A combination of both.\n\n**Example of `cache:key:prefix`**:\n\n```python\nrspec:\nscript:\n - echo \"This rspec job uses a cache.\"\ncache:\nkey:\nfiles:\n - Gemfile.lock\nprefix: $CI_JOB_NAME\npaths:\n - vendor/ruby\n```\n\nFor example, adding a `prefix` of `$CI_JOB_NAME` causes the key to look like `rspec-feef9576d21ee9b6a32e30c5c79d0a0ceb68d1e5`. If a branch changes `Gemfile.lock`, that branch has a new SHA checksum for `cache:key:files`. A new cache key is generated, and a new cache is created for that key. If `Gemfile.lock` is not found, the prefix is added to `default`, so the key in the example would be `rspec-default`.\n\n**Additional details**:\n\n- If no file in `cache:key:files`is changed in any commits, the prefix is added to the `default`key.\n\n* * *\n\n##### `cache:untracked`\n\nUse `untracked: true` to cache all files that are untracked in your Git repository. Untracked files include files that are:\n\n- Ignored due to [.gitignore configuration](https://git-scm.com/docs/gitignore).- Created, but not added to the checkout with [git add](https://git-scm.com/docs/git-add).\n\nCaching untracked files can create unexpectedly large caches if the job downloads:\n\n- Dependencies, like gems or node modules, which are usually untracked.- [Artifacts](https://docs.gitlab.com/ci/yaml/#artifacts)from a different job. Files extracted from the artifacts are untracked by default.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `true`or `false`(default).\n\n**Example of `cache:untracked`**:\n\n```python\nrspec:\nscript: test\ncache:\nuntracked: true\n```\n\n**Additional details**:\n\n- You can combine `cache:untracked` with `cache:paths` to cache all untracked files, as well as files in the configured paths. Use `cache:paths` to cache any specific files, including tracked files, or files that are outside of the working directory, and use `cache: untracked` to also cache all untracked files. For example: ```python\nrspec:\nscript: test\ncache:\nuntracked: true\npaths:\n - binaries/\n``` In this example, the job caches all untracked files in the repository, as well as all the files in `binaries/`. If there are untracked files in `binaries/`, they are covered by both keywords.\n\n* * *\n\n##### `cache:unprotect`\n\nUse `cache:unprotect` to set a cache to be shared between [protected](https://docs.gitlab.com/user/project/repository/branches/protected/) and unprotected branches.\n\nWhen set to `true`, users without access to protected branches can read and write to cache keys used by protected branches.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `true`or `false`(default).\n\n**Example of `cache:unprotect`**:\n\n```python\nrspec:\nscript: test\ncache:\nunprotect: true\n```\n\n* * *\n\n##### `cache:when`\n\nUse `cache:when` to define when to save the cache, based on the status of the job.\n\nMust be used with `cache: paths`, or nothing is cached.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `on_success`(default): Save the cache only when the job succeeds.- `on_failure`: Save the cache only when the job fails.- `always`: Always save the cache.\n\n**Example of `cache:when`**:\n\n```python\nrspec:\nscript: rspec\ncache:\npaths:\n - rspec/\nwhen: 'always'\n```\n\nThis example stores the cache whether or not the job fails or succeeds.\n\n* * *\n\n##### `cache:policy`\n\nTo change the upload and download behavior of a cache, use the `cache:policy` keyword. By default, the job downloads the cache when the job starts, and uploads changes to the cache when the job ends. This caching style is the `pull-push` policy (default).\n\nTo set a job to only download the cache when the job starts, but never upload changes when the job finishes, use `cache:policy:pull`.\n\nTo set a job to only upload a cache when the job finishes, but never download the cache when the job starts, use `cache:policy:push`.\n\nUse the `pull` policy when you have many jobs executing in parallel that use the same cache. This policy speeds up job execution and reduces load on the cache server. You can use a job with the `push` policy to build the cache.\n\nMust be used with `cache: paths`, or nothing is cached.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `pull`- `push`- `pull-push`(default)- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `cache:policy`**:\n\n```python\nprepare-dependencies-job:\nstage: build\ncache:\nkey: gems\npaths:\n - vendor/bundle\npolicy: push\nscript:\n - echo \"This job only downloads dependencies and builds the cache.\"\n - echo \"Downloading dependencies...\"\n\nfaster-test-job:\nstage: test\ncache:\nkey: gems\npaths:\n - vendor/bundle\npolicy: pull\nscript:\n - echo \"This job script uses the cache, but does not update it.\"\n - echo \"Running tests...\"\n```\n\n**Related topics**:\n\n- You can [use a variable to control a job’s cache policy](https://docs.gitlab.com/ci/caching/examples/#use-a-variable-to-control-a-jobs-cache-policy).\n\n* * *\n\n##### `cache:fallback_keys`\n\nUse `cache:fallback_keys` to specify a list of keys to try to restore cache from if there is no cache found for the `cache:key`. Caches are retrieved in the order specified in the `fallback_keys` section.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of cache keys\n\n**Example of `cache:fallback_keys`**:\n\n```python\nrspec:\nscript: rspec\ncache:\nkey: gems-$CI_COMMIT_REF_SLUG\npaths:\n - rspec/\nfallback_keys:\n - gems\nwhen: 'always'\n```\n\n* * *\n\n#### `coverage`\n\nUse `coverage` with a custom regular expression to configure how code coverage is extracted from the job output. The coverage is shown in the UI if at least one line in the job output matches the regular expression.\n\nTo extract the code coverage value from the match, GitLab uses this smaller regular expression: `\\d+(?:\\.\\d+)?`.\n\n**Supported values**:\n\n- An RE2 regular expression. Must start and end with `/`. Must match the coverage number. May match surrounding text as well, so you don’t need to use a regular expression character group to capture the exact number. Because it uses RE2 syntax, all groups must be non-capturing.\n\n**Example of `coverage`**:\n\n```python\njob1:\nscript: rspec\ncoverage: '/Code coverage: \\d+(?:\\.\\d+)?/'\n```\n\nIn this example:\n\n- GitLab checks the job log for a match with the regular expression. A line like `Code coverage: 67.89% of lines covered`would match.- GitLab then checks the matched fragment to find a match to the regular expression: `\\d+(?:\\.\\d+)?`. The sample regex can match a code coverage of `67.89`.\n\n**Additional details**:\n\n- You can find regex examples in [Code Coverage](https://docs.gitlab.com/ci/testing/code_coverage/#coverage-regex-patterns).- If there is more than one matched line in the job output, the last line is used (the first result of reverse search).- If there are multiple matches in a single line, the last match is searched for the coverage number.- If there are multiple coverage numbers found in the matched fragment, the first number is used.- Leading zeros are removed.- Coverage output from [child pipelines](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines)is not recorded or displayed. Check [the related issue](https://gitlab.com/gitlab-org/gitlab/-/issues/280818)for more details.\n\n* * *\n\n#### `dast_configuration`\n\n- Tier: Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nUse the `dast_configuration` keyword to specify a site profile and scanner profile to be used in a CI/CD configuration. Both profiles must first have been created in the project. The job’s stage must be `dast`.\n\n**Keyword type**: Job keyword. You can use only as part of a job.\n\n**Supported values**: One each of `site_profile` and `scanner_profile`.\n\n- Use `site_profile`to specify the site profile to be used in the job.- Use `scanner_profile`to specify the scanner profile to be used in the job.\n\n**Example of `dast_configuration`**:\n\n```python\nstages:\n - build\n - dast\n\ninclude:\n - template: DAST.gitlab-ci.yml\n\ndast:\ndast_configuration:\nsite_profile: \"Example Co\"\nscanner_profile: \"Quick Passive Test\"\n```\n\nIn this example, the `dast` job extends the `dast` configuration added with the `include` keyword to select a specific site profile and scanner profile.\n\n**Additional details**:\n\n- Settings contained in either a site profile or scanner profile take precedence over those contained in the DAST template.\n\n**Related topics**:\n\n- [Site profile](https://docs.gitlab.com/user/application_security/dast/profiles/#site-profile).- [Scanner profile](https://docs.gitlab.com/user/application_security/dast/profiles/#scanner-profile).\n\n* * *\n\n#### `dependencies`\n\nUse the `dependencies` keyword to define a list of specific jobs to fetch [artifacts](https://docs.gitlab.com/ci/yaml/#artifacts) from. The specified jobs must all be in earlier stages. You can also set a job to download no artifacts at all.\n\nWhen `dependencies` is not defined in a job, all jobs in earlier stages are considered dependent and the job fetches all artifacts from those jobs.\n\nTo fetch artifacts from a job in the same stage, you must use [`needs:artifacts`](https://docs.gitlab.com/ci/yaml/#needsartifacts). You should not combine `dependencies` with `needs` in the same job.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- The names of jobs to fetch artifacts from.- An empty array ( `[]`), to configure the job to not download any artifacts.\n\n**Example of `dependencies`**:\n\n```python\nbuild osx:\nstage: build\nscript: make build:osx\nartifacts:\npaths:\n - binaries/\n\nbuild linux:\nstage: build\nscript: make build:linux\nartifacts:\npaths:\n - binaries/\n\ntest osx:\nstage: test\nscript: make test:osx\ndependencies:\n - build osx\n\ntest linux:\nstage: test\nscript: make test:linux\ndependencies:\n - build linux\n\ndeploy:\nstage: deploy\nscript: make deploy\nenvironment: production\n```\n\nIn this example, two jobs have artifacts: `build osx` and `build linux`. When `test osx` is executed, the artifacts from `build osx` are downloaded and extracted in the context of the build. The same thing happens for `test linux` and artifacts from `build linux`.\n\nThe `deploy` job downloads artifacts from all previous jobs because of the [stage](https://docs.gitlab.com/ci/yaml/#stages) precedence.\n\n**Additional details**:\n\n- The job status does not matter. If a job fails or it’s a manual job that isn’t triggered, no error occurs.- If the artifacts of a dependent job are [expired](https://docs.gitlab.com/ci/yaml/#artifactsexpire_in)or [deleted](https://docs.gitlab.com/ci/jobs/job_artifacts/#delete-job-log-and-artifacts), then the job fails.\n\n* * *\n\n#### `environment`\n\nUse `environment` to define the [environment](https://docs.gitlab.com/ci/environments/) that a job deploys to.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: The name of the environment the job deploys to, in one of these formats:\n\n- Plain text, including letters, digits, spaces, and these characters: `-`, `_`, `/`, `$`, `{`, `}`.- CI/CD variables, including predefined, project, group, instance, or variables defined in the `.gitlab-ci.yml`file. You can’t use variables defined in a `script`section.\n\n**Example of `environment`**:\n\n```python\ndeploy to production:\nstage: deploy\nscript: git push production HEAD:main\nenvironment: production\n```\n\n**Additional details**:\n\n- If you specify an `environment`and no environment with that name exists, an environment is created.\n\n* * *\n\n##### `environment:name`\n\nSet a name for an [environment](https://docs.gitlab.com/ci/environments/).\n\nCommon environment names are `qa`, `staging`, and `production`, but you can use any name.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: The name of the environment the job deploys to, in one of these formats:\n\n- Plain text, including letters, digits, spaces, and these characters: `-`, `_`, `/`, `$`, `{`, `}`.- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file), including predefined, project, group, instance, or variables defined in the `.gitlab-ci.yml`file. You can’t use variables defined in a `script`section.\n\n**Example of `environment:name`**:\n\n```python\ndeploy to production:\nstage: deploy\nscript: git push production HEAD:main\nenvironment:\nname: production\n```\n\n* * *\n\n##### `environment:url`\n\nSet a URL for an [environment](https://docs.gitlab.com/ci/environments/).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: A single URL, in one of these formats:\n\n- Plain text, like `https://prod.example.com`.- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file), including predefined, project, group, instance, or variables defined in the `.gitlab-ci.yml`file. You can’t use variables defined in a `script`section.\n\n**Example of `environment:url`**:\n\n```python\ndeploy to production:\nstage: deploy\nscript: git push production HEAD:main\nenvironment:\nname: production\nurl: https://prod.example.com\n```\n\n**Additional details**:\n\n- After the job completes, you can access the URL by selecting a button in the merge request, environment, or deployment pages.\n\n* * *\n\n##### `environment:on_stop`\n\nClosing (stopping) environments can be achieved with the `on_stop` keyword defined under `environment`. It declares a different job that runs to close the environment.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Additional details**:\n\n- See [environment:action](https://docs.gitlab.com/ci/yaml/#environmentaction)for more details and an example.\n\n* * *\n\n##### `environment:action`\n\nUse the `action` keyword to specify how the job interacts with the environment.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: One of the following keywords:\n\n**Value**\n\n**Description**\n\n`start`\n\nDefault value. Indicates that the job starts the environment. The deployment is created after the job starts.\n\n`prepare`\n\nIndicates that the job is only preparing the environment. It does not trigger deployments. [Read more about preparing environments](https://docs.gitlab.com/ci/environments/#access-an-environment-for-preparation-or-verification-purposes).\n\n`stop`\n\nIndicates that the job stops an environment. [Read more about stopping an environment](https://docs.gitlab.com/ci/environments/#stopping-an-environment).\n\n`verify`\n\nIndicates that the job is only verifying the environment. It does not trigger deployments. [Read more about verifying environments](https://docs.gitlab.com/ci/environments/#access-an-environment-for-preparation-or-verification-purposes).\n\n`access`\n\nIndicates that the job is only accessing the environment. It does not trigger deployments. [Read more about accessing environments](https://docs.gitlab.com/ci/environments/#access-an-environment-for-preparation-or-verification-purposes).\n\n**Example of `environment:action`**:\n\n```python\nstop_review_app:\nstage: deploy\nvariables:\nGIT_STRATEGY: none\nscript: make delete-app\nwhen: manual\nenvironment:\nname: review/$CI_COMMIT_REF_SLUG\naction: stop\n```\n\n* * *\n\n##### `environment:auto_stop_in`\n\nThe `auto_stop_in` keyword specifies the lifetime of the environment. When an environment expires, GitLab automatically stops it.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: A period of time written in natural language. For example, these are all equivalent:\n\n- `168 hours`- `7 days`- `one week`- `never`\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `environment:auto_stop_in`**:\n\n```python\nreview_app:\nscript: deploy-review-app\nenvironment:\nname: review/$CI_COMMIT_REF_SLUG\nauto_stop_in: 1 day\n```\n\nWhen the environment for `review_app` is created, the environment’s lifetime is set to `1 day`. Every time the review app is deployed, that lifetime is also reset to `1 day`.\n\nThe `auto_stop_in` keyword can be used for all [environment actions](https://docs.gitlab.com/ci/yaml/#environmentaction) except `stop`. Some actions can be used to reset the scheduled stop time for the environment. For more information, see [Access an environment for preparation or verification purposes](https://docs.gitlab.com/ci/environments/#access-an-environment-for-preparation-or-verification-purposes).\n\n**Related topics**:\n\n- [Environments auto-stop documentation](https://docs.gitlab.com/ci/environments/#stop-an-environment-after-a-certain-time-period).\n\n* * *\n\n##### `environment:kubernetes`\n\nUse the `kubernetes` keyword to configure the [dashboard for Kubernetes](https://docs.gitlab.com/ci/environments/kubernetes_dashboard/) and [GitLab-managed Kubernetes resources](https://docs.gitlab.com/user/clusters/agent/managed_kubernetes_resources/) for an environment.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `agent`: A string specifying the [GitLab agent for Kubernetes](https://docs.gitlab.com/user/clusters/agent/). The format is `path/to/agent/project:agent-name`. If the agent is connected to the project running the pipeline, use `$CI_PROJECT_PATH:agent-name`.- `dashboard:namespace`: A string representing the Kubernetes namespace where the environment is deployed. The namespace must be set together with the `agent`keyword. `namespace`is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#environmentkubernetesnamespace-and-environmentkubernetesflux_resource_path).- `dashboard:flux_resource_path`: A string representing the full path to the Flux resource, such as a `HelmRelease`. The Flux resource must be set together with the `agent`and `dashboard:namespace`keywords. `flux_resource_path`is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#environmentkubernetesnamespace-and-environmentkubernetesflux_resource_path).- `managed_resources`: A hash with the `enabled`keyword to configure the [GitLab-managed Kubernetes resources](https://docs.gitlab.com/user/clusters/agent/managed_kubernetes_resources/)for the environment.\n - `managed_resources:enabled`: A boolean value indicating whether GitLab-managed Kubernetes resources are enabled for the environment.- `dashboard`: A hash with the `dashboard:namespace`and `dashboard:flux_resource_path`keywords to configure the [dashboard for Kubernetes](https://docs.gitlab.com/ci/environments/kubernetes_dashboard/)for the environment.\n\n**Example of `environment:kubernetes`**:\n\n```python\ndeploy:\nstage: deploy\nscript: make deploy-app\nenvironment:\nname: production\nkubernetes:\nagent: path/to/agent/project:agent-name\ndashboard:\nnamespace: my-namespace\nflux_resource_path: helm.toolkit.fluxcd.io/v2/namespaces/flux-system/helmreleases/helm-release-resource\n```\n\n**Example of `environment:kubernetes`** when disabling managed resources:\n\n```python\ndeploy:\nstage: deploy\nscript: make deploy-app\nenvironment:\nname: production\nkubernetes:\nagent: path/to/agent/project:agent-name\nmanaged_resources:\nenabled: false\ndashboard:\nnamespace: my-namespace\nflux_resource_path: helm.toolkit.fluxcd.io/v2/namespaces/flux-system/helmreleases/helm-release-resource\n```\n\nThis configuration:\n\n- Sets up the `deploy`job to deploy to the `production`environment.- Associates the [agent](https://docs.gitlab.com/user/clusters/agent/)named `agent-name`with the environment.- Configures the [dashboard for Kubernetes](https://docs.gitlab.com/ci/environments/kubernetes_dashboard/)for an environment with the namespace `my-namespace`and the `flux_resource_path`set to `helm.toolkit.fluxcd.io/v2/namespaces/flux-system/helmreleases/helm-release-resource`.\n\n**Additional details**:\n\n- To use the dashboard, you must [install the GitLab agent for Kubernetes](https://docs.gitlab.com/user/clusters/agent/install/)and [configure user_access](https://docs.gitlab.com/user/clusters/agent/user_access/)for the environment’s project or its parent group.- The user running the job must be authorized to access the cluster agent. Otherwise, the dashboard ignores the `agent`, `namespace`, and `flux_resource_path`attributes.- If you only want to set the `agent`, you do not have to set the `namespace`, and cannot set `flux_resource_path`. However, this configuration lists all namespaces in a cluster in the dashboard for Kubernetes.\n\n* * *\n\n##### `environment:deployment_tier`\n\nUse the `deployment_tier` keyword to specify the tier of the deployment environment.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: One of the following:\n\n- `production`- `staging`- `testing`- `development`- `other`- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file), including predefined, project, group, instance, or variables defined in the `.gitlab-ci.yml`file. You can’t use variables defined in a `script`section.\n\n**Example of `environment:deployment_tier`**:\n\n```python\ndeploy:\nscript: echo\nenvironment:\nname: customer-portal\ndeployment_tier: production\n```\n\n**Additional details**:\n\n- Environments created from this job definition are assigned a [tier](https://docs.gitlab.com/ci/environments/#deployment-tier-of-environments)based on this value.- Existing environments don’t have their tier updated if this value is added later. Existing environments must have their tier updated via the [Environments API](https://docs.gitlab.com/api/environments/#update-an-existing-environment).\n\n**Related topics**:\n\n- [Deployment tier of environments](https://docs.gitlab.com/ci/environments/#deployment-tier-of-environments).\n\n* * *\n\n##### Dynamic environments\n\nUse CI/CD [variables](https://docs.gitlab.com/ci/variables/) to dynamically name environments.\n\nFor example:\n\n```python\ndeploy as review app:\nstage: deploy\nscript: make deploy\nenvironment:\nname: review/$CI_COMMIT_REF_SLUG\nurl: https://$CI_ENVIRONMENT_SLUG.example.com/\n```\n\nThe `deploy as review app` job is marked as a deployment to dynamically create the `review/$CI_COMMIT_REF_SLUG` environment. `$CI_COMMIT_REF_SLUG` is a [CI/CD variable](https://docs.gitlab.com/ci/variables/) set by the runner. The `$CI_ENVIRONMENT_SLUG` variable is based on the environment name, but suitable for inclusion in URLs. If the `deploy as review app` job runs in a branch named `pow`, this environment would be accessible with a URL like `https://review-pow.example.com/`.\n\nThe common use case is to create dynamic environments for branches and use them as review apps. You can see an example that uses review apps at https://gitlab.com/gitlab-examples/review-apps-nginx/.\n\n* * *\n\n#### `extends`\n\nUse `extends` to reuse configuration sections. It’s an alternative to [YAML anchors](https://docs.gitlab.com/ci/yaml/yaml_optimization/#anchors) and is a little more flexible and readable.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- The name of another job in the pipeline.- A list (array) of names of other jobs in the pipeline.\n\n**Example of `extends`**:\n\n```python\n.tests:\nstage: test\nimage: ruby:3.0\n\nrspec:\nextends: .tests\nscript: rake rspec\n\nrubocop:\nextends: .tests\nscript: bundle exec rubocop\n```\n\nIn this example, the `rspec` job uses the configuration from the `.tests` template job. When creating the pipeline, GitLab:\n\n- Performs a reverse deep merge based on the keys.- Merges the `.tests`content with the `rspec`job.- Doesn’t merge the values of the keys.\n\nThe combined configuration is equivalent to these jobs:\n\n```python\nrspec:\nstage: test\nimage: ruby:3.0\nscript: rake rspec\n\nrubocop:\nstage: test\nimage: ruby:3.0\nscript: bundle exec rubocop\n```\n\n**Additional details**:\n\n- You can use multiple parents for `extends`.- The `extends`keyword supports up to eleven levels of inheritance, but you should avoid using more than three levels.- In the previous example, `.tests`is a [hidden job](https://docs.gitlab.com/ci/jobs/#hide-a-job), but you can extend configuration from regular jobs as well.\n\n**Related topics**:\n\n- [Reuse configuration sections by using extends](https://docs.gitlab.com/ci/yaml/yaml_optimization/#use-extends-to-reuse-configuration-sections).- Use `extends`to reuse configuration from [included configuration files](https://docs.gitlab.com/ci/yaml/yaml_optimization/#use-extends-and-include-together).\n\n* * *\n\n#### `hooks`\n\nUse `hooks` to specify lists of commands to execute on the runner at certain stages of job execution, like before retrieving the Git repository.\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:hooks`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `hooks`, the job configuration takes precedence and the default configuration is not used.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A hash of hooks and their commands. Available hooks: `pre_get_sources_script`.\n\n* * *\n\n##### `hooks:pre_get_sources_script`\n\nUse `hooks:pre_get_sources_script` to specify a list of commands to execute on the runner before cloning the Git repository and any submodules. You can use it for example to:\n\n- Adjust the [Git configuration](https://docs.gitlab.com/ci/jobs/job_troubleshooting/#get_sources-job-section-fails-because-of-an-http2-problem).- Export [tracing variables](https://docs.gitlab.com/topics/git/troubleshooting_git/#debug-git-with-traces).\n\n**Supported values**: An array including:\n\n- Single line commands.- Long commands [split over multiple lines](https://docs.gitlab.com/ci/yaml/script/#split-long-commands).- [YAML anchors](https://docs.gitlab.com/ci/yaml/yaml_optimization/#yaml-anchors-for-scripts).\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `hooks:pre_get_sources_script`**:\n\n```python\njob1:\nhooks:\npre_get_sources_script:\n - echo 'hello job1 pre_get_sources_script'\nscript: echo 'hello job1 script'\n```\n\n**Related topics**:\n\n- [GitLab Runner configuration](https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runners-section)\n\n* * *\n\n#### `identity`\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab.com- Status: Beta\n\nThis feature is in [beta](https://docs.gitlab.com/policy/development_stages_support/).\n\nUse `identity` to authenticate with third party services using identity federation.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default:` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: An identifier. Supported providers:\n\n- `google_cloud`: Google Cloud. Must be configured with the [Google Cloud IAM integration](https://docs.gitlab.com/integration/google_cloud_iam/).\n\n**Example of `identity`**:\n\n```python\njob_with_workload_identity:\nidentity: google_cloud\nscript:\n - gcloud compute instances list\n```\n\n**Related topics**:\n\n- [Workload Identity Federation](https://cloud.google.com/iam/docs/workload-identity-federation).- [Google Cloud IAM integration](https://docs.gitlab.com/integration/google_cloud_iam/).\n\n* * *\n\n#### `id_tokens`\n\nUse `id_tokens` to create [ID tokens](https://docs.gitlab.com/ci/secrets/id_token_authentication/) to authenticate with third party services. All JWTs created this way support OIDC authentication. The required `aud` sub-keyword is used to configure the `aud` claim for the JWT.\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:id_tokens`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `id_tokens`, the job configuration takes precedence and the default configuration is not used.\n\n**Supported values**:\n\n- Token names with their `aud`claims. `aud`supports:\n - A single string.- An array of strings.- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `id_tokens`**:\n\n```python\njob_with_id_tokens:\nid_tokens:\nID_TOKEN_1:\naud: https://vault.example.com\nID_TOKEN_2:\naud:\n - https://gcp.com\n - https://aws.com\nSIGSTORE_ID_TOKEN:\naud: sigstore\nscript:\n - command_to_authenticate_with_vault $ID_TOKEN_1\n - command_to_authenticate_with_aws $ID_TOKEN_2\n - command_to_authenticate_with_gcp $ID_TOKEN_2\n```\n\n**Related topics**:\n\n- [ID token authentication](https://docs.gitlab.com/ci/secrets/id_token_authentication/).- [Connect to cloud services](https://docs.gitlab.com/ci/cloud_services/).- [Keyless signing with Sigstore](https://docs.gitlab.com/ci/yaml/signing_examples/).\n\n* * *\n\n#### `image`\n\nUse `image` to specify a Docker image that the job runs in.\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:image`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `image`, the job configuration takes precedence and the default configuration is not used.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: The name of the image, including the registry path if needed, in one of these formats:\n\n- `<image-name>`(Same as using `<image-name>`with the `latest`tag)- `<image-name>:<tag>`- `<image-name>@<digest>`\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `image`**:\n\n```python\ndefault:\nimage: ruby:3.0\n\nrspec:\nscript: bundle exec rspec\n\nrspec 2.7:\nimage: registry.example.com/my-group/my-project/ruby:2.7\nscript: bundle exec rspec\n```\n\nIn this example, the `ruby:3.0` image is the default for all jobs in the pipeline. The `rspec 2.7` job does not use the default, because it overrides the default with a job-specific `image` section.\n\n**Additional details**:\n\n- Using `image`at the top level, but not in the `default`section, is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#globally-defined-image-services-cache-before_script-after_script).\n\n**Related topics**:\n\n- [Run your CI/CD jobs in Docker containers](https://docs.gitlab.com/ci/docker/using_docker_images/).\n\n* * *\n\n##### `image:name`\n\nThe name of the Docker image that the job runs in. Similar to [`image`](https://docs.gitlab.com/ci/yaml/#image) used by itself.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: The name of the image, including the registry path if needed, in one of these formats:\n\n- `<image-name>`(Same as using `<image-name>`with the `latest`tag)- `<image-name>:<tag>`- `<image-name>@<digest>`\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `image:name`**:\n\n```python\ntest-job:\nimage:\nname: \"registry.example.com/my/image:latest\"\nscript: echo \"Hello world\"\n```\n\n**Related topics**:\n\n- [Run your CI/CD jobs in Docker containers](https://docs.gitlab.com/ci/docker/using_docker_images/).\n\n* * *\n\n##### `image:entrypoint`\n\nCommand or script to execute as the container’s entry point.\n\nWhen the Docker container is created, the `entrypoint` is translated to the Docker `--entrypoint` option. The syntax is similar to the [Dockerfile `ENTRYPOINT` directive](https://docs.docker.com/reference/dockerfile/#entrypoint), where each shell token is a separate string in the array.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A string.\n\n**Example of `image:entrypoint`**:\n\n```python\ntest-job:\nimage:\nname: super/sql:experimental\nentrypoint: [\"\"]\nscript: echo \"Hello world\"\n```\n\n**Related topics**:\n\n- [Override the entrypoint of an image](https://docs.gitlab.com/ci/docker/using_docker_images/#override-the-entrypoint-of-an-image).\n\n* * *\n\n##### `image:docker`\n\nUse `image:docker` to pass options to runners using the [Docker executor](https://docs.gitlab.com/runner/executors/docker.html) or the [Kubernetes executor](https://docs.gitlab.com/runner/executors/kubernetes/). This keyword does not work with other executor types.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\nA hash of options for the Docker executor, which can include:\n\n- `platform`: Selects the architecture of the image to pull. When not specified, the default is the same platform as the host runner.- `user`: Specify the username or UID to use when running the container.\n\n**Example of `image:docker`**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests\"\nimage:\nname: super/sql:experimental\ndocker:\nplatform: arm64/v8\nuser: dave\n```\n\n**Additional details**:\n\n- `image:docker:platform`maps to the [docker pull --platform option](https://docs.docker.com/reference/cli/docker/image/pull/#options).- `image:docker:user`maps to the [docker run --user option](https://docs.docker.com/reference/cli/docker/container/run/#options).\n\n* * *\n\n##### `image:kubernetes`\n\nUse `image:kubernetes` to pass options to the GitLab Runner [Kubernetes executor](https://docs.gitlab.com/runner/executors/kubernetes/). This keyword does not work with other executor types.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\nA hash of options for the Kubernetes executor, which can include:\n\n- `user`: Specify the username or UID to use when the container runs. You can also use it to set GID by using the `UID:GID`format.\n\n**Example of `image:kubernetes` with only UID**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests\"\nimage:\nname: super/sql:experimental\nkubernetes:\nuser: \"1001\"\n```\n\n**Example of `image:kubernetes` with both UID and GID**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests\"\nimage:\nname: super/sql:experimental\nkubernetes:\nuser: \"1001:1001\"\n```\n\n* * *\n\n##### `image:pull_policy`\n\nThe pull policy that the runner uses to fetch the Docker image.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A single pull policy, or multiple pull policies in an array. Can be `always`, `if-not-present`, or `never`.\n\n**Examples of `image:pull_policy`**:\n\n```python\njob1:\nscript: echo \"A single pull policy.\"\nimage:\nname: ruby:3.0\npull_policy: if-not-present\n\njob2:\nscript: echo \"Multiple pull policies.\"\nimage:\nname: ruby:3.0\npull_policy: [always, if-not-present]\n```\n\n**Additional details**:\n\n- If the runner does not support the defined pull policy, the job fails with an error similar to: `ERROR: Job failed (system failure): the configured PullPolicies ([always]) are not allowed by AllowedPullPolicies ([never])`.\n\n**Related topics**:\n\n- [Run your CI/CD jobs in Docker containers](https://docs.gitlab.com/ci/docker/using_docker_images/).- [Configure how runners pull images](https://docs.gitlab.com/runner/executors/docker.html#configure-how-runners-pull-images).- [Set multiple pull policies](https://docs.gitlab.com/runner/executors/docker.html#set-multiple-pull-policies).\n\n* * *\n\n#### `inherit`\n\nUse `inherit` to [control inheritance of default keywords and variables](https://docs.gitlab.com/ci/jobs/#control-the-inheritance-of-default-keywords-and-variables).\n\n* * *\n\n##### `inherit:default`\n\nUse `inherit:default` to control the inheritance of [default keywords](https://docs.gitlab.com/ci/yaml/#default).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`(default) or `false`to enable or disable the inheritance of all default keywords.- A list of specific default keywords to inherit.\n\n**Example of `inherit:default`**:\n\n```python\ndefault:\nretry: 2\nimage: ruby:3.0\ninterruptible: true\n\njob1:\nscript: echo \"This job does not inherit any default keywords.\"\ninherit:\ndefault: false\n\njob2:\nscript: echo \"This job inherits only the two listed default keywords. It does not inherit 'interruptible'.\"\ninherit:\ndefault:\n - retry\n - image\n```\n\n**Additional details**:\n\n- You can also list default keywords to inherit on one line: `default: [keyword1, keyword2]`\n\n* * *\n\n##### `inherit:variables`\n\nUse `inherit:variables` to control the inheritance of [default variables](https://docs.gitlab.com/ci/yaml/#default-variables) keywords.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`(default) or `false`to enable or disable the inheritance of all default variables.- A list of specific variables to inherit.\n\n**Example of `inherit:variables`**:\n\n```python\nvariables:\nVARIABLE1: \"This is default variable 1\"\nVARIABLE2: \"This is default variable 2\"\nVARIABLE3: \"This is default variable 3\"\n\njob1:\nscript: echo \"This job does not inherit any default variables.\"\ninherit:\nvariables: false\n\njob2:\nscript: echo \"This job inherits only the two listed default variables. It does not inherit 'VARIABLE3'.\"\ninherit:\nvariables:\n - VARIABLE1\n - VARIABLE2\n```\n\n**Additional details**:\n\n- You can also list default variables to inherit on one line: `variables: [VARIABLE1, VARIABLE2]`\n\n* * *\n\n#### `interruptible`\n\nUse `interruptible` to configure the [auto-cancel redundant pipelines](https://docs.gitlab.com/ci/pipelines/settings/#auto-cancel-redundant-pipelines) feature to cancel a job before it completes if a new pipeline on the same ref starts for a newer commit. If the feature is disabled, the keyword has no effect. The new pipeline must be for a commit with new changes. For example, the **Auto-cancel redundant pipelines** feature has no effect if you select **New pipeline** in the UI to run a pipeline for the same commit.\n\nThe behavior of the **Auto-cancel redundant pipelines** feature can be controlled by the [`workflow:auto_cancel:on_new_commit`](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit) setting.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `true`or `false`(default).\n\n**Example of `interruptible` with the default behavior**:\n\n```python\nworkflow:\nauto_cancel:\non_new_commit: conservative # the default behavior\n\nstages:\n - stage1\n - stage2\n - stage3\n\nstep-1:\nstage: stage1\nscript:\n - echo \"Can be canceled.\"\ninterruptible: true\n\nstep-2:\nstage: stage2\nscript:\n - echo \"Can not be canceled.\"\n\nstep-3:\nstage: stage3\nscript:\n - echo \"Because step-2 can not be canceled, this step can never be canceled, even though it's set as interruptible.\"\ninterruptible: true\n```\n\nIn this example, a new pipeline causes a running pipeline to be:\n\n- Canceled, if only `step-1`is running or pending.- Not canceled, after `step-2`starts.\n\n**Example of `interruptible` with the `auto_cancel:on_new_commit:interruptible` setting**:\n\n```python\nworkflow:\nauto_cancel:\non_new_commit: interruptible\n\nstages:\n - stage1\n - stage2\n - stage3\n\nstep-1:\nstage: stage1\nscript:\n - echo \"Can be canceled.\"\ninterruptible: true\n\nstep-2:\nstage: stage2\nscript:\n - echo \"Can not be canceled.\"\n\nstep-3:\nstage: stage3\nscript:\n - echo \"Can be canceled.\"\ninterruptible: true\n```\n\nIn this example, a new pipeline causes a running pipeline to cancel `step-1` and `step-3` if they are running or pending.\n\n**Additional details**:\n\n- Only set `interruptible: true`if the job can be safely canceled after it has started, like a build job. Deployment jobs usually shouldn’t be canceled, to prevent partial deployments.- When using the default behavior or `workflow:auto_cancel:on_new_commit: conservative`:\n - A job that has not started yet is always considered `interruptible: true`, regardless of the job’s configuration. The `interruptible`configuration is only considered after the job starts.- **Running**pipelines are only canceled if all running jobs are configured with `interruptible: true`or no jobs configured with `interruptible: false`have started at any time. After a job with `interruptible: false`starts, the entire pipeline is no longer considered interruptible.- If the pipeline triggered a downstream pipeline, but no job with `interruptible: false`in the downstream pipeline has started yet, the downstream pipeline is also canceled.- You can add an optional manual job with `interruptible: false`in the first stage of a pipeline to allow users to manually prevent a pipeline from being automatically canceled. After a user starts the job, the pipeline cannot be canceled by the **Auto-cancel redundant pipelines**feature.- When using `interruptible`with a [trigger job](https://docs.gitlab.com/ci/yaml/#trigger):\n - The triggered downstream pipeline is never affected by the trigger job’s `interruptible`configuration.- If [workflow:auto_cancel](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit)is set to `conservative`, the trigger job’s `interruptible`configuration has no effect.- If [workflow:auto_cancel](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit)is set to `interruptible`, a trigger job with `interruptible: true`can be automatically canceled.\n\n* * *\n\n#### `needs`\n\nUse `needs` to execute jobs out-of-order. Relationships between jobs that use `needs` can be visualized as a [directed acyclic graph](https://docs.gitlab.com/ci/yaml/needs/).\n\nYou can ignore stage ordering and run some jobs without waiting for others to complete. Jobs in multiple stages can run concurrently.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- An array of jobs (maximum of 50 jobs).- An empty array ( `[]`), to set the job to start as soon as the pipeline is created.\n\n**Example of `needs`**:\n\n```python\nlinux:build:\nstage: build\nscript: echo \"Building linux...\"\n\nmac:build:\nstage: build\nscript: echo \"Building mac...\"\n\nlint:\nstage: test\nneeds: []\nscript: echo \"Linting...\"\n\nlinux:rspec:\nstage: test\nneeds: [\"linux:build\"]\nscript: echo \"Running rspec on linux...\"\n\nmac:rspec:\nstage: test\nneeds: [\"mac:build\"]\nscript: echo \"Running rspec on mac...\"\n\nproduction:\nstage: deploy\nscript: echo \"Running production...\"\nenvironment: production\n```\n\nThis example creates four paths of execution:\n\n- Linter: The `lint`job runs immediately without waiting for the `build`stage to complete because it has no needs ( `needs: []`).- Linux path: The `linux:rspec`job runs as soon as the `linux:build`job finishes, without waiting for `mac:build`to finish.- macOS path: The `mac:rspec`jobs runs as soon as the `mac:build`job finishes, without waiting for `linux:build`to finish.- The `production`job runs as soon as all previous jobs finish: `lint`, `linux:build`, `linux:rspec`, `mac:build`, `mac:rspec`.\n\n**Additional details**:\n\n- The maximum number of jobs that a single job can have in the `needs`array is limited:\n - For GitLab.com, the limit is 50. For more information, see [issue 350398](https://gitlab.com/gitlab-org/gitlab/-/issues/350398).- For GitLab Self-Managed and GitLab Dedicated, the default limit is 50. This limit can be changed by [updating the CI/CD limits in the Admin area](https://docs.gitlab.com/administration/settings/continuous_integration/#set-cicd-limits).- If `needs`refers to a job that uses the [parallel](https://docs.gitlab.com/ci/yaml/#parallel)keyword, it depends on all jobs created in parallel, not just one job. It also downloads artifacts from all the parallel jobs by default. If the artifacts have the same name, they overwrite each other and only the last one downloaded is saved.\n - To have `needs`refer to a subset of parallelized jobs (and not all of the parallelized jobs), use the [needs:parallel:matrix](https://docs.gitlab.com/ci/yaml/#needsparallelmatrix)keyword.- You can refer to jobs in the same stage as the job you are configuring.- If `needs`refers to a job that might not be added to a pipeline because of `only`, `except`, or `rules`, the pipeline might fail to create. Use the [needs:optional](https://docs.gitlab.com/ci/yaml/#needsoptional)keyword to resolve a failed pipeline creation.- If a pipeline has jobs with `needs: []`and jobs in the [.pre](https://docs.gitlab.com/ci/yaml/#stage-pre)stage, they will all start as soon as the pipeline is created. Jobs with `needs: []`start immediately, and jobs in the `.pre`stage also start immediately.\n\n* * *\n\n##### `needs:artifacts`\n\nWhen a job uses `needs`, it no longer downloads all artifacts from previous stages by default, because jobs with `needs` can start before earlier stages complete. With `needs` you can only download artifacts from the jobs listed in the `needs` configuration.\n\nUse `artifacts: true` (default) or `artifacts: false` to control when artifacts are downloaded in jobs that use `needs`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job. Must be used with `needs:job`.\n\n**Supported values**:\n\n- `true`(default) or `false`.\n\n**Example of `needs:artifacts`**:\n\n```python\ntest-job1:\nstage: test\nneeds:\n - job: build_job1\nartifacts: true\n\ntest-job2:\nstage: test\nneeds:\n - job: build_job2\nartifacts: false\n\ntest-job3:\nneeds:\n - job: build_job1\nartifacts: true\n - job: build_job2\n - build_job3\n```\n\nIn this example:\n\n- The `test-job1`job downloads the `build_job1`artifacts- The `test-job2`job does not download the `build_job2`artifacts.- The `test-job3`job downloads the artifacts from all three `build_jobs`, because `artifacts`is `true`, or defaults to `true`, for all three needed jobs.\n\n**Additional details**:\n\n- You should not combine `needs`with [dependencies](https://docs.gitlab.com/ci/yaml/#dependencies)in the same job.\n\n* * *\n\n##### `needs:project`\n\n- Tier: Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nUse `needs:project` to download artifacts from up to five jobs in other pipelines. The artifacts are downloaded from the latest successful specified job for the specified ref. To specify multiple jobs, add each as separate array items under the `needs` keyword.\n\nIf there is a pipeline running for the ref, a job with `needs:project` does not wait for the pipeline to complete. Instead, the artifacts are downloaded from the latest successful run of the specified job.\n\n`needs:project` must be used with `job`, `ref`, and `artifacts`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `needs:project`: A full project path, including namespace and group.- `job`: The job to download artifacts from.- `ref`: The ref to download artifacts from.- `artifacts`: Must be `true`to download artifacts.\n\n**Examples of `needs:project`**:\n\n```python\nbuild_job:\nstage: build\nscript:\n - ls -lhR\nneeds:\n - project: namespace/group/project-name\njob: build-1\nref: main\nartifacts: true\n - project: namespace/group/project-name-2\njob: build-2\nref: main\nartifacts: true\n```\n\nIn this example, `build_job` downloads the artifacts from the latest successful `build-1` and `build-2` jobs on the `main` branches in the `group/project-name` and `group/project-name-2` projects.\n\nYou can use [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file) in `needs:project`, for example:\n\n```python\nbuild_job:\nstage: build\nscript:\n - ls -lhR\nneeds:\n - project: $CI_PROJECT_PATH\njob: $DEPENDENCY_JOB_NAME\nref: $ARTIFACTS_DOWNLOAD_REF\nartifacts: true\n```\n\n**Additional details**:\n\n- To download artifacts from a different pipeline in the current project, set `project`to be the same as the current project, but use a different ref than the current pipeline. Concurrent pipelines running on the same ref could override the artifacts.- The user running the pipeline must have at least the Reporter role for the group or project, or the group/project must have public visibility.- You can’t use `needs:project`in the same job as [trigger](https://docs.gitlab.com/ci/yaml/#trigger).- When using `needs:project`to download artifacts from another pipeline, the job does not wait for the needed job to complete. [Using needs to wait for jobs to complete](https://docs.gitlab.com/ci/yaml/needs/)is limited to jobs in the same pipeline. Make sure that the needed job in the other pipeline completes before the job that needs it tries to download the artifacts.- You can’t download artifacts from jobs that run in [parallel](https://docs.gitlab.com/ci/yaml/#parallel).- Support [CI/CD variables](https://docs.gitlab.com/ci/variables/)in `project`, `job`, and `ref`.\n\n**Related topics**:\n\n- To download artifacts between [parent-child pipelines](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines), use [needs:pipeline:job](https://docs.gitlab.com/ci/yaml/#needspipelinejob).\n\n* * *\n\n##### `needs:pipeline:job`\n\nA [child pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines) can download artifacts from a successfully finished job in its parent pipeline or another child pipeline in the same parent-child pipeline hierarchy.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `needs:pipeline`: A pipeline ID. Must be a pipeline present in the same parent-child pipeline hierarchy.- `job`: The job to download artifacts from.\n\n**Example of `needs:pipeline:job`**:\n\n- Parent pipeline (`.gitlab-ci.yml`): ```python\nstages:\n - build\n - test\n\ncreate-artifact:\nstage: build\nscript: echo \"sample artifact\" > artifact.txt\nartifacts:\npaths: [artifact.txt]\n\nchild-pipeline:\nstage: test\ntrigger:\ninclude: child.yml\nstrategy: mirror\nvariables:\nPARENT_PIPELINE_ID: $CI_PIPELINE_ID\n```- Child pipeline (`child.yml`): ```python\nuse-artifact:\nscript: cat artifact.txt\nneeds:\n - pipeline: $PARENT_PIPELINE_ID\njob: create-artifact\n```\n\nIn this example, the `create-artifact` job in the parent pipeline creates some artifacts. The `child-pipeline` job triggers a child pipeline, and passes the `CI_PIPELINE_ID` variable to the child pipeline as a new `PARENT_PIPELINE_ID` variable. The child pipeline can use that variable in `needs:pipeline` to download artifacts from the parent pipeline. Having the `create-artifact` and `child-pipeline` jobs in subsequent stages ensures that the `use-artifact` job only executes when `create-artifact` has successfully finished.\n\n**Additional details**:\n\n- The `pipeline`attribute does not accept the current pipeline ID ( `$CI_PIPELINE_ID`). To download artifacts from a job in the current pipeline, use [needs:artifacts](https://docs.gitlab.com/ci/yaml/#needsartifacts).- You cannot use `needs:pipeline:job`in a [trigger job](https://docs.gitlab.com/ci/yaml/#trigger), or to fetch artifacts from a [multi-project pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#multi-project-pipelines). To fetch artifacts from a multi-project pipeline use [needs:project](https://docs.gitlab.com/ci/yaml/#needsproject).- The job listed in `needs:pipeline:job`must complete with a status of `success`or the artifacts can’t be fetched. [Issue 367229](https://gitlab.com/gitlab-org/gitlab/-/issues/367229)proposes to allow fetching artifacts from any job with artifacts.\n\n* * *\n\n##### `needs:optional`\n\nTo need a job that sometimes does not exist in the pipeline, add `optional: true` to the `needs` configuration. If not defined, `optional: false` is the default.\n\nJobs that use [`rules`](https://docs.gitlab.com/ci/yaml/#rules), [`only`, or `except`](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#only--except) and that are added with [`include`](https://docs.gitlab.com/ci/yaml/#include) might not always be added to a pipeline. GitLab checks the `needs` relationships before starting a pipeline:\n\n- If the `needs`entry has `optional: true`and the needed job is present in the pipeline, the job waits for it to complete before starting.- If the needed job is not present, the job can start when all other needs requirements are met.- If the `needs`section contains only optional jobs, and none are added to the pipeline, the job starts immediately (the same as an empty `needs`entry: `needs: []`).- If a needed job has `optional: false`, but it was not added to the pipeline, the pipeline fails to start with an error similar to: `'job1' job needs 'job2' job, but it was not added to the pipeline`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Example of `needs:optional`**:\n\n```python\nbuild-job:\nstage: build\n\ntest-job1:\nstage: test\n\ntest-job2:\nstage: test\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n\ndeploy-job:\nstage: deploy\nneeds:\n - job: test-job2\noptional: true\n - job: test-job1\nenvironment: production\n\nreview-job:\nstage: deploy\nneeds:\n - job: test-job2\noptional: true\nenvironment: review\n```\n\nIn this example:\n\n- `build-job`, `test-job1`, and `test-job2`start in stage order.- When the branch is the default branch, `test-job2`is added to the pipeline, so:\n - `deploy-job`waits for both `test-job1`and `test-job2`to complete.- `review-job`waits for `test-job2`to complete.- When the branch is not the default branch, `test-job2`is not added to the pipeline, so:\n - `deploy-job`waits for only `test-job1`to complete, and does not wait for the missing `test-job2`.- `review-job`has no other needed jobs and starts immediately (at the same time as `build-job`), like `needs: []`.\n\n* * *\n\n##### `needs:pipeline`\n\nYou can mirror the pipeline status from an upstream pipeline to a job by using the `needs:pipeline` keyword. The latest pipeline status from the default branch is replicated to the job.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A full project path, including namespace and group. If the project is in the same group or namespace, you can omit them from the `project`keyword. For example: `project: group/project-name`or `project: project-name`.\n\n**Example of `needs:pipeline`**:\n\n```python\nupstream_status:\nstage: test\nneeds:\npipeline: other/project\n```\n\n**Additional details**:\n\n- If you add the `job`keyword to `needs:pipeline`, the job no longer mirrors the pipeline status. The behavior changes to [needs:pipeline:job](https://docs.gitlab.com/ci/yaml/#needspipelinejob).\n\n* * *\n\n##### `needs:parallel:matrix`\n\nJobs can use [`parallel:matrix`](https://docs.gitlab.com/ci/yaml/#parallelmatrix) to run a job multiple times in parallel in a single pipeline, but with different variable values for each instance of the job.\n\nUse `needs:parallel:matrix` to execute jobs out-of-order depending on parallelized jobs.\n\n**Keyword type**: Job keyword. You can use it only as part of a job. Must be used with `needs:job`.\n\n**Supported values**: An array of hashes of matrix identifiers:\n\n- The identifiers and values must be selected from the identifiers and values defined in the `parallel:matrix`job.- You can use [matrix expressions](https://docs.gitlab.com/ci/yaml/matrix_expressions/).\n\n**Example of `needs:parallel:matrix`**:\n\n```python\nlinux:build:\nstage: build\nscript: echo \"Building linux...\"\nparallel:\nmatrix:\n - PROVIDER: aws\nSTACK:\n - monitoring\n - app1\n - app2\n\nlinux:rspec:\nstage: test\nneeds:\n - job: linux:build\nparallel:\nmatrix:\n - PROVIDER: aws\nSTACK: app1\nscript: echo \"Running rspec on linux...\"\n```\n\nThe previous example generates the following jobs:\n\n```text\nlinux:build: [aws, monitoring]\nlinux:build: [aws, app1]\nlinux:build: [aws, app2]\nlinux:rspec\n```\n\nThe `linux:rspec` job runs as soon as the `linux:build: [aws, app1]` job finishes.\n\n**Additional details**:\n\n- The order of the matrix identifiers in `needs:parallel:matrix` must match the order of the matrix variables in the needed job. For example, reversing the order of the variables in the `linux:rspec` job in the previous example would be invalid: ```python\nlinux:rspec:\nstage: test\nneeds:\n - job: linux:build\nparallel:\nmatrix:\n - STACK: app1 # The variable order does not match `linux:build` and is invalid.\nPROVIDER: aws\nscript: echo \"Running rspec on linux...\"\n```\n\n**Related topics**:\n\n- [Specify a parallelized job using needs with multiple parallelized jobs](https://docs.gitlab.com/ci/jobs/job_control/#specify-a-parallelized-job-using-needs-with-multiple-parallelized-jobs).- [Matrix expressions in needs:parallel:matrix](https://docs.gitlab.com/ci/yaml/matrix_expressions/#matrix-expressions-in-needsparallelmatrix).\n\n#### `pages`\n\nUse `pages` to define a [GitLab Pages](https://docs.gitlab.com/user/project/pages/) job that uploads static content to GitLab. The content is then published as a website.\n\nYou must:\n\n- Define `pages: true`to publish a directory named `public`- Alternatively, define [pages.publish](https://docs.gitlab.com/ci/yaml/#pagespublish)if want to use a different content directory.- Have a non-empty `index.html`file in the root of the content directory.\n\n**Keyword type**: Job keyword or Job name (deprecated). You can use it only as part of a job.\n\n**Supported Values**:\n\n- A boolean. Uses the default configuration when set to `true`- A hash of configuration options, see the following sections for details.\n\n**Example of `pages`**:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - mv my-html-content public\npages: true # specifies that this is a Pages job and publishes the default public directory\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nenvironment: production\n```\n\nThis example renames the `my-html-content/` directory to `public/`. This directory is exported as an artifact and published with GitLab Pages.\n\n**Example using a configuration hash**:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - echo \"nothing to do here\"\npages: # specifies that this is a Pages job and publishes the default public directory\npublish: my-html-content\nexpire_in: \"1 week\"\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nenvironment: production\n```\n\nThis example does not move the directory, but uses the `publish` property directly. It also configures the pages deployment to be unpublished after a week.\n\n**Additional details**:\n\n- Using `pages`as a job name [is deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#publish-keyword-and-pages-job-name-for-gitlab-pages).- To use `pages`as a job name without triggering a Pages deployment, set the `pages`property to false\n\n* * *\n\n##### `pages.publish`\n\nUse `pages.publish` to configure the content directory of a [`pages` job](https://docs.gitlab.com/ci/yaml/#pages).\n\n**Keyword type**: Job keyword. You can use it only as part of a `pages` job.\n\n**Supported values**: A path to a directory containing the Pages content. In [GitLab 17.10 and later](https://gitlab.com/gitlab-org/gitlab/-/issues/428018), if not specified, the default `public` directory is used and if specified, this path is automatically appended to [`artifacts:paths`](https://docs.gitlab.com/ci/yaml/#artifactspaths).\n\n**Example of `pages.publish`**:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - npx @11ty/eleventy --input=path/to/eleventy/root --output=dist\npages:\npublish: dist # this path is automatically appended to artifacts:paths\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nenvironment: production\n```\n\nThis example uses [Eleventy](https://www.11ty.dev/) to generate a static website and output the generated HTML files into a the `dist/` directory. This directory is exported as an artifact and published with GitLab Pages.\n\nIt is also possible to use variables in the `pages.publish` field. For example:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - mkdir -p $CUSTOM_FOLDER/$CUSTOM_PATH\n - cp -r public $CUSTOM_FOLDER/$CUSTOM_SUBFOLDER\npages:\npublish: $CUSTOM_FOLDER/$CUSTOM_SUBFOLDER # this path is automatically appended to artifacts:paths\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nvariables:\nCUSTOM_FOLDER: \"custom_folder\"\nCUSTOM_SUBFOLDER: \"custom_subfolder\"\n```\n\nThe publish path specified must be relative to the build root.\n\n**Additional details**:\n\n- The top-level `publish`keyword [is deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#publish-keyword-and-pages-job-name-for-gitlab-pages)and must now be nested under the `pages`keyword\n\n* * *\n\n##### `pages.path_prefix`\n\n- Tier: Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated- Status: Beta\n\nUse `pages.path_prefix` to configure a path prefix for [parallel deployments](https://docs.gitlab.com/user/project/pages/#parallel-deployments) of GitLab Pages.\n\n**Keyword type**: Job keyword. You can use it only as part of a `pages` job.\n\n**Supported values**:\n\n- A string- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file)- A combination of both\n\nThe given value is converted to lowercase and shortened to 63 bytes. Everything except alphanumeric characters or periods is replaced with a hyphen. Leading and trailing hyphens or periods are not permitted.\n\n**Example of `pages.path_prefix`**:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - echo \"Pages accessible through ${CI_PAGES_URL}\"\npages: # specifies that this is a Pages job and publishes the default public directory\npath_prefix: \"$CI_COMMIT_BRANCH\"\n```\n\nIn this example, a different pages deployment is created for each branch.\n\n* * *\n\n##### `pages.expire_in`\n\n- Tier: Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nUse `expire_in` to specify how long a deployment should be available before it expires. After the deployment is expired, it’s deactivated by a cron job running every 10 minutes.\n\nBy default, [parallel deployments](https://docs.gitlab.com/user/project/pages/#parallel-deployments) expire automatically after 24 hours. To disable this behavior, set the value to `never`.\n\n**Keyword type**: Job keyword. You can use it only as part of a `pages` job.\n\n**Supported values**: The expiry time. If no unit is provided, the time is in seconds. Variables are also supported. Valid values include:\n\n- `'42'`- `42 seconds`- `3 mins 4 sec`- `2 hrs 20 min`- `2h20min`- `6 mos 1 day`- `47 yrs 6 mos and 4d`- `3 weeks and 2 days`- `never`- `$DURATION`\n\n**Example of `pages.expire_in`**:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - echo \"Pages accessible through ${CI_PAGES_URL}\"\npages: # specifies that this is a Pages job and publishes the default public directory\nexpire_in: 1 week\n```\n\n* * *\n\n#### `parallel`\n\nUse `parallel` to run a job multiple times in parallel in a single pipeline.\n\nMultiple runners must exist, or a single runner must be configured to run multiple jobs concurrently.\n\nParallel jobs are named sequentially from `job_name 1/N` to `job_name N/N`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A numeric value from `1`to `200`.\n\n**Example of `parallel`**:\n\n```python\ntest:\nscript: rspec\nparallel: 5\n```\n\nThis example creates 5 jobs that run in parallel, named `test 1/5` to `test 5/5`.\n\n**Additional details**:\n\n- Every parallel job has a `CI_NODE_INDEX`and `CI_NODE_TOTAL` [predefined CI/CD variable](https://docs.gitlab.com/ci/variables/#predefined-cicd-variables)set.- A pipeline with jobs that use `parallel`might:\n - Create more jobs running in parallel than available runners. Excess jobs are queued and marked `pending`while waiting for an available runner.- Fail with a `job_activity_limit_exceeded`error if creating the pipeline would cause the total number of jobs across all active pipelines to [exceed the instance limit](https://docs.gitlab.com/administration/instance_limits/#number-of-jobs-in-active-pipelines).\n\n**Related topics**:\n\n- [Parallelize large jobs](https://docs.gitlab.com/ci/jobs/job_control/#parallelize-large-jobs).\n\n* * *\n\n##### `parallel:matrix`\n\nUse `parallel:matrix` to run a job multiple times in parallel in a single pipeline, but with different variable values for each instance of the job.\n\nMultiple runners must exist, or a single runner must be configured to run multiple jobs concurrently.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: An array of hashes of variables:\n\n- The matrix identifiers, which become the variable names, can use only numbers, letters, and underscores ( `_`).- The values must be either a string, or an array of strings.- The number of permutations cannot exceed 200.\n\n**Example of `parallel:matrix`**:\n\n```python\ndeploystacks:\nstage: deploy\nscript:\n - bin/deploy\nparallel:\nmatrix:\n - PROVIDER: aws\nSTACK:\n - monitoring\n - app1\n - app2\n - PROVIDER: [gcp, vultr]\nSTACK: [data, processing]\nenvironment: $PROVIDER/$STACK\n```\n\nThe example generates 7 parallel `deploystacks` jobs, each with different values for `PROVIDER` and `STACK`:\n\n- `deploystacks: [aws, monitoring]`- `deploystacks: [aws, app1]`- `deploystacks: [aws, app2]`- `deploystacks: [gcp, data]`- `deploystacks: [gcp, processing]`- `deploystacks: [vultr, data]`- `deploystacks: [vultr, processing]`\n\n**Additional details**:\n\n- `parallel:matrix` jobs add the matrix values to the job names to differentiate the jobs from each other, but [large values can cause names to exceed limits](https://gitlab.com/gitlab-org/gitlab/-/issues/362262):\n - [Job names](https://docs.gitlab.com/ci/jobs/#job-names)must be 255 characters or fewer.- When using [needs](https://docs.gitlab.com/ci/yaml/#needs), job names must be 128 characters or fewer.- You cannot use the matrix values as variables for [`rules:if`](https://docs.gitlab.com/ci/yaml/#rulesif).- You cannot create multiple matrix configurations with the same values but different names. Job names are generated from the matrix values, not the names, so matrix entries with identical values generate identical job names that overwrite each other. For example, this `test` configuration would try to create two series of identical jobs, but the `OS2` versions overwrite the `OS` versions: ```python\ntest:\nparallel:\nmatrix:\n - OS: [ubuntu]\nPROVIDER: [aws, gcp]\n - OS2: [ubuntu]\nPROVIDER: [aws, gcp]\n```\n\n**Related topics**:\n\n- [Run a one-dimensional matrix of parallel jobs](https://docs.gitlab.com/ci/jobs/job_control/#run-a-one-dimensional-matrix-of-parallel-jobs).- [Run a matrix of triggered parallel jobs](https://docs.gitlab.com/ci/jobs/job_control/#run-a-matrix-of-parallel-trigger-jobs).- [Select different runner tags for each parallel matrix job](https://docs.gitlab.com/ci/jobs/job_control/#select-different-runner-tags-for-each-parallel-matrix-job).- [Matrix expressions in needs:parallel:matrix](https://docs.gitlab.com/ci/yaml/matrix_expressions/#matrix-expressions-in-needsparallelmatrix).\n\n* * *\n\n#### `release`\n\nUse `release` to create a [release](https://docs.gitlab.com/user/project/releases/).\n\nThe release job must have access to the [`glab` CLI](https://gitlab.com/gitlab-org/cli), which must be in the `$PATH`.\n\nIf you use the [Docker executor](https://docs.gitlab.com/runner/executors/docker.html), you can use this image from the GitLab container registry: `registry.gitlab.com/gitlab-org/cli:latest`\n\nIf you use the [Shell executor](https://docs.gitlab.com/runner/executors/shell.html) or similar, [install `glab` CLI](https://gitlab.com/gitlab-org/cli#installation) on the server where the runner is registered.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: The `release` subkeys:\n\n- [tag_name](https://docs.gitlab.com/ci/yaml/#releasetag_name)\n- [tag_message](https://docs.gitlab.com/ci/yaml/#releasetag_message)(optional)- [name](https://docs.gitlab.com/ci/yaml/#releasename)(optional)- [description](https://docs.gitlab.com/ci/yaml/#releasedescription)\n- [ref](https://docs.gitlab.com/ci/yaml/#releaseref)(optional)- [milestones](https://docs.gitlab.com/ci/yaml/#releasemilestones)(optional)- [released_at](https://docs.gitlab.com/ci/yaml/#releasereleased_at)(optional)- [assets:links](https://docs.gitlab.com/ci/yaml/#releaseassetslinks)(optional)\n\n**Example of `release` keyword**:\n\n```python\nrelease_job:\nstage: release\nimage: registry.gitlab.com/gitlab-org/cli:latest\nrules:\n - if: $CI_COMMIT_TAG # Run this job when a tag is created manually\nscript:\n - echo \"Running the release job.\"\nrelease:\ntag_name: $CI_COMMIT_TAG\nname: 'Release $CI_COMMIT_TAG'\ndescription: 'Release created using the CLI.'\n```\n\nThis example creates a release:\n\n- When you push a Git tag.- When you add a Git tag in the UI at **Code**> **Tags**.\n\n**Additional details**:\n\n- All release jobs, except [trigger](https://docs.gitlab.com/ci/yaml/#trigger) jobs, must include the `script` keyword. A release job can use the output from script commands. If you don’t need the script, you can use a placeholder: ```python\nscript:\n - echo \"release job\"\n``` An [issue](https://gitlab.com/gitlab-org/gitlab/-/issues/223856) exists to remove this requirement.- The `release` section executes after the `script` keyword and before the `after_script`.- A release is created only if the job’s main script succeeds.- If the release already exists, it is not updated and the job with the `release` keyword fails.\n\n**Related topics**:\n\n- [CI/CD example of the release keyword](https://docs.gitlab.com/user/project/releases/#creating-a-release-by-using-a-cicd-job).- [Create multiple releases in a single pipeline](https://docs.gitlab.com/user/project/releases/#create-multiple-releases-in-a-single-pipeline).- [Use a custom SSL CA certificate authority](https://docs.gitlab.com/user/project/releases/#use-a-custom-ssl-ca-certificate-authority).\n\n* * *\n\n##### `release:tag_name`\n\nRequired. The Git tag for the release.\n\nIf the tag does not exist in the project yet, it is created at the same time as the release. New tags use the SHA associated with the pipeline.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A tag name.\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `release:tag_name`**:\n\nTo create a release when a new tag is added to the project:\n\n- Use the `$CI_COMMIT_TAG`CI/CD variable as the `tag_name`.- Use [rules:if](https://docs.gitlab.com/ci/yaml/#rulesif)to configure the job to run only for new tags.\n\n```python\njob:\nscript: echo \"Running the release job for the new tag.\"\nrelease:\ntag_name: $CI_COMMIT_TAG\ndescription: 'Release description'\nrules:\n - if: $CI_COMMIT_TAG\n```\n\nTo create a release and a new tag at the same time, your [`rules`](https://docs.gitlab.com/ci/yaml/#rules) should **not** configure the job to run only for new tags. A semantic versioning example:\n\n```python\njob:\nscript: echo \"Running the release job and creating a new tag.\"\nrelease:\ntag_name: ${MAJOR}_${MINOR}_${REVISION}\ndescription: 'Release description'\nrules:\n - if: $CI_PIPELINE_SOURCE == \"schedule\"\n```\n\n* * *\n\n##### `release:tag_message`\n\nIf the tag does not exist, the newly created tag is annotated with the message specified by `tag_message`. If omitted, a lightweight tag is created.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A text string.\n\n**Example of `release:tag_message`**:\n\n```python\nrelease_job:\nstage: release\nrelease:\ntag_name: $CI_COMMIT_TAG\ndescription: 'Release description'\ntag_message: 'Annotated tag message'\n```\n\n* * *\n\n##### `release:name`\n\nThe release name. If omitted, it is populated with the value of `release: tag_name`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A text string.\n\n**Example of `release:name`**:\n\n```python\nrelease_job:\nstage: release\nrelease:\nname: 'Release $CI_COMMIT_TAG'\n```\n\n* * *\n\n##### `release:description`\n\nThe long description of the release.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A string with the long description.- The path to a file that contains the description.\n - The file location must be relative to the project directory ( `$CI_PROJECT_DIR`).- If the file is a symbolic link, it must be in the `$CI_PROJECT_DIR`.- The `./path/to/file`and filename can’t contain spaces.\n\n**Example of `release:description`**:\n\n```python\njob:\nrelease:\ntag_name: ${MAJOR}_${MINOR}_${REVISION}\ndescription: './path/to/CHANGELOG.md'\n```\n\n**Additional details**:\n\n- The `description`is evaluated by the shell that runs `glab`. You can use CI/CD variables to define the description, but some shells [use different syntax](https://docs.gitlab.com/ci/variables/job_scripts/)to reference variables. Similarly, some shells might require special characters to be escaped. For example, backticks ( `` ` ``) might need to be escaped with a backslash ( `\\`).\n\n* * *\n\n##### `release:ref`\n\nThe `ref` for the release, if the `release: tag_name` doesn’t exist yet.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A commit SHA, another tag name, or a branch name.\n\n* * *\n\n##### `release:milestones`\n\nThe title of each milestone the release is associated with.\n\n* * *\n\n##### `release:released_at`\n\nThe date and time when the release is ready.\n\n**Supported values**:\n\n- A date enclosed in quotes and expressed in ISO 8601 format.\n\n**Example of `release:released_at`**:\n\n```text\nreleased_at: '2021-03-15T08:00:00Z'\n```\n\n**Additional details**:\n\n- If it is not defined, the current date and time is used.\n\n* * *\n\n##### `release:assets:links`\n\nUse `release:assets:links` to include [asset links](https://docs.gitlab.com/user/project/releases/release_fields/#release-assets) in the release.\n\n**Example of `release:assets:links`**:\n\n```python\nassets:\nlinks:\n - name: 'asset1'\nurl: 'https://example.com/assets/1'\n - name: 'asset2'\nurl: 'https://example.com/assets/2'\nfilepath: '/pretty/url/1' # optional\nlink_type: 'other' # optional\n```\n\n* * *\n\n#### `resource_group`\n\nUse `resource_group` to create a [resource group](https://docs.gitlab.com/ci/resource_groups/) that ensures a job is mutually exclusive across different pipelines for the same project.\n\nFor example, if multiple jobs that belong to the same resource group are queued simultaneously, only one of the jobs starts. The other jobs wait until the `resource_group` is free.\n\nResource groups behave similar to semaphores in other programming languages.\n\nYou can choose a [process mode](https://docs.gitlab.com/ci/resource_groups/#process-modes) to strategically control the job concurrency for your deployment preferences. The default process mode is `unordered`. To change the process mode of a resource group, use the [API](https://docs.gitlab.com/api/resource_groups/#edit-an-existing-resource-group) to send a request to edit an existing resource group.\n\nYou can define multiple resource groups per environment. For example, when deploying to physical devices, you might have multiple physical devices. Each device can be deployed to, but only one deployment can occur per device at any given time.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- Only letters, digits, `-`, `_`, `/`, `$`, `{`, `}`, `.`, and spaces. It can’t start or end with `/`. CI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `resource_group`**:\n\n```python\ndeploy-to-production:\nscript: deploy\nresource_group: production\n```\n\nIn this example, two `deploy-to-production` jobs in two separate pipelines can never run at the same time. As a result, you can ensure that concurrent deployments never happen to the production environment.\n\n**Related topics**:\n\n- [Pipeline-level concurrency control with cross-project/parent-child pipelines](https://docs.gitlab.com/ci/resource_groups/#pipeline-level-concurrency-control-with-cross-projectparent-child-pipelines).\n\n* * *\n\n#### `retry`\n\nUse `retry` to configure how many times a job is retried if it fails. If not defined, defaults to `0` and jobs do not retry.\n\nWhen a job fails, the job is processed up to two more times, until it succeeds or reaches the maximum number of retries.\n\nBy default, all failure types cause the job to be retried. Use [`retry:when`](https://docs.gitlab.com/ci/yaml/#retrywhen) or [`retry:exit_codes`](https://docs.gitlab.com/ci/yaml/#retryexit_codes) to select which failures to retry on.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `0`(default), `1`, or `2`.\n\n**Example of `retry`**:\n\n```python\ntest:\nscript: rspec\nretry: 2\n\ntest_advanced:\nscript:\n - echo \"Run a script that results in exit code 137.\"\n - exit 137\nretry:\nmax: 2\nwhen: runner_system_failure\nexit_codes: 137\n```\n\n`test_advanced` will be retried up to 2 times if the exit code is `137` or if it had a runner system failure.\n\n* * *\n\n##### `retry:when`\n\nUse `retry:when` with `retry:max` to retry jobs for only specific failure cases. `retry:max` is the maximum number of retries, like [`retry`](https://docs.gitlab.com/ci/yaml/#retry), and can be `0`, `1`, or `2`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A single failure type, or an array of one or more failure types:\n\n- `always`: Retry on any failure (default).- `unknown_failure`: Retry when the failure reason is unknown.- `script_failure`: Retry when:\n - The script failed.- The runner failed to pull the Docker image. For `docker`, `docker+machine`, `kubernetes` [executors](https://docs.gitlab.com/runner/executors/).- `api_failure`: Retry on API failure.- `stuck_or_timeout_failure`: Retry when the job got stuck or timed out.- `runner_system_failure`: Retry if there is a runner system failure (for example, job setup failed).- `runner_unsupported`: Retry if the runner is unsupported.- `stale_schedule`: Retry if a delayed job could not be executed.- `job_execution_timeout`: Retry if the script exceeded the maximum execution time set for the job.- `archived_failure`: Retry if the job is archived and can’t be run.- `unmet_prerequisites`: Retry if the job failed to complete prerequisite tasks.- `scheduler_failure`: Retry if the scheduler failed to assign the job to a runner.- `data_integrity_failure`: Retry if there is an unknown job problem.\n\n**Example of `retry:when`** (single failure type):\n\n```python\ntest:\nscript: rspec\nretry:\nmax: 2\nwhen: runner_system_failure\n```\n\nIf there is a failure other than a runner system failure, the job is not retried.\n\n**Example of `retry:when`** (array of failure types):\n\n```python\ntest:\nscript: rspec\nretry:\nmax: 2\nwhen:\n - runner_system_failure\n - stuck_or_timeout_failure\n```\n\n* * *\n\n##### `retry:exit_codes`\n\nUse `retry:exit_codes` with `retry:max` to retry jobs for only specific failure cases. `retry:max` is the maximum number of retries, like [`retry`](https://docs.gitlab.com/ci/yaml/#retry), and can be `0`, `1`, or `2`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A single exit code.- An array of exit codes.\n\n**Example of `retry:exit_codes`**:\n\n```python\ntest_job_1:\nscript:\n - echo \"Run a script that results in exit code 1. This job isn't retried.\"\n - exit 1\nretry:\nmax: 2\nexit_codes: 137\n\ntest_job_2:\nscript:\n - echo \"Run a script that results in exit code 137. This job will be retried.\"\n - exit 137\nretry:\nmax: 1\nexit_codes:\n - 255\n - 137\n```\n\n**Related topics**:\n\nYou can specify the number of [retry attempts for certain stages of job execution](https://docs.gitlab.com/ci/runners/configure_runners/#job-stages-attempts) using variables.\n\n* * *\n\n#### `rules`\n\nUse `rules` to include or exclude jobs in pipelines.\n\nRules are evaluated when the pipeline is created, and evaluated in order. When a match is found, no more rules are checked and the job is either included or excluded from the pipeline depending on the configuration. If no rules match, the job is not added to the pipeline.\n\n`rules` accepts an array of rules. Each rules must have at least one of:\n\n- `if`- `changes`- `exists`- `when`\n\nRules can also optionally be combined with:\n\n- `allow_failure`- `needs`- `variables`- `interruptible`\n\nYou can combine multiple keywords together for [complex rules](https://docs.gitlab.com/ci/jobs/job_rules/#complex-rules).\n\nThe job is added to the pipeline:\n\n- If an `if`, `changes`, or `exists`rule matches, and is configured with `when: on_success`(default if not defined), `when: delayed`, or `when: always`.- If a rule is reached that is only `when: on_success`, `when: delayed`, or `when: always`.\n\nThe job is not added to the pipeline:\n\n- If no rules match.- If a rule matches and has `when: never`.\n\nFor additional examples, see [Specify when jobs run with `rules`](https://docs.gitlab.com/ci/jobs/job_rules/).\n\n* * *\n\n##### `rules:if`\n\nUse `rules:if` clauses to specify when to add a job to a pipeline:\n\n- If an `if`statement is true, add the job to the pipeline.- If an `if`statement is true, but it’s combined with `when: never`, do not add the job to the pipeline.- If an `if`statement is false, check the next `rules`item (if any more exist).\n\n`if` clauses are evaluated:\n\n- Based on the values of [CI/CD variables](https://docs.gitlab.com/ci/variables/)or [predefined CI/CD variables](https://docs.gitlab.com/ci/variables/predefined_variables/), with [some exceptions](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).- In order, following [rules execution flow](https://docs.gitlab.com/ci/yaml/#rules).\n\n**Keyword type**: Job-specific and pipeline-specific. You can use it as part of a job to configure the job behavior, or with [`workflow`](https://docs.gitlab.com/ci/yaml/#workflow) to configure the pipeline behavior.\n\n**Supported values**:\n\n- A [CI/CD variable expression](https://docs.gitlab.com/ci/jobs/job_rules/#cicd-variable-expressions).\n\n**Example of `rules:if`**:\n\n```python\njob:\nscript: echo \"Hello, Rules!\"\nrules:\n - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^feature/ && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME != $CI_DEFAULT_BRANCH\nwhen: never\n - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^feature/\nwhen: manual\nallow_failure: true\n - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME\n```\n\n**Additional details**:\n\n- You cannot use [nested variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#nested-variable-expansion)with `if`. See [issue 327780](https://gitlab.com/gitlab-org/gitlab/-/issues/327780)for more details.- If a rule matches and has no `when`defined, the rule uses the `when`defined for the job, which defaults to `on_success`if not defined.- You can [mix when at the job-level with when in rules](https://gitlab.com/gitlab-org/gitlab/-/issues/219437). `when`configuration in `rules`takes precedence over `when`at the job-level.- Unlike variables in [script](https://docs.gitlab.com/ci/variables/job_scripts/)sections, variables in rules expressions are always formatted as `$VARIABLE`.\n - You can use `rules:if`with `include`to [conditionally include other configuration files](https://docs.gitlab.com/ci/yaml/includes/#use-rules-with-include).- CI/CD variables on the right side of `=~`and `!~`expressions are [evaluated as regular expressions](https://docs.gitlab.com/ci/jobs/job_rules/#store-a-regular-expression-in-a-variable).\n\n**Related topics**:\n\n- [Common if expressions for rules](https://docs.gitlab.com/ci/jobs/job_rules/#common-if-clauses-with-predefined-variables).- [Avoid duplicate pipelines](https://docs.gitlab.com/ci/jobs/job_rules/#avoid-duplicate-pipelines).- [Use rules to run merge request pipelines](https://docs.gitlab.com/ci/pipelines/merge_request_pipelines/#configure-merge-request-pipelines).\n\n* * *\n\n##### `rules:changes`\n\nUse `rules:changes` to specify when to add a job to a pipeline by checking for changes to specific files.\n\nFor new branch pipelines or when there is no Git `push` event, `rules: changes` always evaluates to true and the job always runs. Pipelines like tag pipelines, scheduled pipelines, and manual pipelines, all do **not** have a Git `push` event associated with them. To cover these cases, use [`rules: changes: compare_to`](https://docs.gitlab.com/ci/yaml/#ruleschangescompare_to) to specify the branch to compare against the pipeline ref.\n\nIf you do not use `compare_to`, you should use `rules: changes` only with [branch pipelines](https://docs.gitlab.com/ci/pipelines/pipeline_types/#branch-pipeline) or [merge request pipelines](https://docs.gitlab.com/ci/pipelines/merge_request_pipelines/), though `rules: changes` still evaluates to true when creating a new branch. With:\n\n- Merge request pipelines, `rules:changes`compares the changes with the target MR branch.- Branch pipelines, `rules:changes`compares the changes with the previous commit on the branch.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\nAn array including any number of:\n\n- Paths to files. The file paths can include [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).- Wildcard paths for:\n - Single directories, for example `path/to/directory/*`.- A directory and all its subdirectories, for example `path/to/directory/**/*`.- Wildcard [glob](https://en.wikipedia.org/wiki/Glob_%28programming%29)paths for all files with the same extension or multiple extensions, for example `*.md`or `path/to/directory/*.{rb,py,sh}`.- Wildcard paths to files in the root directory, or all directories, wrapped in double quotes. For example `\"*.json\"`or `\"**/*.json\"`.\n\n**Example of `rules:changes`**:\n\n```bash\ndocker build:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nchanges:\n - Dockerfile\nwhen: manual\nallow_failure: true\n\ndocker build alternative:\nvariables:\nDOCKERFILES_DIR: 'path/to/dockerfiles'\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nchanges:\n - $DOCKERFILES_DIR/**/*\n```\n\nIn this example:\n\n- If the pipeline is a merge request pipeline, check `Dockerfile`and the files in `$DOCKERFILES_DIR/**/*`for changes.- If `Dockerfile`has changed, add the job to the pipeline as a manual job, and the pipeline continues running even if the job is not triggered ( `allow_failure: true`).- If a file in `$DOCKERFILES_DIR/**/*`has changed, add the job to the pipeline.- If no listed files have changed, do not add either job to any pipeline (same as `when: never`).\n\n**Additional details**:\n\n- Glob patterns are interpreted with Ruby’s [File.fnmatch](https://docs.ruby-lang.org/en/master/File.html#method-c-fnmatch)with the [flags](https://docs.ruby-lang.org/en/master/File/Constants.html#module-File::Constants-label-Filename+Globbing+Constants+-28File-3A-3AFNM_-2A-29) `File::FNM_PATHNAME | File::FNM_DOTMATCH | File::FNM_EXTGLOB`.- For performance reasons, GitLab performs a maximum of 50,000 checks against `changes`patterns or file paths. After the 50,000th check, rules with patterned globs always match. In other words, the `changes`rule always assumes a match when more than 50,000 files changed, or if there are fewer than 50,000 changed files but the `changes`rules are checked more than 50,000 times.- A maximum of 50 patterns or file paths can be defined per `rules:changes`section.- `changes`resolves to `true`if any of the matching files are changed (an `OR`operation).- For additional examples, see [Specify when jobs run with rules](https://docs.gitlab.com/ci/jobs/job_rules/).- You can use the `$`character for both variables and paths. For example, if the `$VAR`variable exists, its value is used. If it does not exist, the `$`is interpreted as being part of a path.- Do not use `./`, double slashes ( `//`), or any other kind of relative path. Paths are matched with exact string comparison, they are not evaluated like in a shell.\n\n**Related topics**:\n\n- [Jobs or pipelines can run unexpectedly when using rules: changes](https://docs.gitlab.com/ci/jobs/job_troubleshooting/#jobs-or-pipelines-run-unexpectedly-when-using-changes).\n\n* * *\n\n###### `rules:changes:paths`\n\nUse `rules:changes` to specify that a job only be added to a pipeline when specific files are changed, and use `rules:changes:paths` to specify the files.\n\n`rules:changes:paths` is the same as using [`rules:changes`](https://docs.gitlab.com/ci/yaml/#ruleschanges) without any subkeys. All additional details and related topics are the same.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- Same as `rules:changes`.\n\n**Example of `rules:changes:paths`**:\n\n```python\ndocker-build-1:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nchanges:\n - Dockerfile\n\ndocker-build-2:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nchanges:\npaths:\n - Dockerfile\n```\n\nIn this example, both jobs have the same behavior.\n\n* * *\n\n###### `rules:changes:compare_to`\n\nUse `rules:changes:compare_to` to specify which ref to compare against for changes to the files listed under [`rules:changes:paths`](https://docs.gitlab.com/ci/yaml/#ruleschangespaths).\n\n**Keyword type**: Job keyword. You can use it only as part of a job, and it must be combined with `rules:changes:paths`.\n\n**Supported values**:\n\n- A branch name, like `main`, `branch1`, or `refs/heads/branch1`.- A tag name, like `tag1`or `refs/tags/tag1`.- A commit SHA, like `2fg31ga14b`.\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `rules:changes:compare_to`**:\n\n```bash\ndocker build:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nchanges:\npaths:\n - Dockerfile\ncompare_to: 'refs/heads/branch1'\n```\n\nIn this example, the `docker build` job is only included when the `Dockerfile` has changed relative to `refs/heads/branch1` and the pipeline source is a merge request event.\n\n**Additional details**:\n\n- Using `compare_to`in some situation can cause unexpected results:\n - With [merged results pipelines](https://docs.gitlab.com/ci/pipelines/merged_results_pipelines/#troubleshooting), because the comparison base is an internal commit that GitLab creates.- In a forked project, see [issue 424584](https://gitlab.com/gitlab-org/gitlab/-/issues/424584).\n\n**Related topics**:\n\n- You can use `rules:changes:compare_to`to [skip a job if the branch is empty](https://docs.gitlab.com/ci/jobs/job_rules/#skip-jobs-if-the-branch-is-empty).\n\n* * *\n\n##### `rules:exists`\n\nUse `exists` to run a job when certain files or directories exist in the repository.\n\n**Keyword type**: Job keyword. You can use it as part of a job or an [`include`](https://docs.gitlab.com/ci/yaml/#include).\n\n**Supported values**:\n\n- An array of file or directory paths. Paths are relative to the project directory ( `$CI_PROJECT_DIR`) and can’t directly link outside it. File paths can use glob patterns and [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `rules:exists`**:\n\n```python\njob1:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - exists:\n - Dockerfile\n\njob2:\nvariables:\nDOCKERPATH: \"**/Dockerfile\"\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - exists:\n - $DOCKERPATH\n```\n\nIn this example:\n\n- `job1`runs if a `Dockerfile`exists in the root directory of the repository.- `job2`runs if a `Dockerfile`exists anywhere in the repository.\n\n**Additional details**:\n\n- Glob patterns are interpreted with Ruby’s [File.fnmatch](https://docs.ruby-lang.org/en/master/File.html#method-c-fnmatch)with the [flags](https://docs.ruby-lang.org/en/master/File/Constants.html#module-File::Constants-label-Filename+Globbing+Constants+-28File-3A-3AFNM_-2A-29) `File::FNM_PATHNAME | File::FNM_DOTMATCH | File::FNM_EXTGLOB`.- For performance reasons, GitLab performs a maximum of 50,000 checks against `exists`patterns or file paths. After the 50,000th check, rules with patterned globs always match. In other words, the `exists`rule always assumes a match in projects with more than 50,000 files, or if there are fewer than 50,000 files but the `exists`rules are checked more than 50,000 times.\n - If there are multiple patterned globs, the limit is 50,000 divided by the number of globs. For example, a rule with 5 patterned globs has file limit of 10,000.- A maximum of 50 patterns or file paths can be defined per `rules:exists`section.- `exists`resolves to `true`if any of the listed files are found (an `OR`operation).- With job-level `rules:exists`, GitLab searches for the files in the project and ref that runs the pipeline. When using [include with rules:exists](https://docs.gitlab.com/ci/yaml/includes/#include-with-rulesexists), GitLab searches for the files or directories in the project and ref of the file that contains the `include`section. The project containing the `include`section can be different than the project running the pipeline when using:\n - [Nested includes](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes).- [Compliance pipelines](https://docs.gitlab.com/user/compliance/compliance_pipelines/).- `rules:exists`cannot search for the presence of [artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/), because `rules`evaluation happens before jobs run and artifacts are fetched.- To test the existence of a directory, the path must end with a forward slash (/)\n\n* * *\n\n###### `rules:exists:paths`\n\n`rules:exists:paths` is the same as using [`rules:exists`](https://docs.gitlab.com/ci/yaml/#rulesexists) without any subkeys. All additional details are the same.\n\n**Keyword type**: Job keyword. You can use it as part of a job or an [`include`](https://docs.gitlab.com/ci/yaml/#include).\n\n**Supported values**:\n\n- An array of file paths.\n\n**Example of `rules:exists:paths`**:\n\n```python\ndocker-build-1:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nexists:\n - Dockerfile\n\ndocker-build-2:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nexists:\npaths:\n - Dockerfile\n```\n\nIn this example, both jobs have the same behavior.\n\n* * *\n\n###### `rules:exists:project`\n\nUse `rules:exists:project` to specify the location in which to search for the files listed under [`rules:exists:paths`](https://docs.gitlab.com/ci/yaml/#rulesexistspaths). Must be used with `rules:exists:paths`.\n\n**Keyword type**: Job keyword. You can use it as part of a job or an [`include`](https://docs.gitlab.com/ci/yaml/#include), and it must be combined with `rules:exists:paths`.\n\n**Supported values**:\n\n- `exists:project`: A full project path, including namespace and group.- `exists:ref`: Optional. The commit ref to use to search for the file. The ref can be a tag, branch name, or SHA. Defaults to the `HEAD`of the project when not specified.\n\n**Example of `rules:exists:project`**:\n\n```bash\ndocker build:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - exists:\npaths:\n - Dockerfile\nproject: my-group/my-project\nref: v1.0.0\n```\n\nIn this example, the `docker build` job is only included when the `Dockerfile` exists in the project `my-group/my-project` on the commit tagged with `v1.0.0`.\n\n* * *\n\n##### `rules:when`\n\nUse `rules:when` alone or as part of another rule to control conditions for adding a job to a pipeline. `rules:when` is similar to [`when`](https://docs.gitlab.com/ci/yaml/#when), but with slightly different input options.\n\nIf a `rules:when` rule is not combined with `if`, `changes`, or `exists`, it always matches if reached when evaluating a job’s rules.\n\n**Keyword type**: Job-specific. You can use it only as part of a job.\n\n**Supported values**:\n\n- `on_success`(default): Run the job only when no jobs in earlier stages fail.- `on_failure`: Run the job only when at least one job in an earlier stage fails.- `never`: Don’t run the job regardless of the status of jobs in earlier stages.- `always`: Run the job regardless of the status of jobs in earlier stages.- `manual`: Add the job to the pipeline as a [manual job](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually). The default value for [allow_failure](https://docs.gitlab.com/ci/yaml/#allow_failure)changes to `false`.- `delayed`: Add the job to the pipeline as a [delayed job](https://docs.gitlab.com/ci/jobs/job_control/#run-a-job-after-a-delay).\n\n**Example of `rules:when`**:\n\n```python\njob1:\nrules:\n - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH\n - if: $CI_COMMIT_REF_NAME =~ /feature/\nwhen: delayed\n - when: manual\nscript:\n - echo\n```\n\nIn this example, `job1` is added to pipelines:\n\n- For the default branch, with `when: on_success`which is the default behavior when `when`is not defined.- For feature branches as a delayed job.- In all other cases as a manual job.\n\n**Additional details**:\n\n- When evaluating the status of jobs for `on_success`and `on_failure`:\n - Jobs with [allow_failure: true](https://docs.gitlab.com/ci/yaml/#allow_failure)in earlier stages are considered successful, even if they failed.- Skipped jobs in earlier stages, for example [manual jobs that have not been started](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually), are considered successful.- When using `rules:when: manual`to [add a manual job](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually):\n - [allow_failure](https://docs.gitlab.com/ci/yaml/#allow_failure)becomes `false`by default. This default is the opposite of using [when: manual](https://docs.gitlab.com/ci/yaml/#when)to add a manual job.- To achieve the same behavior as `when: manual`defined outside of `rules`, set [rules: allow_failure](https://docs.gitlab.com/ci/yaml/#rulesallow_failure)to `true`.\n\n* * *\n\n##### `rules:allow_failure`\n\nUse [`allow_failure: true`](https://docs.gitlab.com/ci/yaml/#allow_failure) in `rules` to allow a job to fail without stopping the pipeline.\n\nYou can also use `allow_failure: true` with a manual job. The pipeline continues running without waiting for the result of the manual job. `allow_failure: false` combined with `when: manual` in rules causes the pipeline to wait for the manual job to run before continuing.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`or `false`. Defaults to `false`if not defined.\n\n**Example of `rules:allow_failure`**:\n\n```python\njob:\nscript: echo \"Hello, Rules!\"\nrules:\n - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH\nwhen: manual\nallow_failure: true\n```\n\nIf the rule matches, then the job is a manual job with `allow_failure: true`.\n\n**Additional details**:\n\n- The rule-level `rules:allow_failure`overrides the job-level [allow_failure](https://docs.gitlab.com/ci/yaml/#allow_failure), and only applies when the specific rule triggers the job.\n\n* * *\n\n##### `rules:needs`\n\nUse `needs` in rules to update a job’s [`needs`](https://docs.gitlab.com/ci/yaml/#needs) for specific conditions. When a condition matches a rule, the job’s `needs` configuration is completely replaced with the `needs` in the rule.\n\n**Keyword type**: Job-specific. You can use it only as part of a job.\n\n**Supported values**:\n\n- An array of job names as strings.- A hash with a job name, optionally with additional attributes.- An empty array ( `[]`), to set the job needs to none when the specific condition is met.\n\n**Example of `rules:needs`**:\n\n```python\nbuild-dev:\nstage: build\nrules:\n - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\nscript: echo \"Feature branch, so building dev version...\"\n\nbuild-prod:\nstage: build\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nscript: echo \"Default branch, so building prod version...\"\n\ntests:\nstage: test\nrules:\n - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\nneeds: ['build-dev']\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nneeds: ['build-prod']\nscript: echo \"Running dev specs by default, or prod specs when default branch...\"\n```\n\nIn this example:\n\n- If the pipeline runs on a branch that is not the default branch, and therefore the rule matches the first condition, the `specs`job needs the `build-dev`job.- If the pipeline runs on the default branch, and therefore the rule matches the second condition, the `specs`job needs the `build-prod`job.\n\n**Additional details**:\n\n- `needs`in rules override any `needs`defined at the job-level. When overridden, the behavior is same as [job-level needs](https://docs.gitlab.com/ci/yaml/#needs).- `needs`in rules can accept [artifacts](https://docs.gitlab.com/ci/yaml/#needsartifacts)and [optional](https://docs.gitlab.com/ci/yaml/#needsoptional).\n\n* * *\n\n##### `rules:variables`\n\nUse [`variables`](https://docs.gitlab.com/ci/yaml/#variables) in `rules` to define variables for specific conditions.\n\n**Keyword type**: Job-specific. You can use it only as part of a job.\n\n**Supported values**:\n\n- A hash of variables in the format `VARIABLE-NAME: value`.\n\n**Example of `rules:variables`**:\n\n```python\njob:\nvariables:\nDEPLOY_VARIABLE: \"default-deploy\"\nrules:\n - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH\nvariables: # Override DEPLOY_VARIABLE defined\nDEPLOY_VARIABLE: \"deploy-production\" # at the job level.\n - if: $CI_COMMIT_REF_NAME =~ /feature/\nvariables:\nIS_A_FEATURE: \"true\" # Define a new variable.\nscript:\n - echo \"Run script with $DEPLOY_VARIABLE as an argument\"\n - echo \"Run another script if $IS_A_FEATURE exists\"\n```\n\n* * *\n\n##### `rules:interruptible`\n\nUse `interruptible` in rules to update a job’s [`interruptible`](https://docs.gitlab.com/ci/yaml/#interruptible) value for specific conditions.\n\n**Keyword type**: Job-specific. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`or `false`.\n\n**Example of `rules:interruptible`**:\n\n```python\njob:\nscript: echo \"Hello, Rules!\"\ninterruptible: true\nrules:\n - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH\ninterruptible: false # Override interruptible defined at the job level.\n - when: on_success\n```\n\n**Additional details**:\n\n- The rule-level `rules:interruptible`overrides the job-level [interruptible](https://docs.gitlab.com/ci/yaml/#interruptible), and only applies when the specific rule triggers the job.\n\n* * *\n\n#### `run`\n\n- Status: Experiment\n\nThis feature is available for testing, but not ready for production use.\n\nUse `run` to define a series of [steps](https://docs.gitlab.com/ci/steps/) to be executed in a job. Each step can be either a script or a predefined step.\n\nYou can also provide optional environment variables and inputs.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- An array of hashes, where each hash represents a step with the following possible keys:\n - `name`: A string representing the name of the step.- `script`: A string containing shell commands to execute.- `step`: A string identifying a predefined step to run.- `env`: Optional. A hash of environment variables specific to this step.- `inputs`: Optional. A hash of input parameters for predefined steps.\n\nEach array entry must have a `name`, and one `script` or `step` (but not both).\n\n**Example of `run`**:\n\n```python\njob:\nrun:\n - name: 'hello_steps'\nscript: 'echo \"hello from step1\"'\n - name: 'bye_steps'\nstep: gitlab.com/gitlab-org/ci-cd/runner-tools/echo-step@main\ninputs:\necho: 'bye steps!'\nenv:\nvar1: 'value 1'\n```\n\nIn this example, the job has two steps:\n\n- `hello_steps`runs the `echo`shell command.- `bye_steps`uses a predefined step with an environment variable and an input parameter.\n\n**Additional details**:\n\n- A step can have either a `script`or a `step`key, but not both.- A `run`configuration cannot be used together with existing [script](https://docs.gitlab.com/ci/yaml/#script), [after_script](https://docs.gitlab.com/ci/yaml/#after_script)or [before_script](https://docs.gitlab.com/ci/yaml/#before_script)keywords.- Multi-line scripts can be defined using [YAML block scalar syntax](https://docs.gitlab.com/ci/yaml/script/#split-long-commands).\n\n* * *\n\n#### `script`\n\nUse `script` to specify commands for the runner to execute.\n\nAll jobs except [trigger jobs](https://docs.gitlab.com/ci/yaml/#trigger) require a `script` keyword.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: An array including:\n\n- Single line commands.- Long commands [split over multiple lines](https://docs.gitlab.com/ci/yaml/script/#split-long-commands).- [YAML anchors](https://docs.gitlab.com/ci/yaml/yaml_optimization/#yaml-anchors-for-scripts).\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `script`**:\n\n```python\njob1:\nscript: \"bundle exec rspec\"\n\njob2:\nscript:\n - uname -a\n - bundle exec rspec\n```\n\n**Additional details**:\n\n- When you use [these special characters in script](https://docs.gitlab.com/ci/yaml/script/#use-special-characters-with-script), you must use single quotes ( `'`) or double quotes ( `\"`).\n\n**Related topics**:\n\n- You can [ignore non-zero exit codes](https://docs.gitlab.com/ci/yaml/script/#ignore-non-zero-exit-codes).- [Use color codes with script](https://docs.gitlab.com/ci/yaml/script/#add-color-codes-to-script-output)to make job logs easier to review.- [Create custom collapsible sections](https://docs.gitlab.com/ci/jobs/job_logs/#custom-collapsible-sections)to simplify job log output.\n\n* * *\n\n#### `secrets`\n\n- Tier: Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nUse `secrets` to specify [CI/CD secrets](https://docs.gitlab.com/ci/secrets/) to:\n\n- Retrieve from an external secrets provider.- Make available in the job as [CI/CD variables](https://docs.gitlab.com/ci/variables/)( [file type](https://docs.gitlab.com/ci/variables/#use-file-type-cicd-variables)by default).\n\n* * *\n\n##### `secrets:vault`\n\nUse `secrets:vault` to specify secrets provided by a [HashiCorp Vault](https://www.vaultproject.io/).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `engine:name`: Name of the secrets engine. Can be one of `kv-v2`(default), `kv-v1`, or `generic`.- `engine:path`: Path to the secrets engine.- `path`: Path to the secret.- `field`: Name of the field where the password is stored.\n\n**Example of `secrets:vault`**:\n\nTo specify all details explicitly and use the [KV-V2](https://developer.hashicorp.com/vault/docs/secrets/kv/kv-v2) secrets engine:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD: # Store the path to the secret in this CI/CD variable\nvault: # Translates to secret: `ops/data/production/db`, field: `password`\nengine:\nname: kv-v2\npath: ops\npath: production/db\nfield: password\n```\n\nYou can shorten this syntax. With the short syntax, `engine:name` and `engine:path` both default to `kv-v2`:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD: # Store the path to the secret in this CI/CD variable\nvault: production/db/password # Translates to secret: `kv-v2/data/production/db`, field: `password`\n```\n\nTo specify a custom secrets engine path in the short syntax, add a suffix that starts with `@`:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD: # Store the path to the secret in this CI/CD variable\nvault: production/db/password@ops # Translates to secret: `ops/data/production/db`, field: `password`\n```\n\n* * *\n\n##### `secrets:gcp_secret_manager`\n\nUse `secrets:gcp_secret_manager` to specify secrets provided by [GCP Secret Manager](https://cloud.google.com/security/products/secret-manager).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `name`: Name of the secret.- `version`: Version of the secret.\n\n**Example of `secrets:gcp_secret_manager`**:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD:\ngcp_secret_manager:\nname: 'test'\nversion: 2\n```\n\n**Related topics**:\n\n- [Use GCP Secret Manager secrets in GitLab CI/CD](https://docs.gitlab.com/ci/secrets/gcp_secret_manager/).\n\n* * *\n\n##### `secrets:azure_key_vault`\n\nUse `secrets:azure_key_vault` to specify secrets provided by a [Azure Key Vault](https://azure.microsoft.com/en-us/products/key-vault/).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `name`: Name of the secret.- `version`: Version of the secret.\n\n**Example of `secrets:azure_key_vault`**:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD:\nazure_key_vault:\nname: 'test'\nversion: 'test'\n```\n\n**Related topics**:\n\n- [Use Azure Key Vault secrets in GitLab CI/CD](https://docs.gitlab.com/ci/secrets/azure_key_vault/).\n\n* * *\n\n##### `secrets:file`\n\nUse `secrets:file` to configure the secret to be stored as either a [`file` or `variable` type CI/CD variable](https://docs.gitlab.com/ci/variables/#use-file-type-cicd-variables)\n\nBy default, the secret is passed to the job as a `file` type CI/CD variable. The value of the secret is stored in the file and the variable contains the path to the file.\n\nIf your software can’t use `file` type CI/CD variables, set `file: false` to store the secret value directly in the variable.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`(default) or `false`.\n\n**Example of `secrets:file`**:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD:\nvault: production/db/password@ops\nfile: false\n```\n\n**Additional details**:\n\n- The `file`keyword is a setting for the CI/CD variable and must be nested under the CI/CD variable name, not in the `vault`section.\n\n* * *\n\n##### `secrets:token`\n\nUse `secrets:token` to explicitly select a token to use when authenticating with the external secrets provider by referencing the token’s CI/CD variable.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- The name of an ID token\n\n**Example of `secrets:token`**:\n\n```python\njob:\nid_tokens:\nAWS_TOKEN:\naud: https://aws.example.com\nVAULT_TOKEN:\naud: https://vault.example.com\nsecrets:\nDB_PASSWORD:\nvault: gitlab/production/db\ntoken: $VAULT_TOKEN\n```\n\n**Additional details**:\n\n- When the `token`keyword is not set and there is only one token defined, the defined token will automatically be used.- If there is more than one token defined, you should specify which token to use by setting the `token`keyword. If you do not specify which token to use, it is not possible to predict which token is used each time the job runs.\n\n* * *\n\n#### `services`\n\nUse `services` to specify any additional Docker images that your scripts require to run successfully. The [`services` image](https://docs.gitlab.com/ci/services/) is linked to the image specified in the [`image`](https://docs.gitlab.com/ci/yaml/#image) keyword.\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:services`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `services`, the job configuration takes precedence and the default configuration is not used.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: The name of the services image, including the registry path if needed, in one of these formats:\n\n- `<image-name>`(Same as using `<image-name>`with the `latest`tag)- `<image-name>:<tag>`- `<image-name>@<digest>`\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file), but [not for `alias`](https://gitlab.com/gitlab-org/gitlab/-/issues/19561).\n\n**Example of `services`**:\n\n```python\ndefault:\nimage:\nname: ruby:2.6\nentrypoint: [\"/bin/bash\"]\n\nservices:\n - name: my-postgres:11.7\nalias: db-postgres\nentrypoint: [\"/usr/local/bin/db-postgres\"]\ncommand: [\"start\"]\n\nbefore_script:\n - bundle install\n\ntest:\nscript:\n - bundle exec rake spec\n```\n\nIn this example, GitLab launches two containers for the job:\n\n- A Ruby container that runs the `script`commands.- A PostgreSQL container. The `script`commands in the Ruby container can connect to the PostgreSQL database at the `db-postgres`hostname.\n\n**Additional details**:\n\n- Using `services`at the top level, but not in the `default`section, is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#globally-defined-image-services-cache-before_script-after_script).\n\n**Related topics**:\n\n- [Available settings for services](https://docs.gitlab.com/ci/services/#available-settings-for-services).- [Define services in the .gitlab-ci.yml file](https://docs.gitlab.com/ci/services/#define-services-in-the-gitlab-ciyml-file).- [Run your CI/CD jobs in Docker containers](https://docs.gitlab.com/ci/docker/using_docker_images/).- [Use Docker to build Docker images](https://docs.gitlab.com/ci/docker/using_docker_build/).\n\n* * *\n\n##### `services:name`\n\nThe full name of the image to use for the service.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: The name of the service image, including the registry path if needed, in one of these formats:\n\n- `<image-name>`(Same as using `<image-name>`with the `latest`tag)- `<image-name>:<tag>`- `<image-name>@<digest>`\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `services:name`**:\n\n```python\nservices:\n - name: postgres:11.7\n - name: registry.example.com/my-org/custom-service:latest\n```\n\n**Additional details**:\n\n- Use [alias](https://docs.gitlab.com/ci/yaml/#servicesalias)to define unique name aliases when using multiple identical service images, or when the service image name is long.- When used with other service options like `entrypoint`, `command`, or `variables`, the `name`keyword is required.- For more information, see [accessing the services](https://docs.gitlab.com/ci/services/#accessing-the-services).\n\n* * *\n\n##### `services:alias`\n\nAdditional aliases to access the service from the job’s container.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: A string with one or more aliases separated by spaces or commas.\n\n**Example of `services:alias`**:\n\n```python\nservices:\n - name: postgres:11.7\nalias: db,postgres,pg\n - name: mysql:latest\nalias: mysql-1\n```\n\n**Additional details**:\n\n- Multiple aliases can be separated by spaces or commas.- For more information, see [accessing the services](https://docs.gitlab.com/ci/services/#accessing-the-services). and [using aliases as service container names for the Kubernetes executor](https://docs.gitlab.com/ci/services/#using-aliases-as-service-container-names-for-the-kubernetes-executor).\n\n* * *\n\n##### `services:docker`\n\nUse `services:docker` to pass options to the Docker executor of a GitLab Runner.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\nA hash of options for the Docker executor, which can include:\n\n- `platform`: Selects the architecture of the image to pull. When not specified, the default is the same platform as the host runner.- `user`: Specify the username or UID to use when running the container.\n\n**Example of `services:docker`**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests in service container\"\nimage: ruby:2.6\nservices:\n - name: super/sql:experimental\ndocker:\nplatform: arm64/v8\nuser: dave\n```\n\n**Additional details**:\n\n- `services:docker:platform`maps to the [docker pull --platform option](https://docs.docker.com/reference/cli/docker/image/pull/#options).- `services:docker:user`maps to the [docker run --user option](https://docs.docker.com/reference/cli/docker/container/run/#options).\n\n* * *\n\n##### `services:kubernetes`\n\nUse `services:kubernetes` to pass options to the GitLab Runner [Kubernetes executor](https://docs.gitlab.com/runner/executors/kubernetes/).\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\nA hash of options for the Kubernetes executor, which can include:\n\n- `user`: Specify the username or UID to use when the container runs. You can also use it to set GID by using the `UID:GID`format.\n\n**Example of `services:kubernetes` with only UID**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests\"\nimage: ruby:2.6\nservices:\n - name: super/sql:experimental\nkubernetes:\nuser: \"1001\"\n```\n\n**Example of `services:kubernetes` with both UID and GID**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests\"\nimage: ruby:2.6\nservices:\n - name: super/sql:experimental\nkubernetes:\nuser: \"1001:1001\"\n```\n\n* * *\n\n##### `services:entrypoint`\n\nA command or script to execute as the container’s entrypoint.\n\nWhen the Docker container is created, the `entrypoint` is translated to the Docker `--entrypoint` option. The syntax is similar to the [Dockerfile `ENTRYPOINT` directive](https://docs.docker.com/reference/dockerfile/#entrypoint), where each shell token is a separate string in the array.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: An array of strings representing the entrypoint command.\n\n**Example of `services:entrypoint`**:\n\n```python\nservices:\n - name: my-postgres:11.7\nentrypoint: [\"/usr/local/bin/db-postgres\"]\n```\n\n* * *\n\n##### `services:command`\n\nCommand or script that should be used as the container’s command.\n\nIt’s translated to arguments passed to Docker after the image’s name. The syntax is similar to the [Dockerfile `CMD`](https://docs.docker.com/reference/dockerfile/#cmd) directive, where each shell token is a separate string in the array.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: An array of strings representing the command.\n\n**Example of `services:command`**:\n\n```python\nservices:\n - name: super/sql:latest\ncommand: [\"/usr/bin/super-sql\", \"run\"]\n```\n\n* * *\n\n##### `services:variables`\n\nAdditional environment variables that are passed exclusively to the service. Service variables are passed exclusively to the service container and are not available to the job container.\n\nThe syntax is the same as [job variables](https://docs.gitlab.com/ci/variables/).\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: A hash of environment variable names and values.\n\n**Example of `services:variables`**:\n\n```python\nservices:\n - name: postgres:11.7\nalias: db\nvariables:\nPOSTGRES_DB: \"my_custom_db\"\nPOSTGRES_USER: \"postgres\"\nPOSTGRES_PASSWORD: \"example\"\nPGDATA: \"/var/lib/postgresql/data\"\n```\n\n**Additional details**:\n\n- Service variables cannot reference themselves, they do not support variable expansion or interpolation.- Variables defined at the job or pipeline level are automatically passed to services. See [passing CI/CD variables to services](https://docs.gitlab.com/ci/services/#passing-cicd-variables-to-services)for more information.- Service variables are only available to the specific service they are defined for.\n\n* * *\n\n##### `services:pull_policy`\n\nThe pull policy that the runner uses to fetch the Docker image. Requires GitLab Runner 15.1 or later.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A single pull policy, or multiple pull policies in an array. Can be `always`, `if-not-present`, or `never`.\n\n**Examples of `services:pull_policy`**:\n\n```python\njob1:\nscript: echo \"A single pull policy.\"\nservices:\n - name: postgres:11.6\npull_policy: if-not-present\n\njob2:\nscript: echo \"Multiple pull policies.\"\nservices:\n - name: postgres:11.6\npull_policy: [always, if-not-present]\n```\n\n**Additional details**:\n\n- If the runner does not support the defined pull policy, the job fails with an error similar to: `ERROR: Job failed (system failure): the configured PullPolicies ([always]) are not allowed by AllowedPullPolicies ([never])`.\n\n**Related topics**:\n\n- [Run your CI/CD jobs in Docker containers](https://docs.gitlab.com/ci/docker/using_docker_images/).- [Configure how runners pull images](https://docs.gitlab.com/runner/executors/docker.html#configure-how-runners-pull-images).- [Set multiple pull policies](https://docs.gitlab.com/runner/executors/docker.html#set-multiple-pull-policies).\n\n* * *\n\n#### `stage`\n\nUse `stage` to define which [stage](https://docs.gitlab.com/ci/yaml/#stages) a job runs in. Jobs in the same `stage` can execute in parallel (see **Additional details**).\n\nIf `stage` is not defined, the job uses the `test` stage by default.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: A string, which can be a:\n\n- [Default stage](https://docs.gitlab.com/ci/yaml/#stages).- User-defined stages.\n\n**Example of `stage`**:\n\n```python\nstages:\n - build\n - test\n - deploy\n\njob1:\nstage: build\nscript:\n - echo \"This job compiles code.\"\n\njob2:\nstage: test\nscript:\n - echo \"This job tests the compiled code. It runs when the build stage completes.\"\n\njob3:\nscript:\n - echo \"This job also runs in the test stage.\"\n\njob4:\nstage: deploy\nscript:\n - echo \"This job deploys the code. It runs when the test stage completes.\"\nenvironment: production\n```\n\n**Additional details**:\n\n- The stage name must be 255 characters or fewer.- Jobs can run in parallel if they run on different runners.- If you have only one runner, jobs can run in parallel if the runner’s [concurrent setting](https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section)is greater than `1`.\n\n* * *\n\n##### `stage: .pre`\n\nUse the `.pre` stage to make a job run at the start of a pipeline. By default, `.pre` is the first stage in a pipeline. User-defined stages execute after `.pre`. You do not have to define `.pre` in [`stages`](https://docs.gitlab.com/ci/yaml/#stages).\n\nIf a pipeline contains only jobs in the `.pre` or `.post` stages, it does not run. There must be at least one other job in a different stage.\n\n**Keyword type**: You can only use it with a job’s `stage` keyword.\n\n**Example of `stage: .pre`**:\n\n```python\nstages:\n - build\n - test\n\njob1:\nstage: build\nscript:\n - echo \"This job runs in the build stage.\"\n\nfirst-job:\nstage: .pre\nscript:\n - echo \"This job runs in the .pre stage, before all other stages.\"\n\njob2:\nstage: test\nscript:\n - echo \"This job runs in the test stage.\"\n```\n\n**Additional details**:\n\n- If a pipeline has jobs with [needs: []](https://docs.gitlab.com/ci/yaml/#needs)and jobs in the `.pre`stage, they will all start as soon as the pipeline is created. Jobs with `needs: []`start immediately, ignoring any stage configuration.- A [pipeline execution policy](https://docs.gitlab.com/user/application_security/policies/pipeline_execution_policies/)can define a `.pipeline-policy-pre`stage which runs before `.pre`.\n\n* * *\n\n##### `stage: .post`\n\nUse the `.post` stage to make a job run at the end of a pipeline. By default, `.post` is the last stage in a pipeline. User-defined stages execute before `.post`. You do not have to define `.post` in [`stages`](https://docs.gitlab.com/ci/yaml/#stages).\n\nIf a pipeline contains only jobs in the `.pre` or `.post` stages, it does not run. There must be at least one other job in a different stage.\n\n**Keyword type**: You can only use it with a job’s `stage` keyword.\n\n**Example of `stage: .post`**:\n\n```python\nstages:\n - build\n - test\n\njob1:\nstage: build\nscript:\n - echo \"This job runs in the build stage.\"\n\nlast-job:\nstage: .post\nscript:\n - echo \"This job runs in the .post stage, after all other stages.\"\n\njob2:\nstage: test\nscript:\n - echo \"This job runs in the test stage.\"\n```\n\n**Additional details**:\n\n- A [pipeline execution policy](https://docs.gitlab.com/user/application_security/policies/pipeline_execution_policies/)can define a `.pipeline-policy-post`stage which runs after `.post`.\n\n* * *\n\n#### `tags`\n\nUse `tags` to select a specific runner from the list of all runners that are available for the project.\n\nWhen you register a runner, you can specify the runner’s tags, for example `ruby`, `postgres`, or `development`. To pick up and run a job, a runner must be assigned every tag listed in the job.\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:tags`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `tags`, the job configuration takes precedence and the default configuration is not used.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of tag names, which are case-sensitive.- CI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `tags`**:\n\n```python\njob:\ntags:\n - ruby\n - postgres\n```\n\nIn this example, only runners with both the `ruby` and `postgres` tags can run the job.\n\n**Additional details**:\n\n- The number of tags must be less than `50`.\n\n**Related topics**:\n\n- [Use tags to control which jobs a runner can run](https://docs.gitlab.com/ci/runners/configure_runners/#control-jobs-that-a-runner-can-run)\n- [Select different runner tags for each parallel matrix job](https://docs.gitlab.com/ci/jobs/job_control/#select-different-runner-tags-for-each-parallel-matrix-job)- Runner tags for hosted runners:\n - [Hosted runners on Linux](https://docs.gitlab.com/ci/runners/hosted_runners/linux/)\n- [GPU-enabled hosted runners](https://docs.gitlab.com/ci/runners/hosted_runners/gpu_enabled/)\n- [Hosted runners on macOS](https://docs.gitlab.com/ci/runners/hosted_runners/macos/)\n- [Hosted runners on Windows](https://docs.gitlab.com/ci/runners/hosted_runners/windows/)\n\n* * *\n\n#### `timeout`\n\nUse `timeout` to configure a timeout for a specific job. If the job runs for longer than the timeout, the job fails.\n\nThe job-level timeout can be longer than the [project-level timeout](https://docs.gitlab.com/ci/pipelines/settings/#set-a-limit-for-how-long-jobs-can-run), but can’t be longer than the [runner’s timeout](https://docs.gitlab.com/ci/runners/configure_runners/#set-the-maximum-job-timeout).\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: A period of time written in natural language. For example, these are all equivalent:\n\n- `3600 seconds`- `60 minutes`- `one hour`\n\n**Example of `timeout`**:\n\n```python\nbuild:\nscript: build.sh\ntimeout: 3 hours 30 minutes\n\ntest:\nscript: rspec\ntimeout: 3h 30m\n```\n\n* * *\n\n#### `trigger`\n\nUse `trigger` to declare that a job is a “trigger job” which starts a [downstream pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/) that is either:\n\n- [A multi-project pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#multi-project-pipelines).- [A child pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines).\n\nTrigger jobs can use only a limited set of GitLab CI/CD configuration keywords. The keywords available for use in trigger jobs are:\n\n- [allow_failure](https://docs.gitlab.com/ci/yaml/#allow_failure).- [extends](https://docs.gitlab.com/ci/yaml/#extends).- [needs](https://docs.gitlab.com/ci/yaml/#needs), but not [needs:project](https://docs.gitlab.com/ci/yaml/#needsproject).- [only and except](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#only--except).- [parallel](https://docs.gitlab.com/ci/yaml/#parallel).- [rules](https://docs.gitlab.com/ci/yaml/#rules).- [stage](https://docs.gitlab.com/ci/yaml/#stage).- [trigger](https://docs.gitlab.com/ci/yaml/#trigger).- [variables](https://docs.gitlab.com/ci/yaml/#variables).- [when](https://docs.gitlab.com/ci/yaml/#when)(only with a value of `on_success`, `on_failure`, or `always`).- [resource_group](https://docs.gitlab.com/ci/yaml/#resource_group).- [environment](https://docs.gitlab.com/ci/yaml/#environment).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- For multi-project pipelines, the path to the downstream project. CI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file)in GitLab 15.3 and later, but not [job-only variables](https://docs.gitlab.com/ci/variables/predefined_variables/#variable-availability). Alternatively, use [trigger:project](https://docs.gitlab.com/ci/yaml/#triggerproject).- For child pipelines, use [trigger:include](https://docs.gitlab.com/ci/yaml/#triggerinclude).\n\n**Example of `trigger`**:\n\n```python\ntrigger-multi-project-pipeline:\ntrigger: my-group/my-project\n```\n\n**Additional details**:\n\n- You can use [when:manual](https://docs.gitlab.com/ci/yaml/#when)in the same job as `trigger`, but you cannot use the API to start `when:manual`trigger jobs. See [issue 284086](https://gitlab.com/gitlab-org/gitlab/-/issues/284086)for more details.- You cannot [manually specify CI/CD variables](https://docs.gitlab.com/ci/jobs/job_control/#specify-variables-when-running-manual-jobs)before running a manual trigger job.- [CI/CD variables](https://docs.gitlab.com/ci/yaml/#variables)defined in a top-level `variables`section (globally) or in the trigger job are forwarded to the downstream pipeline as [trigger variables](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#pass-cicd-variables-to-a-downstream-pipeline).- [Pipeline variables](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence)are not passed to downstream pipelines by default. Use [trigger:forward](https://docs.gitlab.com/ci/yaml/#triggerforward)to forward these variables to downstream pipelines.- [Job-only variables](https://docs.gitlab.com/ci/variables/predefined_variables/#variable-availability)are not available in trigger jobs.- Environment variables [defined in the runner’s config.toml](https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runners-section)are not available to trigger jobs and are not passed to downstream pipelines.- You cannot use [needs:pipeline:job](https://docs.gitlab.com/ci/yaml/#needspipelinejob)in a trigger job.\n\n**Related topics**:\n\n- [Multi-project pipeline configuration examples](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#trigger-a-downstream-pipeline-from-a-job-in-the-gitlab-ciyml-file).- To run a pipeline for a specific branch, tag, or commit, you can use a [trigger token](https://docs.gitlab.com/ci/triggers/)to authenticate with the [pipeline triggers API](https://docs.gitlab.com/api/pipeline_triggers/). The trigger token is different than the `trigger`keyword.\n\n* * *\n\n##### `trigger:inputs`\n\nUse `trigger:inputs` to set the [inputs](https://docs.gitlab.com/ci/inputs/) for a multi-project pipeline when the downstream pipeline configuration uses [`spec:inputs`](https://docs.gitlab.com/ci/yaml/#specinputs).\n\n**Example of `trigger:inputs`**:\n\n```python\ntrigger:\n - project: 'my-group/my-project'\ninputs:\nwebsite: \"My website\"\n```\n\n* * *\n\n##### `trigger:include`\n\nUse `trigger:include` to declare that a job is a “trigger job” which starts a [child pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- The path to the child pipeline’s configuration file.\n\n**Example of `trigger:include`**:\n\n```python\ntrigger-child-pipeline:\ntrigger:\ninclude: path/to/child-pipeline.gitlab-ci.yml\n```\n\n**Additional details**:\n\nUse:\n\n- `trigger:include:artifact` to trigger a [dynamic child pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#dynamic-child-pipelines).- `trigger:include:inputs` to set the [inputs](https://docs.gitlab.com/ci/inputs/) when the downstream pipeline configuration uses [`spec:inputs`](https://docs.gitlab.com/ci/yaml/#specinputs).- `trigger:include:local` for a path to a child pipeline configuration file when:\n - Combining [multiple child pipeline configuration files](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#combine-multiple-child-pipeline-configuration-files).- Combined with `trigger:include:inputs` to pass inputs to the child pipeline. For example: ```python\nstaging-job:\ntrigger:\ninclude:\n - local: path/to/child-pipeline.yml\ninputs:\nenvironment: staging\n ```- `trigger:include:project` to trigger a child pipeline [with a configuration file in a different project](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#use-a-child-pipeline-configuration-file-in-a-different-project). If the file contains additional [`include`](https://docs.gitlab.com/ci/yaml/#include) entries, GitLab looks for the files in the project running the pipeline, not the project hosting the file.- `trigger:include:template` to trigger a child pipeline with a CI/CD template.\n\n**Related topics**:\n\n- [Child pipeline configuration examples](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#trigger-a-downstream-pipeline-from-a-job-in-the-gitlab-ciyml-file).\n\n* * *\n\n##### `trigger:include:inputs`\n\nUse `trigger:include:inputs` to set the [inputs](https://docs.gitlab.com/ci/inputs/) for a child pipeline when the downstream pipeline configuration uses [`spec:inputs`](https://docs.gitlab.com/ci/yaml/#specinputs).\n\n**Example of `trigger:inputs`**:\n\n```python\ntrigger-job:\ntrigger:\ninclude:\n - local: path/to/child-pipeline.yml\ninputs:\nwebsite: \"My website\"\n```\n\n* * *\n\n##### `trigger:project`\n\nUse `trigger:project` to declare that a job is a “trigger job” which starts a [multi-project pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#multi-project-pipelines).\n\nBy default, the multi-project pipeline triggers for the default branch. Use `trigger:branch` to specify a different branch.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- The path to the downstream project. CI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file)in GitLab 15.3 and later, but not [job-only variables](https://docs.gitlab.com/ci/variables/predefined_variables/#variable-availability).\n\n**Example of `trigger:project`**:\n\n```python\ntrigger-multi-project-pipeline:\ntrigger:\nproject: my-group/my-project\n```\n\n**Example of `trigger:project` for a different branch**:\n\n```python\ntrigger-multi-project-pipeline:\ntrigger:\nproject: my-group/my-project\nbranch: development\n```\n\n**Related topics**:\n\n- [Multi-project pipeline configuration examples](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#trigger-a-downstream-pipeline-from-a-job-in-the-gitlab-ciyml-file).- To run a pipeline for a specific branch, tag, or commit, you can also use a [trigger token](https://docs.gitlab.com/ci/triggers/)to authenticate with the [pipeline triggers API](https://docs.gitlab.com/api/pipeline_triggers/). The trigger token is different than the `trigger`keyword.\n\n* * *\n\n##### `trigger:strategy`\n\nUse `trigger:strategy` to force the `trigger` job to wait for the downstream pipeline to complete before it is marked as **success**.\n\nThis behavior is different than the default, which is for the `trigger` job to be marked as **success** as soon as the downstream pipeline is created.\n\nThis setting makes your pipeline execution linear rather than parallel.\n\n**Supported values**:\n\n- `mirror`: Mirrors the status of the downstream pipeline exactly.- `depend`: Not recommended, use `mirror`instead. The trigger job status shows **failed**, **success**, or **running**, depending on the downstream pipeline status. See additional details.\n\n**Example of `trigger:strategy`**:\n\n```python\ntrigger_job:\ntrigger:\ninclude: path/to/child-pipeline.yml\nstrategy: mirror\n```\n\nIn this example, jobs from subsequent stages wait for the triggered pipeline to successfully complete before starting.\n\n**Additional details**:\n\n- [Optional manual jobs](https://docs.gitlab.com/ci/jobs/job_control/#types-of-manual-jobs)in the downstream pipeline do not affect the status of the downstream pipeline or the upstream trigger job. The downstream pipeline can complete successfully without running any optional manual jobs.- By default, jobs in later stages do not start until the trigger job completes.- [Blocking manual jobs](https://docs.gitlab.com/ci/jobs/job_control/#types-of-manual-jobs)in the downstream pipeline must run before the trigger job is marked as successful or failed.- When using `strategy:depend`(no longer recommended, use `strategy:mirror`instead):\n - The trigger job shows **running**( status\\_running) if the downstream pipeline status is **waiting for manual action**( status\\_manual) due to manual jobs.- If the downstream pipeline has a failed job, but the job uses [allow_failure: true](https://docs.gitlab.com/ci/yaml/#allow_failure), the downstream pipeline is considered successful and the trigger job shows **success**.\n\n* * *\n\n##### `trigger:forward`\n\nUse `trigger:forward` to specify what to forward to the downstream pipeline. You can control what is forwarded to both [parent-child pipelines](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines) and [multi-project pipelines](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#multi-project-pipelines).\n\nForwarded variables do not get forwarded again in nested downstream pipelines by default, unless the nested downstream trigger job also uses `trigger:forward`.\n\n**Supported values**:\n\n- `yaml_variables`: `true`(default), or `false`. When `true`, variables defined in the trigger job are passed to downstream pipelines.- `pipeline_variables`: `true`or `false`(default). When `true`, [pipeline variables](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence)are passed to the downstream pipeline.\n\n**Example of `trigger:forward`**:\n\n[Run this pipeline manually](https://docs.gitlab.com/ci/pipelines/#run-a-pipeline-manually), with the CI/CD variable `MYVAR = my value`:\n\n```python\nvariables: # default variables for each job\nVAR: value\n\n---\n\n## Default behavior:\n---\n\n## - VAR is passed to the child\n---\n\n## - MYVAR is not passed to the child child1: trigger: include: .child-pipeline.yml\n\n---\n\n## Forward pipeline variables:\n---\n\n## - VAR is passed to the child\n---\n\n## - MYVAR is passed to the child child2: trigger: include: .child-pipeline.yml forward: pipeline_variables: true\n\n---\n\n## Do not forward YAML variables:\n---\n\n## - VAR is not passed to the child\n---\n\n## - MYVAR is not passed to the child child3: trigger: include: .child-pipeline.yml forward: yaml_variables: false\n```\n\n**Additional details**:\n\n- CI/CD variables forwarded to downstream pipelines with `trigger:forward`are [pipeline variables](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence), which have high precedence. If a variable with the same name is defined in the downstream pipeline, that variable is usually overwritten by the forwarded variable.\n\n* * *\n\n#### `when`\n\nUse `when` to configure the conditions for when jobs run. If not defined in a job, the default value is `when: on_success`.\n\n**Keyword type**: Job keyword. You can use it as part of a job. `when: always` and `when: never` can also be used in [`workflow:rules`](https://docs.gitlab.com/ci/yaml/#workflow).\n\n**Supported values**:\n\n- `on_success`(default): Run the job only when no jobs in earlier stages fail.- `on_failure`: Run the job only when at least one job in an earlier stage fails.- `never`: Don’t run the job regardless of the status of jobs in earlier stages. Can only be used in a [rules](https://docs.gitlab.com/ci/yaml/#ruleswhen)section or [workflow: rules](https://docs.gitlab.com/ci/yaml/#workflowrules).- `always`: Run the job regardless of the status of jobs in earlier stages.- `manual`: Add the job to the pipeline as a [manual job](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually).- `delayed`: Add the job to the pipeline as a [delayed job](https://docs.gitlab.com/ci/jobs/job_control/#run-a-job-after-a-delay).\n\n**Example of `when`**:\n\n```python\nstages:\n - build\n - cleanup_build\n - test\n - deploy\n - cleanup\n\nbuild_job:\nstage: build\nscript:\n - make build\n\ncleanup_build_job:\nstage: cleanup_build\nscript:\n - cleanup build when failed\nwhen: on_failure\n\ntest_job:\nstage: test\nscript:\n - make test\n\ndeploy_job:\nstage: deploy\nscript:\n - make deploy\nwhen: manual\nenvironment: production\n\ncleanup_job:\nstage: cleanup\nscript:\n - cleanup after jobs\nwhen: always\n```\n\nIn this example, the script:\n\n- Executes `cleanup_build_job`only when `build_job`fails.- Always executes `cleanup_job`as the last step in pipeline regardless of success or failure.- Executes `deploy_job`when you run it manually in the GitLab UI.\n\n**Additional details**:\n\n- When evaluating the status of jobs for `on_success`and `on_failure`:\n - Jobs with [allow_failure: true](https://docs.gitlab.com/ci/yaml/#allow_failure)in earlier stages are considered successful, even if they failed.- Skipped jobs in earlier stages, for example [manual jobs that have not been started](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually), are considered successful.- The default value for [allow_failure](https://docs.gitlab.com/ci/yaml/#allow_failure)is `true`with `when: manual`. The default value changes to `false`with [rules:when: manual](https://docs.gitlab.com/ci/yaml/#ruleswhen).\n\n**Related topics**:\n\n- `when`can be used with [rules](https://docs.gitlab.com/ci/yaml/#rules)for more dynamic job control.- `when`can be used with [workflow](https://docs.gitlab.com/ci/yaml/#workflow)to control when a pipeline can start.\n\n* * *\n\n##### `manual_confirmation`\n\nUse `manual_confirmation` with [`when: manual`](https://docs.gitlab.com/ci/yaml/#when) to define a custom confirmation message for manual jobs. If no manual job is defined with `when: manual`, this keyword has no effect.\n\nManual confirmation works with all manual jobs, including environment stop jobs that use [`environment:action: stop`](https://docs.gitlab.com/ci/yaml/#environmentaction).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A string with the confirmation message.\n\n**Example of `manual_confirmation`**:\n\n```python\ndelete_job:\nstage: post-deployment\nscript:\n - make delete\nwhen: manual\nmanual_confirmation: 'Are you sure you want to delete this environment?'\n\nstop_production:\nstage: cleanup\nscript:\n - echo \"Stopping production environment\"\nenvironment:\nname: production\naction: stop\nwhen: manual\nmanual_confirmation: \"Are you sure you want to stop the production environment?\"\n```\n\n* * *\n\n#### `start_in`\n\nUse `start_in` to delay the execution of a job for a specified duration after the job is created. You must configure `when: delayed` for the job.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Possible inputs**: A period of time in seconds, minutes, or hours. Must be less than or equal to one week. Examples of valid values:\n\n- `'5'`(5 seconds)- `'10 seconds'`- `'30 minutes'`- `'1 hour'`- `'1 day'`\n\n**Example of `start_in`**:\n\n```python\ndeploy_production:\nstage: deploy\nscript:\n - echo \"Deploying to production\"\nwhen: delayed\nstart_in: 30 minutes\n```\n\nIn this example, the `deploy_production` job starts 30 minutes after the previous stage completes.\n\n**Additional details**:\n\n- The timer starts when the job’s stage begins, not when the previous job finishes.- To manually start a delayed job immediately, select **Play**( play) in the pipeline view.- The minimum delay period is one second and the maximum delay is one week.- `start_in`only works when [when](https://docs.gitlab.com/ci/yaml/#when)is set to `delayed`. If you use any other value for `when`, the configuration is invalid. If a job uses `rules`, `start_in`and `when`must be defined in the `rules`, not at the job level. Otherwise, you receive a validation error: `config key may not be used with 'rules': start_in`.- `start_in`is not supported with `workflow:rules`, but does not cause any syntax violation.\n\n**Related topics**:\n\n- [Run a job after a delay](https://docs.gitlab.com/ci/jobs/job_control/#run-a-job-after-a-delay)\n\n* * *\n\n### `variables`\n\nUse `variables` to define [CI/CD variables](https://docs.gitlab.com/ci/variables/#define-a-cicd-variable-in-the-gitlab-ciyml-file).\n\nVariables can be [defined in a CI/CD job](https://docs.gitlab.com/ci/yaml/#job-variables), or as a top-level (global) keyword to define [default CI/CD variables](https://docs.gitlab.com/ci/yaml/#default-variables) for all jobs.\n\n**Additional details**:\n\n- All YAML-defined variables are also set to any linked [Docker service containers](https://docs.gitlab.com/ci/services/).- YAML-defined variables are meant for non-sensitive project configuration. Store sensitive information in [protected variables](https://docs.gitlab.com/ci/variables/#protect-a-cicd-variable)or [CI/CD secrets](https://docs.gitlab.com/ci/secrets/).- [Manual pipeline variables](https://docs.gitlab.com/ci/variables/#use-pipeline-variables)and [scheduled pipeline variables](https://docs.gitlab.com/ci/pipelines/schedules/#create-a-pipeline-schedule)are not passed to downstream pipelines by default. Use [trigger:forward](https://docs.gitlab.com/ci/yaml/#triggerforward)to forward these variables to downstream pipelines.\n\n**Related topics**:\n\n- [Predefined variables](https://docs.gitlab.com/ci/variables/predefined_variables/)are variables the runner automatically creates and makes available in the job.- You can [configure runner behavior with variables](https://docs.gitlab.com/ci/runners/configure_runners/#configure-runner-behavior-with-variables).\n\n* * *\n\n#### Job `variables`\n\nYou can use job variables in commands in the job’s `script`, `before_script`, or `after_script` sections, and also with some [job keywords](https://docs.gitlab.com/ci/yaml/#job-keywords). Check the **Supported values** section of each job keyword to see if it supports variables.\n\nYou cannot use job variables as values for [global keywords](https://docs.gitlab.com/ci/yaml/#global-keywords) like [`include`](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Supported values**: Variable name and value pairs:\n\n- The name can use only numbers, letters, and underscores ( `_`). In some shells, the first character must be a letter.- The value must be a string.\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of job `variables`**:\n\n```python\nreview_job:\nvariables:\nDEPLOY_SITE: \"https://dev.example.com/\"\nREVIEW_PATH: \"/review\"\nscript:\n - deploy-review-script --url $DEPLOY_SITE --path $REVIEW_PATH\n```\n\nIn this example:\n\n- `review_job`has `DEPLOY_SITE`and `REVIEW_PATH`job variables defined. Both job variables can be used in the `script`section.\n\n* * *\n\n#### Default `variables`\n\nVariables defined in a top-level `variables` section act as default variables for all jobs.\n\nEach default variable is made available to every job in the pipeline, except when the job already has a variable defined with the same name. The variable defined in the job [takes precedence](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence), so the value of the default variable with the same name cannot be used in the job.\n\nLike job variables, you cannot use default variables as values for other global keywords, like [`include`](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Supported values**: Variable name and value pairs:\n\n- The name can use only numbers, letters, and underscores ( `_`). In some shells, the first character must be a letter.- The value must be a string.\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Examples of `variables`**:\n\n```python\nvariables:\nDEPLOY_SITE: \"https://example.com/\"\n\ndeploy_job:\nstage: deploy\nscript:\n - deploy-script --url $DEPLOY_SITE --path \"/\"\nenvironment: production\n\ndeploy_review_job:\nstage: deploy\nvariables:\nDEPLOY_SITE: \"https://dev.example.com/\"\nREVIEW_PATH: \"/review\"\nscript:\n - deploy-review-script --url $DEPLOY_SITE --path $REVIEW_PATH\nenvironment: production\n```\n\nIn this example:\n\n- `deploy_job`has no variables defined. The default `DEPLOY_SITE`variable is copied to the job and can be used in the `script`section.- `deploy_review_job`already has a `DEPLOY_SITE`variable defined, so the default `DEPLOY_SITE`is not copied to the job. The job also has a `REVIEW_PATH`job variable defined. Both job variables can be used in the `script`section.\n\n* * *\n\n##### `variables:description`\n\nUse the `description` keyword to define a description for a default variable. The description displays with [the prefilled variable name when running a pipeline manually](https://docs.gitlab.com/ci/pipelines/#prefill-variables-in-manual-pipelines).\n\n**Keyword type**: You can only use this keyword with default `variables`, not job `variables`.\n\n**Supported values**:\n\n- A string. You can use Markdown.\n\n**Example of `variables:description`**:\n\n```python\nvariables:\nDEPLOY_NOTE:\ndescription: \"The deployment note. Explain the reason for this deployment.\"\n```\n\n**Additional details**:\n\n- When used without `value`, the variable exists in pipelines that were not triggered manually, and the default value is an empty string ( `''`).\n\n* * *\n\n##### `variables:value`\n\nUse the `value` keyword to define a pipeline-level (default) variable’s value. When used with [`variables: description`](https://docs.gitlab.com/ci/yaml/#variablesdescription), the variable value is [prefilled when running a pipeline manually](https://docs.gitlab.com/ci/pipelines/#prefill-variables-in-manual-pipelines).\n\n**Keyword type**: You can only use this keyword with default `variables`, not job `variables`.\n\n**Supported values**:\n\n- A string.\n\n**Example of `variables:value`**:\n\n```python\nvariables:\nDEPLOY_ENVIRONMENT:\nvalue: \"staging\"\ndescription: \"The deployment target. Change this variable to 'canary' or 'production' if needed.\"\n```\n\n**Additional details**:\n\n- If used without [variables: description](https://docs.gitlab.com/ci/yaml/#variablesdescription), the behavior is the same as [variables](https://docs.gitlab.com/ci/yaml/#variables).\n\n* * *\n\n##### `variables:options`\n\nUse `variables:options` to define an array of values that are [selectable in the UI when running a pipeline manually](https://docs.gitlab.com/ci/pipelines/#configure-a-list-of-selectable-prefilled-variable-values).\n\nMust be used with `variables: value`, and the string defined for `value`:\n\n- Must also be one of the strings in the `options`array.- Is the default selection.\n\nIf there is no [`description`](https://docs.gitlab.com/ci/yaml/#variablesdescription), this keyword has no effect.\n\n**Keyword type**: You can only use this keyword with default `variables`, not job `variables`.\n\n**Supported values**:\n\n- An array of strings.\n\n**Example of `variables:options`**:\n\n```python\nvariables:\nDEPLOY_ENVIRONMENT:\nvalue: \"staging\"\noptions:\n - \"production\"\n - \"staging\"\n - \"canary\"\ndescription: \"The deployment target. Set to 'staging' by default.\"\n```\n\n* * *\n\n#### `variables:expand`\n\nUse the `expand` keyword to configure a variable to be expandable or not.\n\n**Keyword type**: You can use this keyword with both default and job `variables`.\n\n**Supported values**:\n\n- `true`(default): The variable is expandable.- `false`: The variable is not expandable.\n\n**Example of `variables:expand`**:\n\n```python\nvariables:\nVAR1: value1\nVAR2: value2 $VAR1\nVAR3:\nvalue: value3 $VAR1\nexpand: false\n```\n\n- The result of `VAR2`is `value2 value1`.- The result of `VAR3`is `value3 $VAR1`.\n\n**Additional details**:\n\n- The `expand`keyword can only be used with default and job `variables`keywords. You can’t use it with [rules:variables](https://docs.gitlab.com/ci/yaml/#rulesvariables)or [workflow:rules:variables](https://docs.gitlab.com/ci/yaml/#workflowrulesvariables).",
			"chunks": [
				{
					"id": "ci_yaml_chunk_1",
					"content": "- Tier: Free, Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nThis document lists the configuration options for the GitLab `.gitlab-ci.yml` file. This file is where you define the CI/CD jobs that make up your pipeline.\n\n- If you are already familiar with [basic CI/CD concepts](https://docs.gitlab.com/ci/), try creating your own `.gitlab-ci.yml`file by following a tutorial that demonstrates a [simple](https://docs.gitlab.com/ci/quick_start/)or [complex](https://docs.gitlab.com/ci/quick_start/tutorial/)pipeline.- For a collection of examples, see [GitLab CI/CD examples](https://docs.gitlab.com/ci/examples/).- To view a large `.gitlab-ci.yml`file used in an enterprise, see the [.gitlab-ci.yml file for gitlab](https://gitlab.com/gitlab-org/gitlab/-/blob/master/.gitlab-ci.yml).\n\nWhen you are editing your `.gitlab-ci.yml` file, you can validate it with the [CI Lint](https://docs.gitlab.com/ci/yaml/lint/) tool.\n\nGitLab CI/CD configuration uses YAML formatting, so the order of keywords is not important unless otherwise specified.\n\nUse [CI/CD expressions](https://docs.gitlab.com/ci/yaml/expressions/) for more dynamic pipeline configuration options.",
					"tokensEstimate": 296,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_2",
					"content": "### Keywords\n\n\n\nA GitLab CI/CD pipeline configuration includes:\n\n- [Global keywords](https://docs.gitlab.com/ci/yaml/#global-keywords) that configure pipeline behavior: Keyword\n\nDescription\n\n[`default`](https://docs.gitlab.com/ci/yaml/#default)\n\nCustom default values for job keywords.\n\n[`include`](https://docs.gitlab.com/ci/yaml/#include)\n\nImport configuration from other YAML files.\n\n[`stages`](https://docs.gitlab.com/ci/yaml/#stages)\n\nThe names and order of the pipeline stages.\n\n[`variables`](https://docs.gitlab.com/ci/yaml/#default-variables)\n\nDefine default CI/CD variables for all jobs in the pipeline.\n\n[`workflow`](https://docs.gitlab.com/ci/yaml/#workflow)\n\nControl what types of pipeline run.- [Header keywords](https://docs.gitlab.com/ci/yaml/#header-keywords) Keyword\n\nDescription\n\n[`spec`](https://docs.gitlab.com/ci/yaml/#spec)\n\nDefine specifications for external configuration files.- [Jobs](https://docs.gitlab.com/ci/jobs/) configured with [job keywords](https://docs.gitlab.com/ci/yaml/#job-keywords): Keyword\n\nDescription\n\n[`after_script`](https://docs.gitlab.com/ci/yaml/#after_script)\n\nOverride a set of commands that are executed after job.\n\n[`allow_failure`](https://docs.gitlab.com/ci/yaml/#allow_failure)\n\nAllow job to fail. A failed job does not cause the pipeline to fail.\n\n[`artifacts`](https://docs.gitlab.com/ci/yaml/#artifacts)\n\nList of files and directories to attach to a job on success.\n\n[`before_script`](https://docs.gitlab.com/ci/yaml/#before_script)\n\nOverride a set of commands that are executed before job.\n\n[`cache`](https://docs.gitlab.com/ci/yaml/#cache)\n\nList of files that should be cached between subsequent runs.\n\n[`coverage`](https://docs.gitlab.com/ci/yaml/#coverage)\n\nCode coverage settings for a given job.\n\n[`dast_configuration`](https://docs.gitlab.com/ci/yaml/#dast_configuration)\n\nUse configuration from DAST profiles on a job level.\n\n[`dependencies`](https://docs.gitlab.com/ci/yaml/#dependencies)\n\nRestrict which artifacts are passed to a specific job by providing a list of jobs to fetch artifacts from.\n\n[`environment`](https://docs.gitlab.com/ci/yaml/#environment)\n\nName of an environment to which the job deploys.\n\n[`extends`](https://docs.gitlab.com/ci/yaml/#extends)\n\nConfiguration entries that this job inherits from.\n\n[`identity`](https://docs.gitlab.com/ci/yaml/#identity)\n\nAuthenticate with third party services using identity federation.",
					"tokensEstimate": 592,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_3",
					"content": "[`image`](https://docs.gitlab.com/ci/yaml/#image)\n\nUse Docker images.\n\n[`inherit`](https://docs.gitlab.com/ci/yaml/#inherit)\n\nSelect which global defaults all jobs inherit.\n\n[`interruptible`](https://docs.gitlab.com/ci/yaml/#interruptible)\n\nDefines if a job can be canceled when made redundant by a newer run.\n\n[`manual_confirmation`](https://docs.gitlab.com/ci/yaml/#manual_confirmation)\n\nDefine a custom confirmation message for a manual job.\n\n[`needs`](https://docs.gitlab.com/ci/yaml/#needs)\n\nExecute jobs earlier than the stage ordering.\n\n[`pages`](https://docs.gitlab.com/ci/yaml/#pages)\n\nUpload the result of a job to use with GitLab Pages.\n\n[`parallel`](https://docs.gitlab.com/ci/yaml/#parallel)\n\nHow many instances of a job should be run in parallel.\n\n[`release`](https://docs.gitlab.com/ci/yaml/#release)\n\nInstructs the runner to generate a [release](https://docs.gitlab.com/user/project/releases/) object.\n\n[`resource_group`](https://docs.gitlab.com/ci/yaml/#resource_group)\n\nLimit job concurrency.\n\n[`retry`](https://docs.gitlab.com/ci/yaml/#retry)\n\nWhen and how many times a job can be auto-retried in case of a failure.\n\n[`rules`](https://docs.gitlab.com/ci/yaml/#rules)\n\nList of conditions to evaluate and determine selected attributes of a job, and whether or not it’s created.\n\n[`script`](https://docs.gitlab.com/ci/yaml/#script)\n\nShell script that is executed by a runner.\n\n[`run`](https://docs.gitlab.com/ci/yaml/#run)\n\nRun configuration that is executed by a runner.\n\n[`secrets`](https://docs.gitlab.com/ci/yaml/#secrets)\n\nThe CI/CD secrets the job needs.\n\n[`services`](https://docs.gitlab.com/ci/yaml/#services)\n\nUse Docker services images.\n\n[`stage`](https://docs.gitlab.com/ci/yaml/#stage)\n\nDefines a job stage.\n\n[`start_in`](https://docs.gitlab.com/ci/yaml/#start_in)\n\nDelay job execution for a specified duration. Requires `when: delayed`.\n\n[`tags`](https://docs.gitlab.com/ci/yaml/#tags)\n\nList of tags that are used to select a runner.\n\n[`timeout`](https://docs.gitlab.com/ci/yaml/#timeout)\n\nDefine a custom job-level timeout that takes precedence over the project-wide setting.\n\n[`trigger`](https://docs.gitlab.com/ci/yaml/#trigger)\n\nDefines a downstream pipeline trigger.\n\n[`variables`](https://docs.gitlab.com/ci/yaml/#job-variables)\n\nDefine CI/CD variables for individual jobs.\n\n[`when`](https://docs.gitlab.com/ci/yaml/#when)\n\nWhen to run job.- [Deprecated keywords](https://docs.gitlab.com/ci/yaml/deprecated_keywords/) that are no longer recommended for use.\n\n* * *\n\n### Global keywords\n\nSome keywords are not defined in a job. These keywords control pipeline behavior or import additional pipeline configuration.\n\n* * *",
					"tokensEstimate": 652,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_4",
					"content": "#### `default`\n\nYou can set global defaults for some keywords. Each default keyword is copied to every job that doesn’t already have it defined.\n\nDefault configuration does not merge with job configuration. If the job already has a keyword defined, the job keyword takes precedence and the default configuration for that keyword is not used.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: These keywords can have custom defaults:\n\n- [after_script](https://docs.gitlab.com/ci/yaml/#after_script)\n- [artifacts](https://docs.gitlab.com/ci/yaml/#artifacts)\n- [before_script](https://docs.gitlab.com/ci/yaml/#before_script)\n- [cache](https://docs.gitlab.com/ci/yaml/#cache)\n- [hooks](https://docs.gitlab.com/ci/yaml/#hooks)\n- [id_tokens](https://docs.gitlab.com/ci/yaml/#id_tokens)\n- [image](https://docs.gitlab.com/ci/yaml/#image)\n- [interruptible](https://docs.gitlab.com/ci/yaml/#interruptible)\n- [retry](https://docs.gitlab.com/ci/yaml/#retry)\n- [services](https://docs.gitlab.com/ci/yaml/#services)\n- [tags](https://docs.gitlab.com/ci/yaml/#tags)\n- [timeout](https://docs.gitlab.com/ci/yaml/#timeout), though due to [issue 213634](https://gitlab.com/gitlab-org/gitlab/-/issues/213634)this keyword has no effect.\n\n**Example of `default`**:\n\n```python\ndefault:\nimage: ruby:3.0\nretry: 2\n\nrspec:\nscript: bundle exec rspec\n\nrspec 2.7:\nimage: ruby:2.7\nscript: bundle exec rspec\n```\n\nIn this example:\n\n- `image: ruby:3.0`and `retry: 2`are the default keywords for all jobs in the pipeline.- The `rspec`job does not have `image`or `retry`defined, so it uses the defaults of `image: ruby:3.0`and `retry: 2`.- The `rspec 2.7`job does not have `retry`defined, but it does have `image`explicitly defined. It uses the default `retry: 2`, but ignores the default `image`and uses the `image: ruby:2.7`defined in the job.\n\n**Additional details**:\n\n- Control inheritance of default keywords in jobs with [inherit:default](https://docs.gitlab.com/ci/yaml/#inheritdefault).- Global defaults are not passed to [downstream pipelines](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/), which run independently of the upstream pipeline that triggered the downstream pipeline.\n\n* * *",
					"tokensEstimate": 542,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_5",
					"content": "#### `include`\n\nUse `include` to include external YAML files in your CI/CD configuration. You can split one long `.gitlab-ci.yml` file into multiple files to increase readability, or reduce duplication of the same configuration in multiple places.\n\nYou can also store template files in a central repository and include them in projects.\n\nThe `include` files are:\n\n- Merged with those in the `.gitlab-ci.yml`file.- Always evaluated first and then merged with the content of the `.gitlab-ci.yml`file, regardless of the position of the `include`keyword.\n\nThe time limit to resolve all files is 30 seconds.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: The `include` subkeys:\n\n- [include:component](https://docs.gitlab.com/ci/yaml/#includecomponent)\n- [include:local](https://docs.gitlab.com/ci/yaml/#includelocal)\n- [include:project](https://docs.gitlab.com/ci/yaml/#includeproject)\n- [include:remote](https://docs.gitlab.com/ci/yaml/#includeremote)\n- [include:template](https://docs.gitlab.com/ci/yaml/#includetemplate)\n\nAnd optionally:\n\n- [include:inputs](https://docs.gitlab.com/ci/yaml/#includeinputs)\n- [include:rules](https://docs.gitlab.com/ci/yaml/#includerules)\n- [include:integrity](https://docs.gitlab.com/ci/yaml/#includeintegrity)\n\n**Additional details**:\n\n- Only [certain CI/CD variables](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include)can be used with `include`keywords.- Use merging to customize and override included CI/CD configurations with local- You can override included configuration by having the same job name or global keyword in the `.gitlab-ci.yml`file. The two configurations are merged together, and the configuration in the `.gitlab-ci.yml`file takes precedence over the included configuration.- If you rerun a:\n - Job, the `include`files are not fetched again. All jobs in a pipeline use the configuration fetched when the pipeline was created. Any changes to the source `include`files do not affect job reruns.- Pipeline, the `include`files are fetched again. If they changed after the last pipeline run, the new pipeline uses the changed configuration.- You can have up to 150 includes per pipeline by default, including [nested](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes). Additionally:\n - In [GitLab 16.0 and later](https://gitlab.com/gitlab-org/gitlab/-/issues/207270)users on GitLab Self-Managed can change the [maximum includes](https://docs.gitlab.com/administration/settings/continuous_integration/#set-maximum-includes)value.- In [GitLab 15.10 and later](https://gitlab.com/gitlab-org/gitlab/-/issues/367150)you can have up to 150 includes. In nested includes, the same file can be included multiple times, but duplicated includes count towards the limit.- From [GitLab 14.9 to GitLab 15.9](https://gitlab.com/gitlab-org/gitlab/-/issues/28987), you can have up to 100 includes. The same file can be included multiple times in nested includes, but duplicates are ignored.\n\n* * *",
					"tokensEstimate": 739,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_6",
					"content": "##### `include:component`\n\nUse `include:component` to add a [CI/CD component](https://docs.gitlab.com/ci/components/) to the pipeline configuration.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: The full address of the CI/CD component, formatted as `<fully-qualified-domain-name>/<project-path>/<component-name>@<specific-version>`.\n\n**Example of `include:component`**:\n\n```python\ninclude:\n - component: $CI_SERVER_FQDN/my-org/security-components/secret-detection@1.0\n```\n\n**Related topics**:\n\n- [Use a CI/CD component](https://docs.gitlab.com/ci/components/#use-a-component).\n\n* * *",
					"tokensEstimate": 147,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_7",
					"content": "##### `include:local`\n\nUse `include:local` to include a file that is in the same repository and branch as the configuration file containing the `include` keyword. Use `include:local` instead of symbolic links.\n\n**Keyword type**: Global keyword.\n\n**Supported values**:\n\nA full path relative to the root directory (`/`):\n\n- The YAML file must have the extension `.yml`or `.yaml`.- You can [use * and ** wildcards in the file path](https://docs.gitlab.com/ci/yaml/includes/#use-includelocal-with-wildcard-file-paths).- You can use [certain CI/CD variables](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Example of `include:local`**:\n\n```python\ninclude:\n - local: '/templates/.gitlab-ci-template.yml'\n```\n\nYou can also use shorter syntax to define the path:\n\n```text\ninclude: '.gitlab-ci-production.yml'\n```\n\n**Additional details**:\n\n- The `.gitlab-ci.yml`file and the local file must be on the same branch.- You can’t include local files through Git submodules paths.- `include`configuration is always evaluated based on the location of the file containing the `include`keyword, not the project running the pipeline. If a [nested include](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes)is in a configuration file in a different project, `include: local`checks that other project for the file.\n\n* * *",
					"tokensEstimate": 332,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_8",
					"content": "##### `include:project`\n\nTo include files from another private project on the same GitLab instance, use `include:project` and `include:file`.\n\n**Keyword type**: Global keyword.\n\n**Supported values**:\n\n- `include:project`: The full GitLab project path.- `include:file`A full file path, or array of file paths, relative to the root directory ( `/`). The YAML files must have the `.yml`or `.yaml`extension.- `include:ref`: Optional. The ref to retrieve the file from. Defaults to the `HEAD`of the project when not specified.- You can use [certain CI/CD variables](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Example of `include:project`**:\n\n```python\ninclude:\n - project: 'my-group/my-project'\nfile: '/templates/.gitlab-ci-template.yml'\n - project: 'my-group/my-subgroup/my-project-2'\nfile:\n - '/templates/.builds.yml'\n - '/templates/.tests.yml'\n```\n\nYou can also specify a `ref`:\n\n```python\ninclude:\n - project: 'my-group/my-project'\nref: main # Git branch\nfile: '/templates/.gitlab-ci-template.yml'\n - project: 'my-group/my-project'\nref: v1.0.0 # Git Tag\nfile: '/templates/.gitlab-ci-template.yml'\n - project: 'my-group/my-project'\nref: 787123b47f14b552955ca2786bc9542ae66fee5b # Git SHA\nfile: '/templates/.gitlab-ci-template.yml'\n```\n\n**Additional details**:\n\n- `include`configuration is always evaluated based on the location of the file containing the `include`keyword, not the project running the pipeline. If a [nested include](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes)is in a configuration file in a different project, `include: local`checks that other project for the file.- When the pipeline starts, the `.gitlab-ci.yml`file configuration included by all methods is evaluated. The configuration is a snapshot in time and persists in the database. GitLab does not reflect any changes to the referenced `.gitlab-ci.yml`file configuration until the next pipeline starts.- When you include a YAML file from another private project, the user running the pipeline must be a member of both projects and have the appropriate permissions to run pipelines. A `not found or access denied`error may be displayed if the user does not have access to any of the included files.- Be careful when including another project’s CI/CD configuration file. No pipelines or notifications trigger when CI/CD configuration files change. From a security perspective, this is similar to pulling a third-party dependency. For the `ref`, consider:\n - Using a specific SHA hash, which should be the most stable option. Use the full 40-character SHA hash to ensure the desired commit is referenced, because using a short SHA hash for the `ref`might be ambiguous.- Applying both [protected branch](https://docs.gitlab.com/user/project/repository/branches/protected/)and [protected tag](https://docs.gitlab.com/user/project/protected_tags/#prevent-tag-creation-with-branch-names)rules to the `ref`in the other project. Protected tags and branches are more likely to pass through change management before changing.\n\n* * *",
					"tokensEstimate": 757,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_9",
					"content": "##### `include:remote`\n\nUse `include:remote` with a full URL to include a file from a different location.\n\n**Keyword type**: Global keyword.\n\n**Supported values**:\n\nA public URL accessible by an HTTP/HTTPS `GET` request:\n\n- Authentication with the remote URL is not supported.- The YAML file must have the extension `.yml`or `.yaml`.- You can use [certain CI/CD variables](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Example of `include:remote`**:\n\n```python\ninclude:\n - remote: 'https://gitlab.com/example-project/-/raw/main/.gitlab-ci.yml'\n```\n\n**Additional details**:\n\n- All [nested includes](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes)are executed without context as a public user, so you can only include public projects or templates. No variables are available in the `include`section of nested includes.- Be careful when including another project’s CI/CD configuration file. No pipelines or notifications trigger when the other project’s files change. From a security perspective, this is similar to pulling a third-party dependency. To verify the integrity of the included file, consider using the [integrity](https://docs.gitlab.com/ci/yaml/#includeintegrity)keyword. If you link to another GitLab project you own, consider the use of both [protected branches](https://docs.gitlab.com/user/project/repository/branches/protected/)and [protected tags](https://docs.gitlab.com/user/project/protected_tags/#prevent-tag-creation-with-branch-names)to enforce change management rules.\n\n* * *",
					"tokensEstimate": 383,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_10",
					"content": "##### `include:template`\n\nUse `include:template` to include [`.gitlab-ci.yml` templates](https://gitlab.com/gitlab-org/gitlab/-/tree/master/lib/gitlab/ci/templates).\n\n**Keyword type**: Global keyword.\n\n**Supported values**:\n\nA [CI/CD template](https://docs.gitlab.com/ci/examples/#cicd-templates):\n\n- All templates can be viewed in [lib/gitlab/ci/templates](https://gitlab.com/gitlab-org/gitlab/-/tree/master/lib/gitlab/ci/templates). Not all templates are designed to be used with `include:template`, so check template comments before using one.- You can use [certain CI/CD variables](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Example of `include:template`**:\n\n```bash",
					"tokensEstimate": 174,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_11",
					"content": "## File sourced from the GitLab template collection include:\n\n- template: Auto-DevOps.gitlab-ci.yml\n```\n\nMultiple `include:template` files:\n\n```python\ninclude:\n - template: Android-Fastlane.gitlab-ci.yml\n - template: Auto-DevOps.gitlab-ci.yml\n```\n\n**Additional details**:\n\n- All [nested includes](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes)are executed without context as a public user, so you can only include public projects or templates. No variables are available in the `include`section of nested includes.\n\n* * *",
					"tokensEstimate": 133,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_12",
					"content": "##### `include:inputs`\n\nUse `include:inputs` to set the values for input parameters when the included configuration uses [`spec:inputs`](https://docs.gitlab.com/ci/yaml/#specinputs) and is added to the pipeline.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: A string, numeric value, or boolean.\n\n**Example of `include:inputs`**:\n\n```python\ninclude:\n - local: 'custom_configuration.yml'\ninputs:\nwebsite: \"My website\"\n```\n\nIn this example:\n\n- The configuration contained in `custom_configuration.yml`is added to the pipeline, with a `website`input set to a value of `My website`for the included configuration.\n\n**Additional details**:\n\n- If the included configuration file uses [spec:inputs:type](https://docs.gitlab.com/ci/yaml/#specinputstype), the input value must match the defined type.- If the included configuration file uses [spec:inputs:options](https://docs.gitlab.com/ci/yaml/#specinputsoptions), the input value must match one of the listed options.\n\n**Related topics**:\n\n- [Set input values when using include](https://docs.gitlab.com/ci/inputs/#for-configuration-added-with-include).\n\n* * *",
					"tokensEstimate": 276,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_13",
					"content": "##### `include:rules`\n\nYou can use [`rules`](https://docs.gitlab.com/ci/yaml/#rules) with `include` to conditionally include other configuration files.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: These `rules` subkeys:\n\n- [rules:if](https://docs.gitlab.com/ci/yaml/#rulesif).- [rules:exists](https://docs.gitlab.com/ci/yaml/#rulesexists).- [rules:changes](https://docs.gitlab.com/ci/yaml/#ruleschanges).\n\nSome [CI/CD variables are supported](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Example of `include:rules`**:\n\n```python\ninclude:\n - local: build_jobs.yml\nrules:\n - if: $INCLUDE_BUILDS == \"true\"\n\ntest-job:\nstage: test\nscript: echo \"This is a test job\"\n```\n\nIn this example, if the `INCLUDE_BUILDS` variable is:\n\n- `true`, the `build_jobs.yml`configuration is included in the pipeline.- Not `true`or does not exist, the `build_jobs.yml`configuration is not included in the pipeline.\n\n**Related topics**:\n\n- Examples of using `include`with:\n - [rules:if](https://docs.gitlab.com/ci/yaml/includes/#include-with-rulesif).- [rules:changes](https://docs.gitlab.com/ci/yaml/includes/#include-with-ruleschanges).- [rules:exists](https://docs.gitlab.com/ci/yaml/includes/#include-with-rulesexists).\n\n* * *",
					"tokensEstimate": 308,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_14",
					"content": "##### `include:integrity`\n\nUse `integrity` with `include:remote` to specify a SHA256 hash of the included remote file. If `integrity` does not match the actual content, the remote file is not processed and the pipeline fails.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: Base64-encoded SHA256 hash of the included content.\n\n**Example of `include:integrity`**:\n\n```python\ninclude:\n - remote: 'https://gitlab.com/example-project/-/raw/main/.gitlab-ci.yml'\nintegrity: 'sha256-L3/GAoKaw0Arw6hDCKeKQlV1QPEgHYxGBHsH4zG1IY8='\n```\n\n* * *",
					"tokensEstimate": 134,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_15",
					"content": "#### `stages`\n\nUse `stages` to define stages that contain groups of jobs. Use [`stage`](https://docs.gitlab.com/ci/yaml/#stage) in a job to configure the job to run in a specific stage.\n\nIf `stages` is not defined in the `.gitlab-ci.yml` file, the default pipeline stages are:\n\n- [.pre](https://docs.gitlab.com/ci/yaml/#stage-pre)- `build`- `test`- `deploy`- [.post](https://docs.gitlab.com/ci/yaml/#stage-post)\n\nThe order of the items in `stages` defines the execution order for jobs:\n\n- Jobs in the same stage run in parallel.- Jobs in the next stage run after the jobs from the previous stage complete successfully.\n\nIf a pipeline contains only jobs in the `.pre` or `.post` stages, it does not run. There must be at least one other job in a different stage.\n\n**Keyword type**: Global keyword.\n\n**Example of `stages`**:\n\n```python\nstages:\n - build\n - test\n - deploy\n```\n\nIn this example:\n\n- All jobs in `build`execute in parallel.- If all jobs in `build`succeed, the `test`jobs execute in parallel.- If all jobs in `test`succeed, the `deploy`jobs execute in parallel.- If all jobs in `deploy`succeed, the pipeline is marked as `passed`.\n\nIf any job fails, the pipeline is marked as `failed` and jobs in later stages do not start. Jobs in the current stage are not stopped and continue to run.\n\n**Additional details**:\n\n- If a job does not specify a [stage](https://docs.gitlab.com/ci/yaml/#stage), the job is assigned the `test`stage.- If a stage is defined but no jobs use it, the stage is not visible in the pipeline, which can help [compliance pipeline configurations](https://docs.gitlab.com/user/compliance/compliance_pipelines/):\n - Stages can be defined in the compliance configuration but remain hidden if not used.- The defined stages become visible when developers use them in job definitions.\n\n**Related topics**:\n\n- To make a job start earlier and ignore the stage order, use the [needs](https://docs.gitlab.com/ci/yaml/#needs)keyword.\n\n* * *",
					"tokensEstimate": 484,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_16",
					"content": "#### `workflow`\n\nUse [`workflow`](https://docs.gitlab.com/ci/yaml/workflow/) to control pipeline behavior.\n\nYou can use some [predefined CI/CD variables](https://docs.gitlab.com/ci/variables/predefined_variables/) in `workflow` configuration, but not variables that are only defined when jobs start.\n\n**Related topics**:\n\n- [workflow: rules examples](https://docs.gitlab.com/ci/yaml/workflow/#workflow-rules-examples)\n- [Switch between branch pipelines and merge request pipelines](https://docs.gitlab.com/ci/yaml/workflow/#switch-between-branch-pipelines-and-merge-request-pipelines)\n\n* * *",
					"tokensEstimate": 147,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_17",
					"content": "##### `workflow:auto_cancel:on_new_commit`\n\nUse `workflow:auto_cancel:on_new_commit` to configure the behavior of the [auto-cancel redundant pipelines](https://docs.gitlab.com/ci/pipelines/settings/#auto-cancel-redundant-pipelines) feature.\n\n**Supported values**:\n\n- `conservative`: Cancel the pipeline, but only if no jobs with `interruptible: false`have started yet. Default when not defined.- `interruptible`: Cancel only jobs with `interruptible: true`.- `none`: Do not auto-cancel any jobs.\n\n**Example of `workflow:auto_cancel:on_new_commit`**:\n\n```python\nworkflow:\nauto_cancel:\non_new_commit: interruptible\n\njob1:\ninterruptible: true\nscript: sleep 60\n\njob2:\ninterruptible: false # Default when not defined.\nscript: sleep 60\n```\n\nIn this example:\n\n- When a new commit is pushed to a branch, GitLab creates a new pipeline and `job1`and `job2`start.- If a new commit is pushed to the branch before the jobs complete, only `job1`is canceled.\n\n* * *",
					"tokensEstimate": 235,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_18",
					"content": "##### `workflow:auto_cancel:on_job_failure`\n\nUse `workflow:auto_cancel:on_job_failure` to configure which jobs should be canceled as soon as one job fails.\n\n**Supported values**:\n\n- `all`: Cancel the pipeline and all running jobs as soon as one job fails.- `none`: Do not auto-cancel any jobs.\n\n**Example of `workflow:auto_cancel:on_job_failure`**:\n\n```python\nstages: [stage_a, stage_b]\n\nworkflow:\nauto_cancel:\non_job_failure: all\n\njob1:\nstage: stage_a\nscript: sleep 60\n\njob2:\nstage: stage_a\nscript:\n - sleep 30\n - exit 1\n\njob3:\nstage: stage_b\nscript:\n - sleep 30\n```\n\nIn this example, if `job2` fails, `job1` is canceled if it is still running and `job3` does not start.\n\n**Related topics**:\n\n- [Auto-cancel the parent pipeline from a downstream pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#auto-cancel-the-parent-pipeline-from-a-downstream-pipeline)\n\n* * *",
					"tokensEstimate": 217,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_19",
					"content": "##### `workflow:name`\n\nYou can use `name` in `workflow:` to define a name for pipelines.\n\nAll pipelines are assigned the defined name. Any leading or trailing spaces in the name are removed.\n\n**Supported values**:\n\n- A string.- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).- A combination of both.\n\n**Examples of `workflow:name`**:\n\nA simple pipeline name with a predefined variable:\n\n```python\nworkflow:\nname: 'Pipeline for branch: $CI_COMMIT_BRANCH'\n```\n\nA configuration with different pipeline names depending on the pipeline conditions:\n\n```python\nvariables:\nPROJECT1_PIPELINE_NAME: 'Default pipeline name' # A default is not required\n\nworkflow:\nname: '$PROJECT1_PIPELINE_NAME'\nrules:\n - if: '$CI_MERGE_REQUEST_LABELS =~ /pipeline:run-in-ruby3/'\nvariables:\nPROJECT1_PIPELINE_NAME: 'Ruby 3 pipeline'\n - if: '$CI_PIPELINE_SOURCE == \"merge_request_event\"'\nvariables:\nPROJECT1_PIPELINE_NAME: 'MR pipeline: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME'\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH # For default branch pipelines, use the default name\n```\n\n**Additional details**:\n\n- If the name is an empty string, the pipeline is not assigned a name. A name consisting of only CI/CD variables could evaluate to an empty string if all the variables are also empty.- `workflow:rules:variables`become [default variables](https://docs.gitlab.com/ci/yaml/#default-variables)available in all jobs, including [trigger](https://docs.gitlab.com/ci/yaml/#trigger)jobs which forward variables to downstream pipelines by default. If the downstream pipeline uses the same variable, the [variable is overwritten](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence)by the upstream variable value. Be sure to either:\n - Use a unique variable name in every project’s pipeline configuration, like `PROJECT1_PIPELINE_NAME`.- Use [inherit:variables](https://docs.gitlab.com/ci/yaml/#inheritvariables)in the trigger job and list the exact variables you want to forward to the downstream pipeline.\n\n* * *",
					"tokensEstimate": 508,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_20",
					"content": "##### `workflow:rules`\n\nThe `rules` keyword in `workflow` is similar to [`rules` defined in jobs](https://docs.gitlab.com/ci/yaml/#rules), but controls whether or not a whole pipeline is created.\n\nWhen no rules evaluate to true, the pipeline does not run.\n\n**Supported values**: You can use some of the same keywords as job-level [`rules`](https://docs.gitlab.com/ci/yaml/#rules):\n\n- [rules: if](https://docs.gitlab.com/ci/yaml/#rulesif).- [rules: changes](https://docs.gitlab.com/ci/yaml/#ruleschanges).- [rules: exists](https://docs.gitlab.com/ci/yaml/#rulesexists).- [when](https://docs.gitlab.com/ci/yaml/#when), can only be `always`or `never`when used with `workflow`.- [variables](https://docs.gitlab.com/ci/yaml/#workflowrulesvariables).\n\n**Example of `workflow:rules`**:\n\n```python\nworkflow:\nrules:\n - if: $CI_COMMIT_TITLE =~ /-draft$/\nwhen: never\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n```\n\nIn this example, pipelines run if the commit title (first line of the commit message) does not end with `-draft` and the pipeline is for either:\n\n- A merge request- The default branch.\n\n**Additional details**:\n\n- If your rules match both branch pipelines (other than the default branch) and merge request pipelines, [duplicate pipelines](https://docs.gitlab.com/ci/jobs/job_rules/#avoid-duplicate-pipelines)can occur.- `start_in`, `allow_failure`, and `needs`are not supported in `workflow:rules`, but do not cause a syntax violation. Though they have no effect, do not use them in `workflow:rules`as it could cause syntax failures in the future. See [issue 436473](https://gitlab.com/gitlab-org/gitlab/-/issues/436473)for more details.\n\n**Related topics**:\n\n- [Common if clauses for workflow:rules](https://docs.gitlab.com/ci/yaml/workflow/#common-if-clauses-for-workflowrules).- [Use rules to run merge request pipelines](https://docs.gitlab.com/ci/pipelines/merge_request_pipelines/#configure-merge-request-pipelines).\n\n* * *",
					"tokensEstimate": 493,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_21",
					"content": "##### `workflow:rules:variables`\n\nYou can use [`variables`](https://docs.gitlab.com/ci/yaml/#variables) in `workflow:rules` to define variables for specific pipeline conditions.\n\nWhen the condition matches, the variable is created and can be used by all jobs in the pipeline. If the variable is already defined at the top level as a default variable, the `workflow` variable takes precedence and overrides the default variable.\n\n**Keyword type**: Global keyword.\n\n**Supported values**: Variable name and value pairs:\n\n- The name can use only numbers, letters, and underscores ( `_`).- The value must be a string.\n\n**Example of `workflow:rules:variables`**:\n\n```python\nvariables:\nDEPLOY_VARIABLE: \"default-deploy\"\n\nworkflow:\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nvariables:\nDEPLOY_VARIABLE: \"deploy-production\" # Override globally-defined DEPLOY_VARIABLE\n - if: $CI_COMMIT_BRANCH =~ /feature/\nvariables:\nIS_A_FEATURE: \"true\" # Define a new variable.\n - if: $CI_COMMIT_BRANCH # Run the pipeline in other cases\n\njob1:\nvariables:\nDEPLOY_VARIABLE: \"job1-default-deploy\"\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nvariables: # Override DEPLOY_VARIABLE defined\nDEPLOY_VARIABLE: \"job1-deploy-production\" # at the job level.\n - when: on_success # Run the job in other cases\nscript:\n - echo \"Run script with $DEPLOY_VARIABLE as an argument\"\n - echo \"Run another script if $IS_A_FEATURE exists\"\n\njob2:\nscript:\n - echo \"Run script with $DEPLOY_VARIABLE as an argument\"\n - echo \"Run another script if $IS_A_FEATURE exists\"\n```\n\nWhen the branch is the default branch:\n\n- job1’s `DEPLOY_VARIABLE`is `job1-deploy-production`.- job2’s `DEPLOY_VARIABLE`is `deploy-production`.\n\nWhen the branch is `feature`:\n\n- job1’s `DEPLOY_VARIABLE`is `job1-default-deploy`, and `IS_A_FEATURE`is `true`.- job2’s `DEPLOY_VARIABLE`is `default-deploy`, and `IS_A_FEATURE`is `true`.\n\nWhen the branch is something else:\n\n- job1’s `DEPLOY_VARIABLE`is `job1-default-deploy`.- job2’s `DEPLOY_VARIABLE`is `default-deploy`.\n\n**Additional details**:\n\n- `workflow:rules:variables`become [default variables](https://docs.gitlab.com/ci/yaml/#variables)available in all jobs, including [trigger](https://docs.gitlab.com/ci/yaml/#trigger)jobs which forward variables to downstream pipelines by default. If the downstream pipeline uses the same variable, the [variable is overwritten](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence)by the upstream variable value. Be sure to either:\n - Use unique variable names in every project’s pipeline configuration, like `PROJECT1_VARIABLE_NAME`.- Use [inherit:variables](https://docs.gitlab.com/ci/yaml/#inheritvariables)in the trigger job and list the exact variables you want to forward to the downstream pipeline.\n\n* * *",
					"tokensEstimate": 682,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_22",
					"content": "##### `workflow:rules:auto_cancel`\n\nUse `workflow:rules:auto_cancel` to configure the behavior of the [`workflow:auto_cancel:on_new_commit`](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit) or the [`workflow:auto_cancel:on_job_failure`](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_job_failure) features.\n\n**Supported values**:\n\n- `on_new_commit`: [workflow:auto_cancel:on_new_commit](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit)- `on_job_failure`: [workflow:auto_cancel:on_job_failure](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_job_failure)\n\n**Example of `workflow:rules:auto_cancel`**:\n\n```python\nworkflow:\nauto_cancel:\non_new_commit: interruptible\non_job_failure: all\nrules:\n - if: $CI_COMMIT_REF_PROTECTED == 'true'\nauto_cancel:\non_new_commit: none\non_job_failure: none\n - when: always # Run the pipeline in other cases\n\ntest-job1:\nscript: sleep 10\ninterruptible: false\n\ntest-job2:\nscript: sleep 10\ninterruptible: true\n```\n\nIn this example, [`workflow:auto_cancel:on_new_commit`](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit) is set to `interruptible` and [`workflow:auto_cancel:on_job_failure`](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_job_failure) is set to `all` for all jobs by default. But if a pipeline runs for a protected branch, the rule overrides the default with `on_new_commit: none` and `on_job_failure: none`. For example, if a pipeline is running for:\n\n- A non-protected branch and a new commit is pushed, `test-job1`continues to run and `test-job2`is canceled.- A protected branch and a new commit is pushed, both `test-job1`and `test-job2`continue to run.\n\n* * *\n\nSome keywords must be defined in a header section of a YAML configuration file. The header must be at the top of the file, separated from the rest of the configuration with `---`.\n\n* * *\n\n#### `spec`\n\nAdd a `spec` section to the header of a YAML file to configure the behavior of a pipeline when a configuration is added to the pipeline with the `include` keyword.\n\nSpecs must be declared at the top of a configuration file, in a header section separated from the rest of the configuration with `---`.\n\n* * *",
					"tokensEstimate": 544,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_23",
					"content": "##### `spec:inputs`\n\nYou can use `spec:inputs` to define [inputs](https://docs.gitlab.com/ci/inputs/) for the CI/CD configuration.\n\nUse the interpolation format `$[[ inputs.input-id ]]` to reference the values outside of the header section. Inputs are evaluated and interpolated when the configuration is fetched during pipeline creation. When using `inputs`, interpolation completes before the configuration is merged with the contents of the `.gitlab-ci.yml` file.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: A hash of strings representing the expected inputs.\n\n**Example of `spec:inputs`**:\n\n```python\nspec:\ninputs:\nenvironment:\njob-stage:\n---\n\nscan-website:\nstage: $[[ inputs.job-stage ]]\nscript: ./scan-website $[[ inputs.environment ]]\n```\n\n**Additional details**:\n\n- Inputs are mandatory unless you use [spec:inputs:default](https://docs.gitlab.com/ci/yaml/#specinputsdefault)to set a default value. Avoid mandatory inputs unless you only use inputs with [include:inputs](https://docs.gitlab.com/ci/yaml/#includeinputs).- Inputs expect strings unless you use [spec:inputs:type](https://docs.gitlab.com/ci/yaml/#specinputstype)to set a different input type.- A string containing an interpolation block must not exceed 1 MB.- The string inside an interpolation block must not exceed 1 KB.- You can define input values [when running a new pipeline](https://docs.gitlab.com/ci/inputs/#for-a-pipeline).\n\n**Related topics**:\n\n- [Define input parameters with spec:inputs](https://docs.gitlab.com/ci/inputs/#define-input-parameters-with-specinputs).\n\n* * *",
					"tokensEstimate": 410,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_24",
					"content": "###### `spec:inputs:default`\n\nInputs are mandatory when included, unless you set a default value with `spec:inputs:default`.\n\nUse `default: ''` to have no default value.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: A string representing the default value, or `''`.\n\n**Example of `spec:inputs:default`**:\n\n```python\nspec:\ninputs:\nwebsite:\nuser:\ndefault: 'test-user'\nflags:\ndefault: ''\n---",
					"tokensEstimate": 120,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_25",
					"content": "## The pipeline configuration would follow...\n\n```\n\nIn this example:\n\n- `website`is mandatory and must be defined.- `user`is optional. If not defined, the value is `test-user`.- `flags`is optional. If not defined, it has no value.\n\n**Additional details**:\n\n- The pipeline fails with a validation error when the input:\n - Uses both `default`and [options](https://docs.gitlab.com/ci/yaml/#specinputsoptions), but the default value is not one of the listed options.- Uses both `default`and `regex`, but the default value does not match the regular expression.- Value does not match the [type](https://docs.gitlab.com/ci/yaml/#specinputstype).\n\n* * *",
					"tokensEstimate": 160,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_26",
					"content": "###### `spec:inputs:description`\n\nUse `description` to give a description to a specific input. The description does not affect the behavior of the input and is only used to help users of the file understand the input.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: A string representing the description.\n\n**Example of `spec:inputs:description`**:\n\n```python\nspec:\ninputs:\nflags:\ndescription: 'Sample description of the `flags` input details.'\n---\n\n## The pipeline configuration would follow...\n\n```\n\n* * *",
					"tokensEstimate": 148,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_27",
					"content": "###### `spec:inputs:options`\n\nInputs can use `options` to specify a list of allowed values for an input. The limit is 50 options per input.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: An array of input options. Only string and number [`type`](https://docs.gitlab.com/ci/yaml/#specinputstype) inputs can be used with options.\n\n**Example of `spec:inputs:options`**:\n\n```python\nspec:\ninputs:\nenvironment:\noptions:\n - development\n - staging\n - production\n---",
					"tokensEstimate": 136,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_28",
					"content": "## The pipeline configuration would follow...\n\n```\n\nIn this example:\n\n- `environment`is mandatory and must be defined with one of the values in the list.\n\n**Additional details**:\n\n- The pipeline fails with a validation error when:\n - The input uses both `options`and [default](https://docs.gitlab.com/ci/yaml/#specinputsdefault), but the default value is not one of the listed options.- Any of the input options do not match the [type](https://docs.gitlab.com/ci/yaml/#specinputstype), which can be either `string`or `number`, but not `boolean`when using `options`.\n\n* * *\n\n###### `spec:inputs:regex`\n\nUse `spec:inputs:regex` to specify a regular expression that the input must match.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: Must be a regular expression.\n\n**Example of `spec:inputs:regex`**:\n\n```python\nspec:\ninputs:\nversion:\nregex: ^v\\d\\.\\d+(\\.\\d+)?$\n---",
					"tokensEstimate": 236,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_29",
					"content": "## The pipeline configuration would follow...\n\n```\n\nIn this example, inputs of `v1.0` or `v1.2.3` match the regular expression and pass validation. An input of `v1.A.B` does not match the regular expression and fails validation.\n\n**Additional details**:\n\n- `inputs:regex`can only be used with a [type](https://docs.gitlab.com/ci/yaml/#specinputstype)of `string`, not `number`or `boolean`.- Do not enclose the regular expression with the `/`character. For example, use `regex.*`, not `/regex.*/`.- `inputs:regex`uses [RE2](https://github.com/google/re2/wiki/Syntax)to parse regular expressions.- Validation of the input against the regular expression happens before variable expansion. If the input text includes a variable name, the raw value of the input (the variable name) is validated, not the variable value.\n\n* * *",
					"tokensEstimate": 204,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_30",
					"content": "###### `spec:inputs:rules`\n\nUse `spec:inputs:rules` to define conditional `options` and `default` values for an input based on the values of other inputs.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: An array of rule objects. Each rule can have:\n\n- `if`: A conditional expression to check input values, using [$[[ inputs.input-id ]] syntax](https://docs.gitlab.com/ci/inputs/#define-input-parameters-with-specinputs).- `options`: An array of allowed values for the input.- `default`: The default value for the input when this rule matches. Use [default: null](https://docs.gitlab.com/ci/inputs/#allow-user-entered-values-with-default-null)to allow users to enter their own value for the input.\n\n**Example of `spec:inputs:rules`**:\n\n```python\nspec:\ninputs:\nenvironment:\noptions: ['development', 'production']\ndefault: 'development'\n\ninstance_type:\ndescription: 'VM instance size'\nrules:\n - if: $[[ inputs.environment ]] == 'development'\noptions: ['small', 'medium']\ndefault: 'small'\n - if: $[[ inputs.environment ]] == 'production'\noptions: ['large', 'xlarge']\ndefault: 'large'\n---\n\ndeploy:\nscript: echo \"Deploying $[[ inputs.instance_type ]] instance\"\n```\n\nIn this example, when `environment` is `development`, users can only select `small` or `medium` instances. When `environment` is `production`, only `large` or `xlarge` instances are available.\n\n**Additional details**:\n\n- Rules are evaluated in order. The first rule with a matching `if`condition is used.- A rule without an `if`condition acts as a fallback when no other rules match.- Fallback rules must define `options`with at least one value.- All rules with `options`must also define a `default`value that exists in the `options`list.- You cannot use both `rules`and top-level `options`or `default`for the same input.\n\n**Related topics**:\n\n- [Define conditional input options with spec:inputs:rules](https://docs.gitlab.com/ci/inputs/#define-conditional-input-options-with-specinputsrules).\n\n* * *",
					"tokensEstimate": 510,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_31",
					"content": "###### `spec:inputs:type`\n\nBy default, inputs expect strings. Use `spec:inputs:type` to set a different required type for inputs.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: Can be one of:\n\n- `array`, to accept an [array](https://docs.gitlab.com/ci/inputs/#array-type)of inputs.- `string`, to accept string inputs (default when not defined).- `number`, to only accept numeric inputs.- `boolean`, to only accept `true`or `false`inputs.\n\n**Example of `spec:inputs:type`**:\n\n```python\nspec:\ninputs:\njob_name:\nwebsite:\ntype: string\nport:\ntype: number\navailable:\ntype: boolean\narray_input:\ntype: array\n---\n\n## The pipeline configuration would follow...\n\n```\n\n* * *",
					"tokensEstimate": 187,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_32",
					"content": "##### `spec:include`\n\nUse `spec:include` to include external input definitions from other files. You can share and reuse input definitions across multiple pipeline configurations.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: An array of include locations. Supports `local`, `remote`, and `project` includes only.\n\n**Example of `spec:include`**:\n\n```python\nspec:\ninclude:\n - local: /shared-inputs.yml\ninputs:\nenvironment:\ndefault: production\n---\n\ndeploy:\nscript: echo \"Deploying to $[[ inputs.environment ]]\"\n```\n\nWith multiple includes from different sources:\n\n```python\nspec:\ninclude:\n - local: /base-inputs.yml\n - remote: 'https://example.com/ci/common-inputs.yml'\n - project: 'my-group/shared-configs'\nref: main\nfile: '/ci/team-inputs.yml'\ninputs:\nenvironment:\ndefault: production\n---\n\ndeploy:\nscript: echo \"Deploying to $[[ inputs.environment ]]\"\n```\n\n**Additional details**:\n\n- You cannot use `spec:include`in [CI/CD components](https://docs.gitlab.com/ci/components/#component-spec-section).- External input files must contain only the `inputs`key. Other keys cause validation errors.- External inputs are merged first, then inline inputs are applied.- Inline inputs take precedence over external inputs with the same name.- When you include multiple input files, they are merged in the order specified.- Supports [local](https://docs.gitlab.com/ci/yaml/#includelocal), [remote](https://docs.gitlab.com/ci/yaml/#includeremote), and [project](https://docs.gitlab.com/ci/yaml/#includeproject)include types. Does not support `template`, `component`, or `artifact`includes.\n\n**Related topics**:\n\n- [Use inputs from external files](https://docs.gitlab.com/ci/inputs/#use-inputs-from-external-files).\n\n* * *",
					"tokensEstimate": 447,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_33",
					"content": "##### `spec:component`\n\nUse `spec:component` to define which component context data is available for interpolation in a [CI/CD component](https://docs.gitlab.com/ci/components/).\n\nComponent context provides metadata about the component itself, such as its name, version, and the commit SHA. This allows component templates to reference their own metadata dynamically.\n\nUse the interpolation format `$[[ component.field-name ]]` to reference component context values in the component template.\n\n**Keyword type**: Header keyword. `spec` must be declared at the top of the configuration file, in a header section.\n\n**Supported values**: An array of strings. Each string must be one of:\n\n- `name`: The component name as specified in the component path.- `sha`: The commit SHA of the component.- `version`: The resolved semantic version from the catalog resource. Returns `null`if:\n - The component is not a catalog resource.- The reference is a branch name or commit SHA (not a released version).- `reference`: The original reference specified after `@`in the component path. For example, `1.0`, `~latest`, a branch name, or a commit SHA.\n\n**Example of `spec:component`**:\n\n```python\nspec:\ncomponent: [name, version, reference]\ninputs:\nimage_tag:\ndefault: latest\n---\n\nbuild-image:\nimage: registry.example.com/$[[ component.name ]]:$[[ component.version ]]\nscript:\n - echo \"Building with component version $[[ component.version ]]\"\n - echo \"Component reference: $[[ component.reference ]]\"\n```\n\n**Additional details**:\n\n- The `version`field resolves to the actual semantic version when using:\n - A full version like `@1.0.0`(returns `1.0.0`)- A partial version like `@1.0`(returns the latest matching version, for example `1.0.2`)- `@~latest`(returns the latest version)- The `reference`field always returns the exact value specified after `@`:\n - `@1.0`returns `1.0`(while `version`might return `1.0.2`)- `@~latest`returns `~latest`(while `version`returns the actual version number)- `@abc123`returns `abc123`(while `version`returns `null`)\n\n**Related topics**:\n\n- [Use component context in components](https://docs.gitlab.com/ci/components/#use-component-context-in-components).\n\n* * *\n\n### Job keywords\n\nThe following topics explain how to use keywords to configure CI/CD pipelines.\n\n* * *",
					"tokensEstimate": 567,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_34",
					"content": "#### `after_script`\n\n\n\nUse `after_script` to define an array of commands to run last, after a job’s `before_script` and `script` sections complete. `after_script` commands also run when:\n\n- The job is canceled while the `before_script`or `script`sections are still running.- The job fails with failure type of `script_failure`, but not [other failure types](https://docs.gitlab.com/ci/yaml/#retrywhen).\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:after_script`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `after_script`, the job configuration takes precedence and the default configuration is not used.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: An array including:\n\n- Single line commands.- Long commands [split over multiple lines](https://docs.gitlab.com/ci/yaml/script/#split-long-commands).- [YAML anchors](https://docs.gitlab.com/ci/yaml/yaml_optimization/#yaml-anchors-for-scripts).\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `after_script`**:\n\n```python\njob:\nscript:\n - echo \"An example script section.\"\nafter_script:\n - echo \"Execute this command after the `script` section completes.\"\n```\n\n**Additional details**:\n\nScripts you specify in `after_script` execute in a new shell, separate from any `before_script` or `script` commands. As a result, they:",
					"tokensEstimate": 386,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_35",
					"content": "- Have the current working directory set back to the default (according to the [variables which define how the runner processes Git requests](https://docs.gitlab.com/ci/runners/configure_runners/#configure-runner-behavior-with-variables)).- Don’t have access to changes done by commands defined in the `before_script`or `script`, including:\n - Command aliases and variables exported in `script`scripts.- Changes outside of the working tree (depending on the runner executor), like software installed by a `before_script`or `script`script.- Have a separate timeout. For GitLab Runner 16.4 and later, this defaults to 5 minutes, and can be configured with the [RUNNER_AFTER_SCRIPT_TIMEOUT](https://docs.gitlab.com/ci/runners/configure_runners/#set-script-and-after_script-timeouts)variable. In GitLab 16.3 and earlier, the timeout is hard-coded to 5 minutes.- Don’t affect the job’s exit code. If the `script`section succeeds and the `after_script`times out or fails, the job exits with code `0`( `Job Succeeded`).- There is a known issue with using [CI/CD job tokens](https://docs.gitlab.com/ci/jobs/ci_job_token/)with `after_script`. You can use a job token for authentication in `after_script`commands, but the token immediately becomes invalid if the job is canceled. See [issue](https://gitlab.com/gitlab-org/gitlab/-/issues/473376)for more details.- For jobs that time out:\n - `after_script`commands do not execute by default.- You can [configure timeout values](https://docs.gitlab.com/ci/runners/configure_runners/#ensuring-after_script-execution)to ensure `after_script`runs by setting appropriate `RUNNER_SCRIPT_TIMEOUT`and `RUNNER_AFTER_SCRIPT_TIMEOUT`values that don’t exceed the job’s timeout.- Using `after_script`at the top level, but not in the `default`section, is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#globally-defined-image-services-cache-before_script-after_script).\n\n**Execution timing and file inclusion**:\n\n`after_script` commands execute before cache and artifact upload operations.",
					"tokensEstimate": 507,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_36",
					"content": "- If you configured artifact collection:\n - Files created or modified in `after_script`are included in artifacts.- Changes made in `after_script`are included in cache uploads.- Any files that `after_script`creates or modifies in the specified cache or artifact paths are captured and uploaded. You can use this timing for scenarios like:\n - Generating test reports or coverage data after the main script.- Creating summary files or logs.- Post-processing build outputs.\n\nIn the following example, the only files that are not included are those created or modified after the artifact or cache upload stages:\n\n```python\njob:\nscript:\n - echo \"main\" > output.txt\n - build_something\n\nafter_script:\n - echo \"modified in after_script\" >> output.txt # This WILL be in the artifact\n - generate_test_report > report.html # This WILL be in the artifact\n\nartifacts:\npaths:\n - output.txt\n - report.html\n\ncache:\npaths:\n - output.txt # Will include the \"modified in after_script\" line\n```\n\nFor more information, see [job execution flow](https://docs.gitlab.com/ci/jobs/job_execution/).\n\n**Related topics**:\n\n- [Use after_script with default](https://docs.gitlab.com/ci/yaml/script/#set-a-default-before_script-or-after_script-for-all-jobs)to define a default array of commands that should run after all jobs.- You can configure a job to [skip after_script commands if the job is canceled](https://docs.gitlab.com/ci/yaml/script/#skip-after_script-commands-if-a-job-is-canceled).- You can [ignore non-zero exit codes](https://docs.gitlab.com/ci/yaml/script/#ignore-non-zero-exit-codes).- [Use color codes with after_script](https://docs.gitlab.com/ci/yaml/script/#add-color-codes-to-script-output)to make job logs easier to review.- [Create custom collapsible sections](https://docs.gitlab.com/ci/jobs/job_logs/#custom-collapsible-sections)to simplify job log output.- You can [ignore errors in after_script](https://docs.gitlab.com/ci/runners/configure_runners/#ignore-errors-in-after_script).\n\n* * *",
					"tokensEstimate": 492,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_37",
					"content": "#### `allow_failure`\n\nUse `allow_failure` to determine whether a pipeline should continue running when a job fails.\n\n- To let the pipeline continue running subsequent jobs, use `allow_failure: true`.- To stop the pipeline from running subsequent jobs, use `allow_failure: false`.\n\nWhen jobs are allowed to fail (`allow_failure: true`) an orange warning ( status\\_warning ) indicates that a job failed. However, the pipeline is successful and the associated commit is marked as passed with no warnings.\n\nThis same warning is displayed when:\n\n- All other jobs in the stage are successful.- All other jobs in the pipeline are successful.\n\nThe default value for `allow_failure` is:\n\n- `true`for [manual jobs](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually).- `false`for jobs that use `when: manual`inside [rules](https://docs.gitlab.com/ci/yaml/#rules).- `false`in all other cases.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`or `false`.\n\n**Example of `allow_failure`**:\n\n```python\njob1:\nstage: test\nscript:\n - execute_script_1\n\njob2:\nstage: test\nscript:\n - execute_script_2\nallow_failure: true\n\njob3:\nstage: deploy\nscript:\n - deploy_to_staging\nenvironment: staging\n```\n\nIn this example, `job1` and `job2` run in parallel:\n\n- If `job1`fails, jobs in the `deploy`stage do not start.- If `job2`fails, jobs in the `deploy`stage can still start.\n\n**Additional details**:\n\n- You can use `allow_failure`as a subkey of [rules](https://docs.gitlab.com/ci/yaml/#rulesallow_failure).- If `allow_failure: true`is set, the job is always considered successful, and later jobs with [when: on_failure](https://docs.gitlab.com/ci/yaml/#when)don’t start if this job fails.- You can use `allow_failure: false`with a manual job to create a [blocking manual job](https://docs.gitlab.com/ci/jobs/job_control/#types-of-manual-jobs). A blocked pipeline does not run any jobs in later stages until the manual job is started and completes successfully.\n\n* * *",
					"tokensEstimate": 501,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_38",
					"content": "##### `allow_failure:exit_codes`\n\nUse `allow_failure:exit_codes` to control when a job should be allowed to fail. The job is `allow_failure: true` for any of the listed exit codes, and `allow_failure` false for any other exit code.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A single exit code.- An array of exit codes.\n\n**Example of `allow_failure`**:\n\n```python\ntest_job_1:\nscript:\n - echo \"Run a script that results in exit code 1. This job fails.\"\n - exit 1\nallow_failure:\nexit_codes: 137\n\ntest_job_2:\nscript:\n - echo \"Run a script that results in exit code 137. This job is allowed to fail.\"\n - exit 137\nallow_failure:\nexit_codes:\n - 137\n - 255\n```\n\n* * *",
					"tokensEstimate": 175,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_39",
					"content": "#### `artifacts`\n\nUse `artifacts` to specify which files to save as [job artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/). Job artifacts are a list of files and directories that are attached to the job when it [succeeds, fails, or always](https://docs.gitlab.com/ci/yaml/#artifactswhen).\n\nThe artifacts are sent to GitLab after the job finishes. They are available for download in the GitLab UI if the size is smaller than the [maximum artifact size](https://docs.gitlab.com/user/gitlab_com/#cicd).\n\nBy default, jobs in later stages automatically download all the artifacts created by jobs in earlier stages. You can control artifact download behavior in jobs with [`dependencies`](https://docs.gitlab.com/ci/yaml/#dependencies).\n\nWhen using the [`needs`](https://docs.gitlab.com/ci/yaml/#needs) keyword, jobs can only download artifacts from the jobs defined in the `needs` configuration.\n\nJob artifacts are only collected for successful jobs by default, and artifacts are restored after [caches](https://docs.gitlab.com/ci/yaml/#cache).\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:artifacts`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `artifacts`, the job configuration takes precedence and the default configuration is not used.\n\n[Read more about artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/).\n\n* * *",
					"tokensEstimate": 351,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_40",
					"content": "##### `artifacts:paths`\n\nPaths are relative to the project directory (`$CI_PROJECT_DIR`) and can’t directly link outside it.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of file paths, relative to the project directory.- You can use Wildcards that use [glob](https://en.wikipedia.org/wiki/Glob_%28programming%29)patterns and [doublestar.Glob](https://pkg.go.dev/github.com/bmatcuk/doublestar@v1.2.2?tab=doc#Match)patterns.- For [GitLab Pages job](https://docs.gitlab.com/ci/yaml/#pages):\n - In [GitLab 17.10 and later](https://gitlab.com/gitlab-org/gitlab/-/issues/428018), the [pages.publish](https://docs.gitlab.com/ci/yaml/#pagespublish)path is automatically appended to `artifacts:paths`, so you don’t need to specify it again.- In [GitLab 17.10 and later](https://gitlab.com/gitlab-org/gitlab/-/issues/428018), when the [pages.publish](https://docs.gitlab.com/ci/yaml/#pagespublish)path is not specified, the `public`directory is automatically appended to `artifacts:paths`.\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `artifacts:paths`**:\n\n```python\njob:\nartifacts:\npaths:\n - binaries/\n - .config\n```\n\nThis example creates an artifact with `.config` and all the files in the `binaries` directory.\n\n**Additional details**:\n\n- If not used with [artifacts:name](https://docs.gitlab.com/ci/yaml/#artifactsname), the artifacts file is named `artifacts`, which becomes `artifacts.zip`when downloaded.\n\n**Related topics**:\n\n- To restrict which jobs a specific job fetches artifacts from, see [dependencies](https://docs.gitlab.com/ci/yaml/#dependencies).- [Create job artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/#create-job-artifacts).\n\n* * *",
					"tokensEstimate": 465,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_41",
					"content": "##### `artifacts:exclude`\n\nUse `artifacts:exclude` to prevent files from being added to an artifacts archive.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of file paths, relative to the project directory.- You can use Wildcards that use [glob](https://en.wikipedia.org/wiki/Glob_%28programming%29)or [doublestar.PathMatch](https://pkg.go.dev/github.com/bmatcuk/doublestar@v1.2.2?tab=doc#PathMatch)patterns.\n\n**Example of `artifacts:exclude`**:\n\n```python\nartifacts:\npaths:\n - binaries/\nexclude:\n - binaries/**/*.o\n```\n\nThis example stores all files in `binaries/`, but not `*.o` files located in subdirectories of `binaries/`.\n\n**Additional details**:\n\n- `artifacts:exclude`paths are not searched recursively.- Files matched by [artifacts:untracked](https://docs.gitlab.com/ci/yaml/#artifactsuntracked)can be excluded using `artifacts:exclude`too.\n\n**Related topics**:\n\n- [Exclude files from job artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/#without-excluded-files).\n\n* * *",
					"tokensEstimate": 276,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_42",
					"content": "##### `artifacts:expire_in`\n\nUse `expire_in` to specify how long [job artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/) are stored before they expire and are deleted. The `expire_in` setting does not affect:\n\n- Artifacts from the latest job, unless keeping the latest job artifacts is disabled [at the project level](https://docs.gitlab.com/ci/jobs/job_artifacts/#keep-artifacts-from-most-recent-successful-jobs)or [instance-wide](https://docs.gitlab.com/administration/settings/continuous_integration/#keep-artifacts-from-latest-successful-pipelines).\n\nAfter their expiry, artifacts are deleted hourly by default (using a cron job), and are not accessible anymore.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: The expiry time. If no unit is provided, the time is in seconds. Valid values include:\n\n- `'42'`- `42 seconds`- `3 mins 4 sec`- `2 hrs 20 min`- `2h20min`- `6 mos 1 day`- `47 yrs 6 mos and 4d`- `3 weeks and 2 days`- `never`\n\n**Example of `artifacts:expire_in`**:\n\n```python\njob:\nartifacts:\nexpire_in: 1 week\n```\n\n**Additional details**:\n\n- The expiration time period begins when the artifact is uploaded and stored on GitLab. If the expiry time is not defined, it defaults to the [instance wide setting](https://docs.gitlab.com/administration/settings/continuous_integration/#set-default-artifacts-expiration).- To override the expiration date and protect artifacts from being automatically deleted:\n - Select **Keep**on the job page.- Set the value of `expire_in`to `never`.- If the expiry time is too short, jobs in later stages of a long pipeline might try to fetch expired artifacts from earlier jobs. If the artifacts are expired, jobs that try to fetch them fail with a [could not retrieve the needed artifacts error](https://docs.gitlab.com/ci/jobs/job_artifacts_troubleshooting/#error-message-this-job-could-not-start-because-it-could-not-retrieve-the-needed-artifacts). Set the expiry time to be longer, or use [dependencies](https://docs.gitlab.com/ci/yaml/#dependencies)in later jobs to ensure they don’t try to fetch expired artifacts.- `artifacts:expire_in`doesn’t affect GitLab Pages deployments. To configure Pages deployments’ expiry, use [pages.expire_in](https://docs.gitlab.com/ci/yaml/#pagesexpire_in).\n\n* * *",
					"tokensEstimate": 589,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_43",
					"content": "##### `artifacts:expose_as`\n\nUse the `artifacts:expose_as` keyword to [expose artifacts in the merge request UI](https://docs.gitlab.com/ci/jobs/job_artifacts/#link-to-job-artifacts-in-the-merge-request-ui).\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- The name to display in the merge request UI for the artifacts download link. Must be combined with [artifacts:paths](https://docs.gitlab.com/ci/yaml/#artifactspaths).\n\n**Example of `artifacts:expose_as`**:\n\n```python\ntest:\nscript: [\"echo 'test' > file.txt\"]\nartifacts:\nexpose_as: 'artifact 1'\npaths: ['file.txt']\n```\n\n**Additional details**:\n\n- You can use `expose_as`only once per job, with a maximum of 10 jobs per merge request.- Glob patterns are not supported.- Artifacts are always sent to GitLab. They are displayed in the UI unless `artifacts:paths`values:\n - Use [CI/CD variables](https://docs.gitlab.com/ci/variables/).- Define a directory, but do not end with `/`. For example, `directory/`works with `artifacts:expose_as`, but `directory`does not.- If `artifacts:paths`only includes a single file, the link opens the file directly. In all other cases, the link opens the [artifacts browser](https://docs.gitlab.com/ci/jobs/job_artifacts/#download-job-artifacts).- Linked files are downloaded by default. If [GitLab Pages](https://docs.gitlab.com/administration/pages/)is enabled, you can preview some artifacts file extensions directly in your browser. See [Browse the contents of the artifacts archive](https://docs.gitlab.com/ci/jobs/job_artifacts/#browse-the-contents-of-the-artifacts-archive)for details.\n\n**Related topics**:\n\n- [Expose job artifacts in the merge request UI](https://docs.gitlab.com/ci/jobs/job_artifacts/#link-to-job-artifacts-in-the-merge-request-ui).\n\n* * *",
					"tokensEstimate": 465,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_44",
					"content": "##### `artifacts:name`\n\nUse the `artifacts:name` keyword to define the name of the created artifacts archive. You can specify a unique name for every archive.\n\nIf not defined, the default name is `artifacts`, which becomes `artifacts.zip` when downloaded.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- The name of the artifacts archive. CI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file). Must be combined with [artifacts:paths](https://docs.gitlab.com/ci/yaml/#artifactspaths).\n\n**Example of `artifacts:name`**:\n\nTo create an archive with a name of the current job:\n\n```python\njob:\nartifacts:\nname: \"job1-artifacts-file\"\npaths:\n - binaries/\n```\n\n**Related topics**:\n\n- [Use CI/CD variables to define the artifacts configuration](https://docs.gitlab.com/ci/jobs/job_artifacts/#with-variable-expansion)\n\n* * *",
					"tokensEstimate": 246,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_45",
					"content": "##### `artifacts:public`\n\nUse `artifacts:public` to control whether job artifacts in public pipelines are available for download with the GitLab UI and API by anonymous users, or Guest and Reporter roles.\n\nThis option only affects GitLab UI and API access. CI/CD jobs using job tokens could still access artifacts with the runner API, regardless of this setting. To restrict job token access, configure your project’s [CI/CD visibility settings](https://docs.gitlab.com/user/project/settings/#configure-project-features-and-permissions) to **Only project members**.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `true`(default): Artifacts in a job in public pipelines are available for download by anyone, including anonymous users, or Guest and Reporter roles.- `false`: Artifacts in the job are only available for download by users with at least the Developer role.\n\n**Example of `artifacts:public`**:\n\n```python\njob:\nartifacts:\npublic: false\n```\n\n* * *",
					"tokensEstimate": 268,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_46",
					"content": "##### `artifacts:access`\n\nUse `artifacts:access` to determine who can access the job artifacts from the GitLab UI or API. This option does not prevent you from forwarding artifacts to downstream pipelines.\n\nYou cannot use [`artifacts:public`](https://docs.gitlab.com/ci/yaml/#artifactspublic) and `artifacts:access` in the same job.\n\nThis option only affects GitLab UI and API access. CI/CD jobs using job tokens could still access artifacts with the runner API, regardless of this setting. To restrict job token access, configure your project’s [CI/CD visibility settings](https://docs.gitlab.com/user/project/settings/#configure-project-features-and-permissions) to **Only project members**.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `all`(default): Artifacts in a job in public pipelines are available for download by anyone, including anonymous, guest, and reporter users.- `developer`: Artifacts in the job are only available for download by users with at least the Developer role.- `maintainer`: Artifacts in the job are only available for download by users with at least the Maintainer role.- `none`: Artifacts in the job are not available for download by anyone.\n\n**Example of `artifacts:access`**:\n\n```python\njob:\nartifacts:\naccess: 'developer'\n```\n\n**Additional details**:\n\n- `artifacts:access`affects all [artifacts:reports](https://docs.gitlab.com/ci/yaml/#artifactsreports)too, so you can also restrict access to [artifacts for reports](https://docs.gitlab.com/ci/yaml/artifacts_reports/).\n\n* * *",
					"tokensEstimate": 388,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_47",
					"content": "##### `artifacts:reports`\n\nUse [`artifacts:reports`](https://docs.gitlab.com/ci/yaml/artifacts_reports/) to collect artifacts generated by included templates in jobs.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- See list of available [artifacts reports types](https://docs.gitlab.com/ci/yaml/artifacts_reports/).\n\n**Example of `artifacts:reports`**:\n\n```python\nrspec:\nstage: test\nscript:\n - bundle install\n - rspec --format RspecJunitFormatter --out rspec.xml\nartifacts:\nreports:\njunit: rspec.xml\n```\n\n**Additional details**:\n\n- Combining reports in parent pipelines using [artifacts from child pipelines](https://docs.gitlab.com/ci/yaml/#needspipelinejob)is not supported. Track progress on adding support in [this issue](https://gitlab.com/gitlab-org/gitlab/-/issues/215725).- To be able to browse and download the report output files, include the [artifacts:paths](https://docs.gitlab.com/ci/yaml/#artifactspaths)keyword. This uploads and stores the artifact twice.- Artifacts created for `artifacts: reports`are always uploaded, regardless of the job results (success or failure). You can use [artifacts:expire_in](https://docs.gitlab.com/ci/yaml/#artifactsexpire_in)to set an expiration date for the artifacts.\n\n* * *",
					"tokensEstimate": 334,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_48",
					"content": "##### `artifacts:untracked`\n\nUse `artifacts:untracked` to add all Git untracked files as artifacts (along with the paths defined in `artifacts:paths`). `artifacts:untracked` ignores configuration in the repository’s `.gitignore`, so matching artifacts in `.gitignore` are included.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `true`or `false`(default if not defined).\n\n**Example of `artifacts:untracked`**:\n\nSave all Git untracked files:\n\n```python\njob:\nartifacts:\nuntracked: true\n```\n\n**Related topics**:\n\n- [Add untracked files to artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/#with-untracked-files).\n\n* * *",
					"tokensEstimate": 184,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_49",
					"content": "##### `artifacts:when`\n\nUse `artifacts:when` to upload artifacts on job failure or despite the failure.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `on_success`(default): Upload artifacts only when the job succeeds.- `on_failure`: Upload artifacts only when the job fails.- `always`: Always upload artifacts (except when jobs time out). For example, when [uploading artifacts](https://docs.gitlab.com/ci/testing/unit_test_reports/#add-screenshots-to-test-reports)required to troubleshoot failing tests.\n\n**Example of `artifacts:when`**:\n\n```python\njob:\nartifacts:\nwhen: on_failure\n```\n\n**Additional details**:\n\n- The artifacts created for [artifacts:reports](https://docs.gitlab.com/ci/yaml/#artifactsreports)are always uploaded, regardless of the job results (success or failure). `artifacts:when`does not change this behavior.\n\n* * *",
					"tokensEstimate": 238,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_50",
					"content": "#### `before_script`\n\nUse `before_script` to define an array of commands that should run before each job’s `script` commands, but after [artifacts](https://docs.gitlab.com/ci/yaml/#artifacts) are restored.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: An array including:\n\n- Single line commands.- Long commands [split over multiple lines](https://docs.gitlab.com/ci/yaml/script/#split-long-commands).- [YAML anchors](https://docs.gitlab.com/ci/yaml/yaml_optimization/#yaml-anchors-for-scripts).\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `before_script`**:\n\n```python\njob:\nbefore_script:\n - echo \"Execute this command before any 'script:' commands.\"\nscript:\n - echo \"This command executes after the job's 'before_script' commands.\"\n```\n\n**Additional details**:\n\n- Scripts you specify in `before_script`are concatenated with any scripts you specify in the main [script](https://docs.gitlab.com/ci/yaml/#script). The combined scripts execute together in a single shell.- Using `before_script`at the top level, but not in the `default`section, [is deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#globally-defined-image-services-cache-before_script-after_script).\n\n**Related topics**:\n\n- [Use before_script with default](https://docs.gitlab.com/ci/yaml/script/#set-a-default-before_script-or-after_script-for-all-jobs)to define a default array of commands that should run before the `script`commands in all jobs.\n - Job configuration and default configuration does not merge together. If the pipeline has [default:before_script](https://docs.gitlab.com/ci/yaml/#default)defined, and the job also has `before_script`, the job configuration takes precedence and the default configuration is not used.- You can [ignore non-zero exit codes](https://docs.gitlab.com/ci/yaml/script/#ignore-non-zero-exit-codes).- [Use color codes with before_script](https://docs.gitlab.com/ci/yaml/script/#add-color-codes-to-script-output)to make job logs easier to review.- [Create custom collapsible sections](https://docs.gitlab.com/ci/jobs/job_logs/#custom-collapsible-sections)to simplify job log output.\n\n* * *",
					"tokensEstimate": 576,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_51",
					"content": "#### `cache`\n\nUse `cache` to specify a list of files and directories to cache between jobs. You can only use paths that are in the local working copy.\n\nCaches are:\n\n- Shared between pipelines and jobs.- By default, not shared between [protected](https://docs.gitlab.com/user/project/repository/branches/protected/)and unprotected branches.- Restored before [artifacts](https://docs.gitlab.com/ci/yaml/#artifacts).- Limited to a maximum of four [different caches](https://docs.gitlab.com/ci/caching/#use-multiple-caches).\n\nYou can [disable caching for specific jobs](https://docs.gitlab.com/ci/caching/#disable-cache-for-specific-jobs), for example to override:\n\n- A default cache defined with [default](https://docs.gitlab.com/ci/yaml/#default).- The configuration for a job added with [include](https://docs.gitlab.com/ci/yaml/#include).\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:cache`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `cache`, the job configuration takes precedence and the default configuration is not used.\n\nFor more information about caches, see [Caching in GitLab CI/CD](https://docs.gitlab.com/ci/caching/).\n\nUsing `cache` at the top level, but not in the `default` section, is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#globally-defined-image-services-cache-before_script-after_script).\n\n* * *",
					"tokensEstimate": 354,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_52",
					"content": "##### `cache:paths`\n\nUse the `cache:paths` keyword to choose which files or directories to cache.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of paths relative to the project directory ( `$CI_PROJECT_DIR`). You can use wildcards that use [glob](https://en.wikipedia.org/wiki/Glob_%28programming%29)and [doublestar.Glob](https://pkg.go.dev/github.com/bmatcuk/doublestar@v1.2.2?tab=doc#Match)patterns.\n\n[CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file) are supported.\n\n**Example of `cache:paths`**:\n\nCache all files in `binaries` that end in `.apk` and the `.config` file:\n\n```python\nrspec:\nscript:\n - echo \"This job uses a cache.\"\ncache:\nkey: binaries-cache\npaths:\n - binaries/*.apk\n - .config\n```\n\n**Additional details**:\n\n- The `cache:paths`keyword includes files even if they are untracked or in your `.gitignore`file.\n\n**Related topics**:\n\n- See the [CI/CD caching examples](https://docs.gitlab.com/ci/caching/examples/)for more `cache:paths`examples.\n\n* * *",
					"tokensEstimate": 283,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_53",
					"content": "##### `cache:key`\n\nUse the `cache:key` keyword to give each cache a unique identifying key. All jobs that use the same cache key use the same cache, including in different pipelines.\n\nIf not set, the default key is `default`. All jobs with the `cache` keyword but no `cache:key` share the `default` cache.\n\nMust be used with `cache: paths`, or nothing is cached.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A string.- A predefined [CI/CD variable](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).- A combination of both.\n\n**Example of `cache:key`**:\n\n```python\ncache-job:\nscript:\n - echo \"This job uses a cache.\"\ncache:\nkey: binaries-cache-$CI_COMMIT_REF_SLUG\npaths:\n - binaries/\n```\n\n**Additional details**:\n\n- If you use **Windows Batch** to run your shell scripts you must replace `$` with `%`. For example: `key: %CI_COMMIT_REF_SLUG%`- The `cache:key` value can’t contain:\n - The `/`character, or the equivalent URI-encoded `%2F`.- Only the `.`character (any number), or the equivalent URI-encoded `%2E`.- The cache is shared between jobs, so if you’re using different paths for different jobs, you should also set a different `cache:key`. Otherwise cache content can be overwritten.\n\n**Related topics**:\n\n- You can specify a [fallback cache key](https://docs.gitlab.com/ci/caching/#use-a-fallback-cache-key)to use if the specified `cache:key`is not found.- You can [use multiple cache keys](https://docs.gitlab.com/ci/caching/#use-multiple-caches)in a single job.- See the [CI/CD caching examples](https://docs.gitlab.com/ci/caching/examples/)for more `cache:key`examples.\n\n* * *",
					"tokensEstimate": 433,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_54",
					"content": "###### `cache:key:files`\n\nUse `cache:key:files` to generate a new cache key when the content of the specified files change. If the content remains unchanged, the cache key remains consistent across branches and pipelines. You can reuse caches and rebuild them less often, which speeds up subsequent pipeline runs.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of up to two file paths or patterns.\n\nCI/CD variables are not supported.\n\n**Example of `cache:key:files`**:\n\n```python\ncache-job:\nscript:\n - echo \"This job uses a cache.\"\ncache:\nkey:\nfiles:\n - Gemfile.lock\n - package.json\npaths:\n - vendor/ruby\n - node_modules\n```\n\nThis example creates a cache for Ruby and Node.js dependencies. The cache is tied to the current versions of the `Gemfile.lock` and `package.json` files. When one of these files changes, a new cache key is computed and a new cache is created. Any future job runs that use the same `Gemfile.lock` and `package.json` with `cache:key:files` use the new cache, instead of rebuilding the dependencies.\n\n**Additional details**:\n\n- The cache `key`is a SHA computed from the content of the listed files. If a file doesn’t exist, it’s ignored in the key calculation. If none of the specified files exist, the fallback key is `default`.- Wildcard patterns like `**/package.json`can be used. An [issue](https://gitlab.com/gitlab-org/gitlab/-/issues/301161)exists to increase the number of paths or patterns allowed for a cache key.\n\n* * *",
					"tokensEstimate": 392,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_55",
					"content": "###### `cache:key:files_commits`\n\nUse `cache:key:files_commits` to generate a new cache key when the latest commit changes for the specified files. `cache:key:files_commits` cache keys change whenever the specified files have a new commit, even if the file content remains identical.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of up to two file paths or patterns.\n\n**Example of `cache:key:files_commits`**:\n\n```python\ncache-job:\nscript:\n - echo \"This job uses a commit-based cache.\"\ncache:\nkey:\nfiles_commits:\n - package.json\n - yarn.lock\npaths:\n - node_modules\n```\n\nThis example creates a cache based on the commit history of `package.json` and `yarn.lock`. If the commit history changes for these files, a new cache key is computed and a new cache is created.\n\n**Additional details**:\n\n- The cache `key`is a SHA computed from the most recent commit for each specified file.- If a file doesn’t exist, it’s ignored in the key calculation.- If none of the specified files exist, the fallback key is `default`.- Cannot be used together with [cache:key:files](https://docs.gitlab.com/ci/yaml/#cachekeyfiles)in the same cache configuration.\n\n* * *",
					"tokensEstimate": 316,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_56",
					"content": "###### `cache:key:prefix`\n\nUse `cache:key:prefix` to combine a prefix with the SHA computed for [`cache:key:files`](https://docs.gitlab.com/ci/yaml/#cachekeyfiles).\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A string.- A predefined [CI/CD variable](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).- A combination of both.\n\n**Example of `cache:key:prefix`**:\n\n```python\nrspec:\nscript:\n - echo \"This rspec job uses a cache.\"\ncache:\nkey:\nfiles:\n - Gemfile.lock\nprefix: $CI_JOB_NAME\npaths:\n - vendor/ruby\n```\n\nFor example, adding a `prefix` of `$CI_JOB_NAME` causes the key to look like `rspec-feef9576d21ee9b6a32e30c5c79d0a0ceb68d1e5`. If a branch changes `Gemfile.lock`, that branch has a new SHA checksum for `cache:key:files`. A new cache key is generated, and a new cache is created for that key. If `Gemfile.lock` is not found, the prefix is added to `default`, so the key in the example would be `rspec-default`.\n\n**Additional details**:\n\n- If no file in `cache:key:files`is changed in any commits, the prefix is added to the `default`key.\n\n* * *",
					"tokensEstimate": 300,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_57",
					"content": "##### `cache:untracked`\n\nUse `untracked: true` to cache all files that are untracked in your Git repository. Untracked files include files that are:\n\n- Ignored due to [.gitignore configuration](https://git-scm.com/docs/gitignore).- Created, but not added to the checkout with [git add](https://git-scm.com/docs/git-add).\n\nCaching untracked files can create unexpectedly large caches if the job downloads:\n\n- Dependencies, like gems or node modules, which are usually untracked.- [Artifacts](https://docs.gitlab.com/ci/yaml/#artifacts)from a different job. Files extracted from the artifacts are untracked by default.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `true`or `false`(default).\n\n**Example of `cache:untracked`**:\n\n```python\nrspec:\nscript: test\ncache:\nuntracked: true\n```\n\n**Additional details**:\n\n- You can combine `cache:untracked` with `cache:paths` to cache all untracked files, as well as files in the configured paths. Use `cache:paths` to cache any specific files, including tracked files, or files that are outside of the working directory, and use `cache: untracked` to also cache all untracked files. For example: ```python\nrspec:\nscript: test\ncache:\nuntracked: true\npaths:\n - binaries/\n``` In this example, the job caches all untracked files in the repository, as well as all the files in `binaries/`. If there are untracked files in `binaries/`, they are covered by both keywords.\n\n* * *",
					"tokensEstimate": 380,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_58",
					"content": "##### `cache:unprotect`\n\nUse `cache:unprotect` to set a cache to be shared between [protected](https://docs.gitlab.com/user/project/repository/branches/protected/) and unprotected branches.\n\nWhen set to `true`, users without access to protected branches can read and write to cache keys used by protected branches.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `true`or `false`(default).\n\n**Example of `cache:unprotect`**:\n\n```python\nrspec:\nscript: test\ncache:\nunprotect: true\n```\n\n* * *",
					"tokensEstimate": 151,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_59",
					"content": "##### `cache:when`\n\nUse `cache:when` to define when to save the cache, based on the status of the job.\n\nMust be used with `cache: paths`, or nothing is cached.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `on_success`(default): Save the cache only when the job succeeds.- `on_failure`: Save the cache only when the job fails.- `always`: Always save the cache.\n\n**Example of `cache:when`**:\n\n```python\nrspec:\nscript: rspec\ncache:\npaths:\n - rspec/\nwhen: 'always'\n```\n\nThis example stores the cache whether or not the job fails or succeeds.\n\n* * *",
					"tokensEstimate": 165,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_60",
					"content": "##### `cache:policy`\n\nTo change the upload and download behavior of a cache, use the `cache:policy` keyword. By default, the job downloads the cache when the job starts, and uploads changes to the cache when the job ends. This caching style is the `pull-push` policy (default).\n\nTo set a job to only download the cache when the job starts, but never upload changes when the job finishes, use `cache:policy:pull`.\n\nTo set a job to only upload a cache when the job finishes, but never download the cache when the job starts, use `cache:policy:push`.\n\nUse the `pull` policy when you have many jobs executing in parallel that use the same cache. This policy speeds up job execution and reduces load on the cache server. You can use a job with the `push` policy to build the cache.\n\nMust be used with `cache: paths`, or nothing is cached.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `pull`- `push`- `pull-push`(default)- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `cache:policy`**:\n\n```python\nprepare-dependencies-job:\nstage: build\ncache:\nkey: gems\npaths:\n - vendor/bundle\npolicy: push\nscript:\n - echo \"This job only downloads dependencies and builds the cache.\"\n - echo \"Downloading dependencies...\"\n\nfaster-test-job:\nstage: test\ncache:\nkey: gems\npaths:\n - vendor/bundle\npolicy: pull\nscript:\n - echo \"This job script uses the cache, but does not update it.\"\n - echo \"Running tests...\"\n```\n\n**Related topics**:\n\n- You can [use a variable to control a job’s cache policy](https://docs.gitlab.com/ci/caching/examples/#use-a-variable-to-control-a-jobs-cache-policy).\n\n* * *",
					"tokensEstimate": 436,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_61",
					"content": "##### `cache:fallback_keys`\n\nUse `cache:fallback_keys` to specify a list of keys to try to restore cache from if there is no cache found for the `cache:key`. Caches are retrieved in the order specified in the `fallback_keys` section.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of cache keys\n\n**Example of `cache:fallback_keys`**:\n\n```python\nrspec:\nscript: rspec\ncache:\nkey: gems-$CI_COMMIT_REF_SLUG\npaths:\n - rspec/\nfallback_keys:\n - gems\nwhen: 'always'\n```\n\n* * *",
					"tokensEstimate": 148,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_62",
					"content": "#### `coverage`\n\nUse `coverage` with a custom regular expression to configure how code coverage is extracted from the job output. The coverage is shown in the UI if at least one line in the job output matches the regular expression.\n\nTo extract the code coverage value from the match, GitLab uses this smaller regular expression: `\\d+(?:\\.\\d+)?`.\n\n**Supported values**:\n\n- An RE2 regular expression. Must start and end with `/`. Must match the coverage number. May match surrounding text as well, so you don’t need to use a regular expression character group to capture the exact number. Because it uses RE2 syntax, all groups must be non-capturing.\n\n**Example of `coverage`**:\n\n```python\njob1:\nscript: rspec\ncoverage: '/Code coverage: \\d+(?:\\.\\d+)?/'\n```\n\nIn this example:\n\n- GitLab checks the job log for a match with the regular expression. A line like `Code coverage: 67.89% of lines covered`would match.- GitLab then checks the matched fragment to find a match to the regular expression: `\\d+(?:\\.\\d+)?`. The sample regex can match a code coverage of `67.89`.\n\n**Additional details**:\n\n- You can find regex examples in [Code Coverage](https://docs.gitlab.com/ci/testing/code_coverage/#coverage-regex-patterns).- If there is more than one matched line in the job output, the last line is used (the first result of reverse search).- If there are multiple matches in a single line, the last match is searched for the coverage number.- If there are multiple coverage numbers found in the matched fragment, the first number is used.- Leading zeros are removed.- Coverage output from [child pipelines](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines)is not recorded or displayed. Check [the related issue](https://gitlab.com/gitlab-org/gitlab/-/issues/280818)for more details.\n\n* * *",
					"tokensEstimate": 452,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_63",
					"content": "#### `dast_configuration`\n\n- Tier: Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nUse the `dast_configuration` keyword to specify a site profile and scanner profile to be used in a CI/CD configuration. Both profiles must first have been created in the project. The job’s stage must be `dast`.\n\n**Keyword type**: Job keyword. You can use only as part of a job.\n\n**Supported values**: One each of `site_profile` and `scanner_profile`.\n\n- Use `site_profile`to specify the site profile to be used in the job.- Use `scanner_profile`to specify the scanner profile to be used in the job.\n\n**Example of `dast_configuration`**:\n\n```python\nstages:\n - build\n - dast\n\ninclude:\n - template: DAST.gitlab-ci.yml\n\ndast:\ndast_configuration:\nsite_profile: \"Example Co\"\nscanner_profile: \"Quick Passive Test\"\n```\n\nIn this example, the `dast` job extends the `dast` configuration added with the `include` keyword to select a specific site profile and scanner profile.\n\n**Additional details**:\n\n- Settings contained in either a site profile or scanner profile take precedence over those contained in the DAST template.\n\n**Related topics**:\n\n- [Site profile](https://docs.gitlab.com/user/application_security/dast/profiles/#site-profile).- [Scanner profile](https://docs.gitlab.com/user/application_security/dast/profiles/#scanner-profile).\n\n* * *",
					"tokensEstimate": 333,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_64",
					"content": "#### `dependencies`\n\nUse the `dependencies` keyword to define a list of specific jobs to fetch [artifacts](https://docs.gitlab.com/ci/yaml/#artifacts) from. The specified jobs must all be in earlier stages. You can also set a job to download no artifacts at all.\n\nWhen `dependencies` is not defined in a job, all jobs in earlier stages are considered dependent and the job fetches all artifacts from those jobs.\n\nTo fetch artifacts from a job in the same stage, you must use [`needs:artifacts`](https://docs.gitlab.com/ci/yaml/#needsartifacts). You should not combine `dependencies` with `needs` in the same job.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- The names of jobs to fetch artifacts from.- An empty array ( `[]`), to configure the job to not download any artifacts.\n\n**Example of `dependencies`**:\n\n```python\nbuild osx:\nstage: build\nscript: make build:osx\nartifacts:\npaths:\n - binaries/\n\nbuild linux:\nstage: build\nscript: make build:linux\nartifacts:\npaths:\n - binaries/\n\ntest osx:\nstage: test\nscript: make test:osx\ndependencies:\n - build osx\n\ntest linux:\nstage: test\nscript: make test:linux\ndependencies:\n - build linux\n\ndeploy:\nstage: deploy\nscript: make deploy\nenvironment: production\n```\n\nIn this example, two jobs have artifacts: `build osx` and `build linux`. When `test osx` is executed, the artifacts from `build osx` are downloaded and extracted in the context of the build. The same thing happens for `test linux` and artifacts from `build linux`.\n\nThe `deploy` job downloads artifacts from all previous jobs because of the [stage](https://docs.gitlab.com/ci/yaml/#stages) precedence.\n\n**Additional details**:\n\n- The job status does not matter. If a job fails or it’s a manual job that isn’t triggered, no error occurs.- If the artifacts of a dependent job are [expired](https://docs.gitlab.com/ci/yaml/#artifactsexpire_in)or [deleted](https://docs.gitlab.com/ci/jobs/job_artifacts/#delete-job-log-and-artifacts), then the job fails.\n\n* * *",
					"tokensEstimate": 498,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_65",
					"content": "#### `environment`\n\nUse `environment` to define the [environment](https://docs.gitlab.com/ci/environments/) that a job deploys to.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: The name of the environment the job deploys to, in one of these formats:\n\n- Plain text, including letters, digits, spaces, and these characters: `-`, `_`, `/`, `$`, `{`, `}`.- CI/CD variables, including predefined, project, group, instance, or variables defined in the `.gitlab-ci.yml`file. You can’t use variables defined in a `script`section.\n\n**Example of `environment`**:\n\n```python\ndeploy to production:\nstage: deploy\nscript: git push production HEAD:main\nenvironment: production\n```\n\n**Additional details**:\n\n- If you specify an `environment`and no environment with that name exists, an environment is created.\n\n* * *",
					"tokensEstimate": 210,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_66",
					"content": "##### `environment:name`\n\nSet a name for an [environment](https://docs.gitlab.com/ci/environments/).\n\nCommon environment names are `qa`, `staging`, and `production`, but you can use any name.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: The name of the environment the job deploys to, in one of these formats:\n\n- Plain text, including letters, digits, spaces, and these characters: `-`, `_`, `/`, `$`, `{`, `}`.- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file), including predefined, project, group, instance, or variables defined in the `.gitlab-ci.yml`file. You can’t use variables defined in a `script`section.\n\n**Example of `environment:name`**:\n\n```python\ndeploy to production:\nstage: deploy\nscript: git push production HEAD:main\nenvironment:\nname: production\n```\n\n* * *",
					"tokensEstimate": 218,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_67",
					"content": "##### `environment:url`\n\nSet a URL for an [environment](https://docs.gitlab.com/ci/environments/).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: A single URL, in one of these formats:\n\n- Plain text, like `https://prod.example.com`.- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file), including predefined, project, group, instance, or variables defined in the `.gitlab-ci.yml`file. You can’t use variables defined in a `script`section.\n\n**Example of `environment:url`**:\n\n```python\ndeploy to production:\nstage: deploy\nscript: git push production HEAD:main\nenvironment:\nname: production\nurl: https://prod.example.com\n```\n\n**Additional details**:\n\n- After the job completes, you can access the URL by selecting a button in the merge request, environment, or deployment pages.\n\n* * *",
					"tokensEstimate": 218,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_68",
					"content": "##### `environment:on_stop`\n\nClosing (stopping) environments can be achieved with the `on_stop` keyword defined under `environment`. It declares a different job that runs to close the environment.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Additional details**:\n\n- See [environment:action](https://docs.gitlab.com/ci/yaml/#environmentaction)for more details and an example.\n\n* * *",
					"tokensEstimate": 102,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_69",
					"content": "##### `environment:action`\n\nUse the `action` keyword to specify how the job interacts with the environment.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: One of the following keywords:\n\n**Value**\n\n**Description**\n\n`start`\n\nDefault value. Indicates that the job starts the environment. The deployment is created after the job starts.\n\n`prepare`\n\nIndicates that the job is only preparing the environment. It does not trigger deployments. [Read more about preparing environments](https://docs.gitlab.com/ci/environments/#access-an-environment-for-preparation-or-verification-purposes).\n\n`stop`\n\nIndicates that the job stops an environment. [Read more about stopping an environment](https://docs.gitlab.com/ci/environments/#stopping-an-environment).\n\n`verify`\n\nIndicates that the job is only verifying the environment. It does not trigger deployments. [Read more about verifying environments](https://docs.gitlab.com/ci/environments/#access-an-environment-for-preparation-or-verification-purposes).\n\n`access`\n\nIndicates that the job is only accessing the environment. It does not trigger deployments. [Read more about accessing environments](https://docs.gitlab.com/ci/environments/#access-an-environment-for-preparation-or-verification-purposes).\n\n**Example of `environment:action`**:\n\n```python\nstop_review_app:\nstage: deploy\nvariables:\nGIT_STRATEGY: none\nscript: make delete-app\nwhen: manual\nenvironment:\nname: review/$CI_COMMIT_REF_SLUG\naction: stop\n```\n\n* * *",
					"tokensEstimate": 373,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_70",
					"content": "##### `environment:auto_stop_in`\n\nThe `auto_stop_in` keyword specifies the lifetime of the environment. When an environment expires, GitLab automatically stops it.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: A period of time written in natural language. For example, these are all equivalent:\n\n- `168 hours`- `7 days`- `one week`- `never`\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `environment:auto_stop_in`**:\n\n```python\nreview_app:\nscript: deploy-review-app\nenvironment:\nname: review/$CI_COMMIT_REF_SLUG\nauto_stop_in: 1 day\n```\n\nWhen the environment for `review_app` is created, the environment’s lifetime is set to `1 day`. Every time the review app is deployed, that lifetime is also reset to `1 day`.\n\nThe `auto_stop_in` keyword can be used for all [environment actions](https://docs.gitlab.com/ci/yaml/#environmentaction) except `stop`. Some actions can be used to reset the scheduled stop time for the environment. For more information, see [Access an environment for preparation or verification purposes](https://docs.gitlab.com/ci/environments/#access-an-environment-for-preparation-or-verification-purposes).\n\n**Related topics**:\n\n- [Environments auto-stop documentation](https://docs.gitlab.com/ci/environments/#stop-an-environment-after-a-certain-time-period).\n\n* * *",
					"tokensEstimate": 352,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_71",
					"content": "##### `environment:kubernetes`\n\n\n\nUse the `kubernetes` keyword to configure the [dashboard for Kubernetes](https://docs.gitlab.com/ci/environments/kubernetes_dashboard/) and [GitLab-managed Kubernetes resources](https://docs.gitlab.com/user/clusters/agent/managed_kubernetes_resources/) for an environment.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `agent`: A string specifying the [GitLab agent for Kubernetes](https://docs.gitlab.com/user/clusters/agent/). The format is `path/to/agent/project:agent-name`. If the agent is connected to the project running the pipeline, use `$CI_PROJECT_PATH:agent-name`.- `dashboard:namespace`: A string representing the Kubernetes namespace where the environment is deployed. The namespace must be set together with the `agent`keyword. `namespace`is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#environmentkubernetesnamespace-and-environmentkubernetesflux_resource_path).- `dashboard:flux_resource_path`: A string representing the full path to the Flux resource, such as a `HelmRelease`. The Flux resource must be set together with the `agent`and `dashboard:namespace`keywords. `flux_resource_path`is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#environmentkubernetesnamespace-and-environmentkubernetesflux_resource_path).- `managed_resources`: A hash with the `enabled`keyword to configure the [GitLab-managed Kubernetes resources](https://docs.gitlab.com/user/clusters/agent/managed_kubernetes_resources/)for the environment.\n - `managed_resources:enabled`: A boolean value indicating whether GitLab-managed Kubernetes resources are enabled for the environment.- `dashboard`: A hash with the `dashboard:namespace`and `dashboard:flux_resource_path`keywords to configure the [dashboard for Kubernetes](https://docs.gitlab.com/ci/environments/kubernetes_dashboard/)for the environment.\n\n**Example of `environment:kubernetes`**:\n\n```python\ndeploy:\nstage: deploy\nscript: make deploy-app\nenvironment:\nname: production\nkubernetes:\nagent: path/to/agent/project:agent-name\ndashboard:\nnamespace: my-namespace\nflux_resource_path: helm.toolkit.fluxcd.io/v2/namespaces/flux-system/helmreleases/helm-release-resource\n```\n\n**Example of `environment:kubernetes`** when disabling managed resources:",
					"tokensEstimate": 577,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_72",
					"content": "```python\ndeploy:\nstage: deploy\nscript: make deploy-app\nenvironment:\nname: production\nkubernetes:\nagent: path/to/agent/project:agent-name\nmanaged_resources:\nenabled: false\ndashboard:\nnamespace: my-namespace\nflux_resource_path: helm.toolkit.fluxcd.io/v2/namespaces/flux-system/helmreleases/helm-release-resource\n```\n\nThis configuration:\n\n- Sets up the `deploy`job to deploy to the `production`environment.- Associates the [agent](https://docs.gitlab.com/user/clusters/agent/)named `agent-name`with the environment.- Configures the [dashboard for Kubernetes](https://docs.gitlab.com/ci/environments/kubernetes_dashboard/)for an environment with the namespace `my-namespace`and the `flux_resource_path`set to `helm.toolkit.fluxcd.io/v2/namespaces/flux-system/helmreleases/helm-release-resource`.\n\n**Additional details**:\n\n- To use the dashboard, you must [install the GitLab agent for Kubernetes](https://docs.gitlab.com/user/clusters/agent/install/)and [configure user_access](https://docs.gitlab.com/user/clusters/agent/user_access/)for the environment’s project or its parent group.- The user running the job must be authorized to access the cluster agent. Otherwise, the dashboard ignores the `agent`, `namespace`, and `flux_resource_path`attributes.- If you only want to set the `agent`, you do not have to set the `namespace`, and cannot set `flux_resource_path`. However, this configuration lists all namespaces in a cluster in the dashboard for Kubernetes.\n\n* * *",
					"tokensEstimate": 366,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_73",
					"content": "##### `environment:deployment_tier`\n\nUse the `deployment_tier` keyword to specify the tier of the deployment environment.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: One of the following:\n\n- `production`- `staging`- `testing`- `development`- `other`- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file), including predefined, project, group, instance, or variables defined in the `.gitlab-ci.yml`file. You can’t use variables defined in a `script`section.\n\n**Example of `environment:deployment_tier`**:\n\n```python\ndeploy:\nscript: echo\nenvironment:\nname: customer-portal\ndeployment_tier: production\n```\n\n**Additional details**:\n\n- Environments created from this job definition are assigned a [tier](https://docs.gitlab.com/ci/environments/#deployment-tier-of-environments)based on this value.- Existing environments don’t have their tier updated if this value is added later. Existing environments must have their tier updated via the [Environments API](https://docs.gitlab.com/api/environments/#update-an-existing-environment).\n\n**Related topics**:\n\n- [Deployment tier of environments](https://docs.gitlab.com/ci/environments/#deployment-tier-of-environments).\n\n* * *",
					"tokensEstimate": 314,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_74",
					"content": "##### Dynamic environments\n\nUse CI/CD [variables](https://docs.gitlab.com/ci/variables/) to dynamically name environments.\n\nFor example:\n\n```python\ndeploy as review app:\nstage: deploy\nscript: make deploy\nenvironment:\nname: review/$CI_COMMIT_REF_SLUG\nurl: https://$CI_ENVIRONMENT_SLUG.example.com/\n```\n\nThe `deploy as review app` job is marked as a deployment to dynamically create the `review/$CI_COMMIT_REF_SLUG` environment. `$CI_COMMIT_REF_SLUG` is a [CI/CD variable](https://docs.gitlab.com/ci/variables/) set by the runner. The `$CI_ENVIRONMENT_SLUG` variable is based on the environment name, but suitable for inclusion in URLs. If the `deploy as review app` job runs in a branch named `pow`, this environment would be accessible with a URL like `https://review-pow.example.com/`.\n\nThe common use case is to create dynamic environments for branches and use them as review apps. You can see an example that uses review apps at https://gitlab.com/gitlab-examples/review-apps-nginx/.\n\n* * *",
					"tokensEstimate": 247,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_75",
					"content": "#### `extends`\n\nUse `extends` to reuse configuration sections. It’s an alternative to [YAML anchors](https://docs.gitlab.com/ci/yaml/yaml_optimization/#anchors) and is a little more flexible and readable.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- The name of another job in the pipeline.- A list (array) of names of other jobs in the pipeline.\n\n**Example of `extends`**:\n\n```python\n.tests:\nstage: test\nimage: ruby:3.0\n\nrspec:\nextends: .tests\nscript: rake rspec\n\nrubocop:\nextends: .tests\nscript: bundle exec rubocop\n```\n\nIn this example, the `rspec` job uses the configuration from the `.tests` template job. When creating the pipeline, GitLab:\n\n- Performs a reverse deep merge based on the keys.- Merges the `.tests`content with the `rspec`job.- Doesn’t merge the values of the keys.\n\nThe combined configuration is equivalent to these jobs:\n\n```python\nrspec:\nstage: test\nimage: ruby:3.0\nscript: rake rspec\n\nrubocop:\nstage: test\nimage: ruby:3.0\nscript: bundle exec rubocop\n```\n\n**Additional details**:\n\n- You can use multiple parents for `extends`.- The `extends`keyword supports up to eleven levels of inheritance, but you should avoid using more than three levels.- In the previous example, `.tests`is a [hidden job](https://docs.gitlab.com/ci/jobs/#hide-a-job), but you can extend configuration from regular jobs as well.\n\n**Related topics**:\n\n- [Reuse configuration sections by using extends](https://docs.gitlab.com/ci/yaml/yaml_optimization/#use-extends-to-reuse-configuration-sections).- Use `extends`to reuse configuration from [included configuration files](https://docs.gitlab.com/ci/yaml/yaml_optimization/#use-extends-and-include-together).\n\n* * *",
					"tokensEstimate": 424,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_76",
					"content": "#### `hooks`\n\nUse `hooks` to specify lists of commands to execute on the runner at certain stages of job execution, like before retrieving the Git repository.\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:hooks`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `hooks`, the job configuration takes precedence and the default configuration is not used.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A hash of hooks and their commands. Available hooks: `pre_get_sources_script`.\n\n* * *",
					"tokensEstimate": 170,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_77",
					"content": "##### `hooks:pre_get_sources_script`\n\nUse `hooks:pre_get_sources_script` to specify a list of commands to execute on the runner before cloning the Git repository and any submodules. You can use it for example to:\n\n- Adjust the [Git configuration](https://docs.gitlab.com/ci/jobs/job_troubleshooting/#get_sources-job-section-fails-because-of-an-http2-problem).- Export [tracing variables](https://docs.gitlab.com/topics/git/troubleshooting_git/#debug-git-with-traces).\n\n**Supported values**: An array including:\n\n- Single line commands.- Long commands [split over multiple lines](https://docs.gitlab.com/ci/yaml/script/#split-long-commands).- [YAML anchors](https://docs.gitlab.com/ci/yaml/yaml_optimization/#yaml-anchors-for-scripts).\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `hooks:pre_get_sources_script`**:\n\n```python\njob1:\nhooks:\npre_get_sources_script:\n - echo 'hello job1 pre_get_sources_script'\nscript: echo 'hello job1 script'\n```\n\n**Related topics**:\n\n- [GitLab Runner configuration](https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runners-section)\n\n* * *",
					"tokensEstimate": 294,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_78",
					"content": "#### `identity`\n\n- Tier: Free, Premium, Ultimate- Offering: GitLab.com- Status: Beta\n\nThis feature is in [beta](https://docs.gitlab.com/policy/development_stages_support/).\n\nUse `identity` to authenticate with third party services using identity federation.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default:` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: An identifier. Supported providers:\n\n- `google_cloud`: Google Cloud. Must be configured with the [Google Cloud IAM integration](https://docs.gitlab.com/integration/google_cloud_iam/).\n\n**Example of `identity`**:\n\n```python\njob_with_workload_identity:\nidentity: google_cloud\nscript:\n - gcloud compute instances list\n```\n\n**Related topics**:\n\n- [Workload Identity Federation](https://cloud.google.com/iam/docs/workload-identity-federation).- [Google Cloud IAM integration](https://docs.gitlab.com/integration/google_cloud_iam/).\n\n* * *",
					"tokensEstimate": 237,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_79",
					"content": "#### `id_tokens`\n\nUse `id_tokens` to create [ID tokens](https://docs.gitlab.com/ci/secrets/id_token_authentication/) to authenticate with third party services. All JWTs created this way support OIDC authentication. The required `aud` sub-keyword is used to configure the `aud` claim for the JWT.\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:id_tokens`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `id_tokens`, the job configuration takes precedence and the default configuration is not used.\n\n**Supported values**:\n\n- Token names with their `aud`claims. `aud`supports:\n - A single string.- An array of strings.- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `id_tokens`**:\n\n```python\njob_with_id_tokens:\nid_tokens:\nID_TOKEN_1:\naud: https://vault.example.com\nID_TOKEN_2:\naud:\n - https://gcp.com\n - https://aws.com\nSIGSTORE_ID_TOKEN:\naud: sigstore\nscript:\n - command_to_authenticate_with_vault $ID_TOKEN_1\n - command_to_authenticate_with_aws $ID_TOKEN_2\n - command_to_authenticate_with_gcp $ID_TOKEN_2\n```\n\n**Related topics**:\n\n- [ID token authentication](https://docs.gitlab.com/ci/secrets/id_token_authentication/).- [Connect to cloud services](https://docs.gitlab.com/ci/cloud_services/).- [Keyless signing with Sigstore](https://docs.gitlab.com/ci/yaml/signing_examples/).\n\n* * *",
					"tokensEstimate": 356,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_80",
					"content": "#### `image`\n\nUse `image` to specify a Docker image that the job runs in.\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:image`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `image`, the job configuration takes precedence and the default configuration is not used.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: The name of the image, including the registry path if needed, in one of these formats:\n\n- `<image-name>`(Same as using `<image-name>`with the `latest`tag)- `<image-name>:<tag>`- `<image-name>@<digest>`\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `image`**:\n\n```python\ndefault:\nimage: ruby:3.0\n\nrspec:\nscript: bundle exec rspec\n\nrspec 2.7:\nimage: registry.example.com/my-group/my-project/ruby:2.7\nscript: bundle exec rspec\n```\n\nIn this example, the `ruby:3.0` image is the default for all jobs in the pipeline. The `rspec 2.7` job does not use the default, because it overrides the default with a job-specific `image` section.\n\n**Additional details**:\n\n- Using `image`at the top level, but not in the `default`section, is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#globally-defined-image-services-cache-before_script-after_script).\n\n**Related topics**:\n\n- [Run your CI/CD jobs in Docker containers](https://docs.gitlab.com/ci/docker/using_docker_images/).\n\n* * *",
					"tokensEstimate": 392,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_81",
					"content": "##### `image:name`\n\nThe name of the Docker image that the job runs in. Similar to [`image`](https://docs.gitlab.com/ci/yaml/#image) used by itself.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: The name of the image, including the registry path if needed, in one of these formats:\n\n- `<image-name>`(Same as using `<image-name>`with the `latest`tag)- `<image-name>:<tag>`- `<image-name>@<digest>`\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `image:name`**:\n\n```python\ntest-job:\nimage:\nname: \"registry.example.com/my/image:latest\"\nscript: echo \"Hello world\"\n```\n\n**Related topics**:\n\n- [Run your CI/CD jobs in Docker containers](https://docs.gitlab.com/ci/docker/using_docker_images/).\n\n* * *",
					"tokensEstimate": 222,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_82",
					"content": "##### `image:entrypoint`\n\nCommand or script to execute as the container’s entry point.\n\nWhen the Docker container is created, the `entrypoint` is translated to the Docker `--entrypoint` option. The syntax is similar to the [Dockerfile `ENTRYPOINT` directive](https://docs.docker.com/reference/dockerfile/#entrypoint), where each shell token is a separate string in the array.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A string.\n\n**Example of `image:entrypoint`**:\n\n```python\ntest-job:\nimage:\nname: super/sql:experimental\nentrypoint: [\"\"]\nscript: echo \"Hello world\"\n```\n\n**Related topics**:\n\n- [Override the entrypoint of an image](https://docs.gitlab.com/ci/docker/using_docker_images/#override-the-entrypoint-of-an-image).\n\n* * *",
					"tokensEstimate": 212,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_83",
					"content": "##### `image:docker`\n\nUse `image:docker` to pass options to runners using the [Docker executor](https://docs.gitlab.com/runner/executors/docker.html) or the [Kubernetes executor](https://docs.gitlab.com/runner/executors/kubernetes/). This keyword does not work with other executor types.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\nA hash of options for the Docker executor, which can include:\n\n- `platform`: Selects the architecture of the image to pull. When not specified, the default is the same platform as the host runner.- `user`: Specify the username or UID to use when running the container.\n\n**Example of `image:docker`**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests\"\nimage:\nname: super/sql:experimental\ndocker:\nplatform: arm64/v8\nuser: dave\n```\n\n**Additional details**:\n\n- `image:docker:platform`maps to the [docker pull --platform option](https://docs.docker.com/reference/cli/docker/image/pull/#options).- `image:docker:user`maps to the [docker run --user option](https://docs.docker.com/reference/cli/docker/container/run/#options).\n\n* * *",
					"tokensEstimate": 294,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_84",
					"content": "##### `image:kubernetes`\n\nUse `image:kubernetes` to pass options to the GitLab Runner [Kubernetes executor](https://docs.gitlab.com/runner/executors/kubernetes/). This keyword does not work with other executor types.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\nA hash of options for the Kubernetes executor, which can include:\n\n- `user`: Specify the username or UID to use when the container runs. You can also use it to set GID by using the `UID:GID`format.\n\n**Example of `image:kubernetes` with only UID**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests\"\nimage:\nname: super/sql:experimental\nkubernetes:\nuser: \"1001\"\n```\n\n**Example of `image:kubernetes` with both UID and GID**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests\"\nimage:\nname: super/sql:experimental\nkubernetes:\nuser: \"1001:1001\"\n```\n\n* * *",
					"tokensEstimate": 232,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_85",
					"content": "##### `image:pull_policy`\n\nThe pull policy that the runner uses to fetch the Docker image.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A single pull policy, or multiple pull policies in an array. Can be `always`, `if-not-present`, or `never`.\n\n**Examples of `image:pull_policy`**:\n\n```python\njob1:\nscript: echo \"A single pull policy.\"\nimage:\nname: ruby:3.0\npull_policy: if-not-present\n\njob2:\nscript: echo \"Multiple pull policies.\"\nimage:\nname: ruby:3.0\npull_policy: [always, if-not-present]\n```\n\n**Additional details**:\n\n- If the runner does not support the defined pull policy, the job fails with an error similar to: `ERROR: Job failed (system failure): the configured PullPolicies ([always]) are not allowed by AllowedPullPolicies ([never])`.\n\n**Related topics**:\n\n- [Run your CI/CD jobs in Docker containers](https://docs.gitlab.com/ci/docker/using_docker_images/).- [Configure how runners pull images](https://docs.gitlab.com/runner/executors/docker.html#configure-how-runners-pull-images).- [Set multiple pull policies](https://docs.gitlab.com/runner/executors/docker.html#set-multiple-pull-policies).\n\n* * *\n\n#### `inherit`\n\nUse `inherit` to [control inheritance of default keywords and variables](https://docs.gitlab.com/ci/jobs/#control-the-inheritance-of-default-keywords-and-variables).\n\n* * *",
					"tokensEstimate": 354,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_86",
					"content": "##### `inherit:default`\n\nUse `inherit:default` to control the inheritance of [default keywords](https://docs.gitlab.com/ci/yaml/#default).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`(default) or `false`to enable or disable the inheritance of all default keywords.- A list of specific default keywords to inherit.\n\n**Example of `inherit:default`**:\n\n```python\ndefault:\nretry: 2\nimage: ruby:3.0\ninterruptible: true\n\njob1:\nscript: echo \"This job does not inherit any default keywords.\"\ninherit:\ndefault: false\n\njob2:\nscript: echo \"This job inherits only the two listed default keywords. It does not inherit 'interruptible'.\"\ninherit:\ndefault:\n - retry\n - image\n```\n\n**Additional details**:\n\n- You can also list default keywords to inherit on one line: `default: [keyword1, keyword2]`\n\n* * *",
					"tokensEstimate": 209,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_87",
					"content": "##### `inherit:variables`\n\nUse `inherit:variables` to control the inheritance of [default variables](https://docs.gitlab.com/ci/yaml/#default-variables) keywords.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`(default) or `false`to enable or disable the inheritance of all default variables.- A list of specific variables to inherit.\n\n**Example of `inherit:variables`**:\n\n```python\nvariables:\nVARIABLE1: \"This is default variable 1\"\nVARIABLE2: \"This is default variable 2\"\nVARIABLE3: \"This is default variable 3\"\n\njob1:\nscript: echo \"This job does not inherit any default variables.\"\ninherit:\nvariables: false\n\njob2:\nscript: echo \"This job inherits only the two listed default variables. It does not inherit 'VARIABLE3'.\"\ninherit:\nvariables:\n - VARIABLE1\n - VARIABLE2\n```\n\n**Additional details**:\n\n- You can also list default variables to inherit on one line: `variables: [VARIABLE1, VARIABLE2]`\n\n* * *",
					"tokensEstimate": 237,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_88",
					"content": "#### `interruptible`\n\n\n\nUse `interruptible` to configure the [auto-cancel redundant pipelines](https://docs.gitlab.com/ci/pipelines/settings/#auto-cancel-redundant-pipelines) feature to cancel a job before it completes if a new pipeline on the same ref starts for a newer commit. If the feature is disabled, the keyword has no effect. The new pipeline must be for a commit with new changes. For example, the **Auto-cancel redundant pipelines** feature has no effect if you select **New pipeline** in the UI to run a pipeline for the same commit.\n\nThe behavior of the **Auto-cancel redundant pipelines** feature can be controlled by the [`workflow:auto_cancel:on_new_commit`](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit) setting.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `true`or `false`(default).\n\n**Example of `interruptible` with the default behavior**:\n\n```python\nworkflow:\nauto_cancel:\non_new_commit: conservative # the default behavior\n\nstages:\n - stage1\n - stage2\n - stage3\n\nstep-1:\nstage: stage1\nscript:\n - echo \"Can be canceled.\"\ninterruptible: true\n\nstep-2:\nstage: stage2\nscript:\n - echo \"Can not be canceled.\"\n\nstep-3:\nstage: stage3\nscript:\n - echo \"Because step-2 can not be canceled, this step can never be canceled, even though it's set as interruptible.\"\ninterruptible: true\n```\n\nIn this example, a new pipeline causes a running pipeline to be:\n\n- Canceled, if only `step-1`is running or pending.- Not canceled, after `step-2`starts.\n\n**Example of `interruptible` with the `auto_cancel:on_new_commit:interruptible` setting**:\n\n```python\nworkflow:\nauto_cancel:\non_new_commit: interruptible\n\nstages:\n - stage1\n - stage2\n - stage3\n\nstep-1:\nstage: stage1\nscript:\n - echo \"Can be canceled.\"\ninterruptible: true\n\nstep-2:\nstage: stage2\nscript:\n - echo \"Can not be canceled.\"\n\nstep-3:\nstage: stage3\nscript:\n - echo \"Can be canceled.\"\ninterruptible: true\n```\n\nIn this example, a new pipeline causes a running pipeline to cancel `step-1` and `step-3` if they are running or pending.\n\n**Additional details**:",
					"tokensEstimate": 532,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_89",
					"content": "- Only set `interruptible: true`if the job can be safely canceled after it has started, like a build job. Deployment jobs usually shouldn’t be canceled, to prevent partial deployments.- When using the default behavior or `workflow:auto_cancel:on_new_commit: conservative`:\n - A job that has not started yet is always considered `interruptible: true`, regardless of the job’s configuration. The `interruptible`configuration is only considered after the job starts.- **Running**pipelines are only canceled if all running jobs are configured with `interruptible: true`or no jobs configured with `interruptible: false`have started at any time. After a job with `interruptible: false`starts, the entire pipeline is no longer considered interruptible.- If the pipeline triggered a downstream pipeline, but no job with `interruptible: false`in the downstream pipeline has started yet, the downstream pipeline is also canceled.- You can add an optional manual job with `interruptible: false`in the first stage of a pipeline to allow users to manually prevent a pipeline from being automatically canceled. After a user starts the job, the pipeline cannot be canceled by the **Auto-cancel redundant pipelines**feature.- When using `interruptible`with a [trigger job](https://docs.gitlab.com/ci/yaml/#trigger):\n - The triggered downstream pipeline is never affected by the trigger job’s `interruptible`configuration.- If [workflow:auto_cancel](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit)is set to `conservative`, the trigger job’s `interruptible`configuration has no effect.- If [workflow:auto_cancel](https://docs.gitlab.com/ci/yaml/#workflowauto_cancelon_new_commit)is set to `interruptible`, a trigger job with `interruptible: true`can be automatically canceled.\n\n* * *",
					"tokensEstimate": 446,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_90",
					"content": "#### `needs`\n\nUse `needs` to execute jobs out-of-order. Relationships between jobs that use `needs` can be visualized as a [directed acyclic graph](https://docs.gitlab.com/ci/yaml/needs/).\n\nYou can ignore stage ordering and run some jobs without waiting for others to complete. Jobs in multiple stages can run concurrently.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- An array of jobs (maximum of 50 jobs).- An empty array ( `[]`), to set the job to start as soon as the pipeline is created.\n\n**Example of `needs`**:\n\n```python\nlinux:build:\nstage: build\nscript: echo \"Building linux...\"\n\nmac:build:\nstage: build\nscript: echo \"Building mac...\"\n\nlint:\nstage: test\nneeds: []\nscript: echo \"Linting...\"\n\nlinux:rspec:\nstage: test\nneeds: [\"linux:build\"]\nscript: echo \"Running rspec on linux...\"\n\nmac:rspec:\nstage: test\nneeds: [\"mac:build\"]\nscript: echo \"Running rspec on mac...\"\n\nproduction:\nstage: deploy\nscript: echo \"Running production...\"\nenvironment: production\n```\n\nThis example creates four paths of execution:\n\n- Linter: The `lint`job runs immediately without waiting for the `build`stage to complete because it has no needs ( `needs: []`).- Linux path: The `linux:rspec`job runs as soon as the `linux:build`job finishes, without waiting for `mac:build`to finish.- macOS path: The `mac:rspec`jobs runs as soon as the `mac:build`job finishes, without waiting for `linux:build`to finish.- The `production`job runs as soon as all previous jobs finish: `lint`, `linux:build`, `linux:rspec`, `mac:build`, `mac:rspec`.\n\n**Additional details**:\n\n- The maximum number of jobs that a single job can have in the `needs`array is limited:\n - For GitLab.com, the limit is 50. For more information, see [issue 350398](https://gitlab.com/gitlab-org/gitlab/-/issues/350398).- For GitLab Self-Managed and GitLab Dedicated, the default limit is 50. This limit can be changed by [updating the CI/CD limits in the Admin area](https://docs.gitlab.com/administration/settings/continuous_integration/#set-cicd-limits).- If `needs`refers to a job that uses the [parallel](https://docs.gitlab.com/ci/yaml/#parallel)keyword, it depends on all jobs created in parallel, not just one job. It also downloads artifacts from all the parallel jobs by default. If the artifacts have the same name, they overwrite each other and only the last one downloaded is saved.\n - To have `needs`refer to a subset of parallelized jobs (and not all of the parallelized jobs), use the [needs:parallel:matrix](https://docs.gitlab.com/ci/yaml/#needsparallelmatrix)keyword.- You can refer to jobs in the same stage as the job you are configuring.- If `needs`refers to a job that might not be added to a pipeline because of `only`, `except`, or `rules`, the pipeline might fail to create. Use the [needs:optional](https://docs.gitlab.com/ci/yaml/#needsoptional)keyword to resolve a failed pipeline creation.- If a pipeline has jobs with `needs: []`and jobs in the [.pre](https://docs.gitlab.com/ci/yaml/#stage-pre)stage, they will all start as soon as the pipeline is created. Jobs with `needs: []`start immediately, and jobs in the `.pre`stage also start immediately.\n\n* * *",
					"tokensEstimate": 790,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_91",
					"content": "##### `needs:artifacts`\n\nWhen a job uses `needs`, it no longer downloads all artifacts from previous stages by default, because jobs with `needs` can start before earlier stages complete. With `needs` you can only download artifacts from the jobs listed in the `needs` configuration.\n\nUse `artifacts: true` (default) or `artifacts: false` to control when artifacts are downloaded in jobs that use `needs`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job. Must be used with `needs:job`.\n\n**Supported values**:\n\n- `true`(default) or `false`.\n\n**Example of `needs:artifacts`**:\n\n```python\ntest-job1:\nstage: test\nneeds:\n - job: build_job1\nartifacts: true\n\ntest-job2:\nstage: test\nneeds:\n - job: build_job2\nartifacts: false\n\ntest-job3:\nneeds:\n - job: build_job1\nartifacts: true\n - job: build_job2\n - build_job3\n```\n\nIn this example:\n\n- The `test-job1`job downloads the `build_job1`artifacts- The `test-job2`job does not download the `build_job2`artifacts.- The `test-job3`job downloads the artifacts from all three `build_jobs`, because `artifacts`is `true`, or defaults to `true`, for all three needed jobs.\n\n**Additional details**:\n\n- You should not combine `needs`with [dependencies](https://docs.gitlab.com/ci/yaml/#dependencies)in the same job.\n\n* * *",
					"tokensEstimate": 313,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_92",
					"content": "##### `needs:project`\n\n- Tier: Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nUse `needs:project` to download artifacts from up to five jobs in other pipelines. The artifacts are downloaded from the latest successful specified job for the specified ref. To specify multiple jobs, add each as separate array items under the `needs` keyword.\n\nIf there is a pipeline running for the ref, a job with `needs:project` does not wait for the pipeline to complete. Instead, the artifacts are downloaded from the latest successful run of the specified job.\n\n`needs:project` must be used with `job`, `ref`, and `artifacts`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `needs:project`: A full project path, including namespace and group.- `job`: The job to download artifacts from.- `ref`: The ref to download artifacts from.- `artifacts`: Must be `true`to download artifacts.\n\n**Examples of `needs:project`**:\n\n```python\nbuild_job:\nstage: build\nscript:\n - ls -lhR\nneeds:\n - project: namespace/group/project-name\njob: build-1\nref: main\nartifacts: true\n - project: namespace/group/project-name-2\njob: build-2\nref: main\nartifacts: true\n```\n\nIn this example, `build_job` downloads the artifacts from the latest successful `build-1` and `build-2` jobs on the `main` branches in the `group/project-name` and `group/project-name-2` projects.\n\nYou can use [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file) in `needs:project`, for example:\n\n```python\nbuild_job:\nstage: build\nscript:\n - ls -lhR\nneeds:\n - project: $CI_PROJECT_PATH\njob: $DEPENDENCY_JOB_NAME\nref: $ARTIFACTS_DOWNLOAD_REF\nartifacts: true\n```\n\n**Additional details**:\n\n- To download artifacts from a different pipeline in the current project, set `project`to be the same as the current project, but use a different ref than the current pipeline. Concurrent pipelines running on the same ref could override the artifacts.- The user running the pipeline must have at least the Reporter role for the group or project, or the group/project must have public visibility.- You can’t use `needs:project`in the same job as [trigger](https://docs.gitlab.com/ci/yaml/#trigger).- When using `needs:project`to download artifacts from another pipeline, the job does not wait for the needed job to complete. [Using needs to wait for jobs to complete](https://docs.gitlab.com/ci/yaml/needs/)is limited to jobs in the same pipeline. Make sure that the needed job in the other pipeline completes before the job that needs it tries to download the artifacts.- You can’t download artifacts from jobs that run in [parallel](https://docs.gitlab.com/ci/yaml/#parallel).- Support [CI/CD variables](https://docs.gitlab.com/ci/variables/)in `project`, `job`, and `ref`.\n\n**Related topics**:\n\n- To download artifacts between [parent-child pipelines](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines), use [needs:pipeline:job](https://docs.gitlab.com/ci/yaml/#needspipelinejob).\n\n* * *",
					"tokensEstimate": 762,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_93",
					"content": "##### `needs:pipeline:job`\n\nA [child pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines) can download artifacts from a successfully finished job in its parent pipeline or another child pipeline in the same parent-child pipeline hierarchy.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `needs:pipeline`: A pipeline ID. Must be a pipeline present in the same parent-child pipeline hierarchy.- `job`: The job to download artifacts from.\n\n**Example of `needs:pipeline:job`**:\n\n- Parent pipeline (`.gitlab-ci.yml`): ```python\nstages:\n - build\n - test\n\ncreate-artifact:\nstage: build\nscript: echo \"sample artifact\" > artifact.txt\nartifacts:\npaths: [artifact.txt]\n\nchild-pipeline:\nstage: test\ntrigger:\ninclude: child.yml\nstrategy: mirror\nvariables:\nPARENT_PIPELINE_ID: $CI_PIPELINE_ID\n```- Child pipeline (`child.yml`): ```python\nuse-artifact:\nscript: cat artifact.txt\nneeds:\n - pipeline: $PARENT_PIPELINE_ID\njob: create-artifact\n```\n\nIn this example, the `create-artifact` job in the parent pipeline creates some artifacts. The `child-pipeline` job triggers a child pipeline, and passes the `CI_PIPELINE_ID` variable to the child pipeline as a new `PARENT_PIPELINE_ID` variable. The child pipeline can use that variable in `needs:pipeline` to download artifacts from the parent pipeline. Having the `create-artifact` and `child-pipeline` jobs in subsequent stages ensures that the `use-artifact` job only executes when `create-artifact` has successfully finished.\n\n**Additional details**:\n\n- The `pipeline`attribute does not accept the current pipeline ID ( `$CI_PIPELINE_ID`). To download artifacts from a job in the current pipeline, use [needs:artifacts](https://docs.gitlab.com/ci/yaml/#needsartifacts).- You cannot use `needs:pipeline:job`in a [trigger job](https://docs.gitlab.com/ci/yaml/#trigger), or to fetch artifacts from a [multi-project pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#multi-project-pipelines). To fetch artifacts from a multi-project pipeline use [needs:project](https://docs.gitlab.com/ci/yaml/#needsproject).- The job listed in `needs:pipeline:job`must complete with a status of `success`or the artifacts can’t be fetched. [Issue 367229](https://gitlab.com/gitlab-org/gitlab/-/issues/367229)proposes to allow fetching artifacts from any job with artifacts.\n\n* * *",
					"tokensEstimate": 597,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_94",
					"content": "##### `needs:optional`\n\nTo need a job that sometimes does not exist in the pipeline, add `optional: true` to the `needs` configuration. If not defined, `optional: false` is the default.\n\nJobs that use [`rules`](https://docs.gitlab.com/ci/yaml/#rules), [`only`, or `except`](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#only--except) and that are added with [`include`](https://docs.gitlab.com/ci/yaml/#include) might not always be added to a pipeline. GitLab checks the `needs` relationships before starting a pipeline:\n\n- If the `needs`entry has `optional: true`and the needed job is present in the pipeline, the job waits for it to complete before starting.- If the needed job is not present, the job can start when all other needs requirements are met.- If the `needs`section contains only optional jobs, and none are added to the pipeline, the job starts immediately (the same as an empty `needs`entry: `needs: []`).- If a needed job has `optional: false`, but it was not added to the pipeline, the pipeline fails to start with an error similar to: `'job1' job needs 'job2' job, but it was not added to the pipeline`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Example of `needs:optional`**:\n\n```python\nbuild-job:\nstage: build\n\ntest-job1:\nstage: test\n\ntest-job2:\nstage: test\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\n\ndeploy-job:\nstage: deploy\nneeds:\n - job: test-job2\noptional: true\n - job: test-job1\nenvironment: production\n\nreview-job:\nstage: deploy\nneeds:\n - job: test-job2\noptional: true\nenvironment: review\n```\n\nIn this example:\n\n- `build-job`, `test-job1`, and `test-job2`start in stage order.- When the branch is the default branch, `test-job2`is added to the pipeline, so:\n - `deploy-job`waits for both `test-job1`and `test-job2`to complete.- `review-job`waits for `test-job2`to complete.- When the branch is not the default branch, `test-job2`is not added to the pipeline, so:\n - `deploy-job`waits for only `test-job1`to complete, and does not wait for the missing `test-job2`.- `review-job`has no other needed jobs and starts immediately (at the same time as `build-job`), like `needs: []`.\n\n* * *",
					"tokensEstimate": 536,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_95",
					"content": "##### `needs:pipeline`\n\nYou can mirror the pipeline status from an upstream pipeline to a job by using the `needs:pipeline` keyword. The latest pipeline status from the default branch is replicated to the job.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A full project path, including namespace and group. If the project is in the same group or namespace, you can omit them from the `project`keyword. For example: `project: group/project-name`or `project: project-name`.\n\n**Example of `needs:pipeline`**:\n\n```python\nupstream_status:\nstage: test\nneeds:\npipeline: other/project\n```\n\n**Additional details**:\n\n- If you add the `job`keyword to `needs:pipeline`, the job no longer mirrors the pipeline status. The behavior changes to [needs:pipeline:job](https://docs.gitlab.com/ci/yaml/#needspipelinejob).\n\n* * *",
					"tokensEstimate": 213,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_96",
					"content": "##### `needs:parallel:matrix`\n\nJobs can use [`parallel:matrix`](https://docs.gitlab.com/ci/yaml/#parallelmatrix) to run a job multiple times in parallel in a single pipeline, but with different variable values for each instance of the job.\n\nUse `needs:parallel:matrix` to execute jobs out-of-order depending on parallelized jobs.\n\n**Keyword type**: Job keyword. You can use it only as part of a job. Must be used with `needs:job`.\n\n**Supported values**: An array of hashes of matrix identifiers:\n\n- The identifiers and values must be selected from the identifiers and values defined in the `parallel:matrix`job.- You can use [matrix expressions](https://docs.gitlab.com/ci/yaml/matrix_expressions/).\n\n**Example of `needs:parallel:matrix`**:\n\n```python\nlinux:build:\nstage: build\nscript: echo \"Building linux...\"\nparallel:\nmatrix:\n - PROVIDER: aws\nSTACK:\n - monitoring\n - app1\n - app2\n\nlinux:rspec:\nstage: test\nneeds:\n - job: linux:build\nparallel:\nmatrix:\n - PROVIDER: aws\nSTACK: app1\nscript: echo \"Running rspec on linux...\"\n```\n\nThe previous example generates the following jobs:\n\n```text\nlinux:build: [aws, monitoring]\nlinux:build: [aws, app1]\nlinux:build: [aws, app2]\nlinux:rspec\n```\n\nThe `linux:rspec` job runs as soon as the `linux:build: [aws, app1]` job finishes.\n\n**Additional details**:\n\n- The order of the matrix identifiers in `needs:parallel:matrix` must match the order of the matrix variables in the needed job. For example, reversing the order of the variables in the `linux:rspec` job in the previous example would be invalid: ```python\nlinux:rspec:\nstage: test\nneeds:\n - job: linux:build\nparallel:\nmatrix:\n - STACK: app1 # The variable order does not match `linux:build` and is invalid.\nPROVIDER: aws\nscript: echo \"Running rspec on linux...\"\n```\n\n**Related topics**:\n\n- [Specify a parallelized job using needs with multiple parallelized jobs](https://docs.gitlab.com/ci/jobs/job_control/#specify-a-parallelized-job-using-needs-with-multiple-parallelized-jobs).- [Matrix expressions in needs:parallel:matrix](https://docs.gitlab.com/ci/yaml/matrix_expressions/#matrix-expressions-in-needsparallelmatrix).",
					"tokensEstimate": 524,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_97",
					"content": "#### `pages`\n\nUse `pages` to define a [GitLab Pages](https://docs.gitlab.com/user/project/pages/) job that uploads static content to GitLab. The content is then published as a website.\n\nYou must:\n\n- Define `pages: true`to publish a directory named `public`- Alternatively, define [pages.publish](https://docs.gitlab.com/ci/yaml/#pagespublish)if want to use a different content directory.- Have a non-empty `index.html`file in the root of the content directory.\n\n**Keyword type**: Job keyword or Job name (deprecated). You can use it only as part of a job.\n\n**Supported Values**:\n\n- A boolean. Uses the default configuration when set to `true`- A hash of configuration options, see the following sections for details.\n\n**Example of `pages`**:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - mv my-html-content public\npages: true # specifies that this is a Pages job and publishes the default public directory\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nenvironment: production\n```\n\nThis example renames the `my-html-content/` directory to `public/`. This directory is exported as an artifact and published with GitLab Pages.\n\n**Example using a configuration hash**:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - echo \"nothing to do here\"\npages: # specifies that this is a Pages job and publishes the default public directory\npublish: my-html-content\nexpire_in: \"1 week\"\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nenvironment: production\n```\n\nThis example does not move the directory, but uses the `publish` property directly. It also configures the pages deployment to be unpublished after a week.\n\n**Additional details**:\n\n- Using `pages`as a job name [is deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#publish-keyword-and-pages-job-name-for-gitlab-pages).- To use `pages`as a job name without triggering a Pages deployment, set the `pages`property to false\n\n* * *",
					"tokensEstimate": 473,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_98",
					"content": "##### `pages.publish`\n\nUse `pages.publish` to configure the content directory of a [`pages` job](https://docs.gitlab.com/ci/yaml/#pages).\n\n**Keyword type**: Job keyword. You can use it only as part of a `pages` job.\n\n**Supported values**: A path to a directory containing the Pages content. In [GitLab 17.10 and later](https://gitlab.com/gitlab-org/gitlab/-/issues/428018), if not specified, the default `public` directory is used and if specified, this path is automatically appended to [`artifacts:paths`](https://docs.gitlab.com/ci/yaml/#artifactspaths).\n\n**Example of `pages.publish`**:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - npx @11ty/eleventy --input=path/to/eleventy/root --output=dist\npages:\npublish: dist # this path is automatically appended to artifacts:paths\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nenvironment: production\n```\n\nThis example uses [Eleventy](https://www.11ty.dev/) to generate a static website and output the generated HTML files into a the `dist/` directory. This directory is exported as an artifact and published with GitLab Pages.\n\nIt is also possible to use variables in the `pages.publish` field. For example:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - mkdir -p $CUSTOM_FOLDER/$CUSTOM_PATH\n - cp -r public $CUSTOM_FOLDER/$CUSTOM_SUBFOLDER\npages:\npublish: $CUSTOM_FOLDER/$CUSTOM_SUBFOLDER # this path is automatically appended to artifacts:paths\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nvariables:\nCUSTOM_FOLDER: \"custom_folder\"\nCUSTOM_SUBFOLDER: \"custom_subfolder\"\n```\n\nThe publish path specified must be relative to the build root.\n\n**Additional details**:\n\n- The top-level `publish`keyword [is deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#publish-keyword-and-pages-job-name-for-gitlab-pages)and must now be nested under the `pages`keyword\n\n* * *",
					"tokensEstimate": 457,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_99",
					"content": "##### `pages.path_prefix`\n\n- Tier: Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated- Status: Beta\n\nUse `pages.path_prefix` to configure a path prefix for [parallel deployments](https://docs.gitlab.com/user/project/pages/#parallel-deployments) of GitLab Pages.\n\n**Keyword type**: Job keyword. You can use it only as part of a `pages` job.\n\n**Supported values**:\n\n- A string- [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file)- A combination of both\n\nThe given value is converted to lowercase and shortened to 63 bytes. Everything except alphanumeric characters or periods is replaced with a hyphen. Leading and trailing hyphens or periods are not permitted.\n\n**Example of `pages.path_prefix`**:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - echo \"Pages accessible through ${CI_PAGES_URL}\"\npages: # specifies that this is a Pages job and publishes the default public directory\npath_prefix: \"$CI_COMMIT_BRANCH\"\n```\n\nIn this example, a different pages deployment is created for each branch.\n\n* * *",
					"tokensEstimate": 267,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_100",
					"content": "##### `pages.expire_in`\n\n- Tier: Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nUse `expire_in` to specify how long a deployment should be available before it expires. After the deployment is expired, it’s deactivated by a cron job running every 10 minutes.\n\nBy default, [parallel deployments](https://docs.gitlab.com/user/project/pages/#parallel-deployments) expire automatically after 24 hours. To disable this behavior, set the value to `never`.\n\n**Keyword type**: Job keyword. You can use it only as part of a `pages` job.\n\n**Supported values**: The expiry time. If no unit is provided, the time is in seconds. Variables are also supported. Valid values include:\n\n- `'42'`- `42 seconds`- `3 mins 4 sec`- `2 hrs 20 min`- `2h20min`- `6 mos 1 day`- `47 yrs 6 mos and 4d`- `3 weeks and 2 days`- `never`- `$DURATION`\n\n**Example of `pages.expire_in`**:\n\n```python\ncreate-pages:\nstage: deploy\nscript:\n - echo \"Pages accessible through ${CI_PAGES_URL}\"\npages: # specifies that this is a Pages job and publishes the default public directory\nexpire_in: 1 week\n```\n\n* * *",
					"tokensEstimate": 272,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_101",
					"content": "#### `parallel`\n\nUse `parallel` to run a job multiple times in parallel in a single pipeline.\n\nMultiple runners must exist, or a single runner must be configured to run multiple jobs concurrently.\n\nParallel jobs are named sequentially from `job_name 1/N` to `job_name N/N`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A numeric value from `1`to `200`.\n\n**Example of `parallel`**:\n\n```python\ntest:\nscript: rspec\nparallel: 5\n```\n\nThis example creates 5 jobs that run in parallel, named `test 1/5` to `test 5/5`.\n\n**Additional details**:\n\n- Every parallel job has a `CI_NODE_INDEX`and `CI_NODE_TOTAL` [predefined CI/CD variable](https://docs.gitlab.com/ci/variables/#predefined-cicd-variables)set.- A pipeline with jobs that use `parallel`might:\n - Create more jobs running in parallel than available runners. Excess jobs are queued and marked `pending`while waiting for an available runner.- Fail with a `job_activity_limit_exceeded`error if creating the pipeline would cause the total number of jobs across all active pipelines to [exceed the instance limit](https://docs.gitlab.com/administration/instance_limits/#number-of-jobs-in-active-pipelines).\n\n**Related topics**:\n\n- [Parallelize large jobs](https://docs.gitlab.com/ci/jobs/job_control/#parallelize-large-jobs).\n\n* * *",
					"tokensEstimate": 329,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_102",
					"content": "##### `parallel:matrix`\n\nUse `parallel:matrix` to run a job multiple times in parallel in a single pipeline, but with different variable values for each instance of the job.\n\nMultiple runners must exist, or a single runner must be configured to run multiple jobs concurrently.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: An array of hashes of variables:\n\n- The matrix identifiers, which become the variable names, can use only numbers, letters, and underscores ( `_`).- The values must be either a string, or an array of strings.- The number of permutations cannot exceed 200.\n\n**Example of `parallel:matrix`**:\n\n```python\ndeploystacks:\nstage: deploy\nscript:\n - bin/deploy\nparallel:\nmatrix:\n - PROVIDER: aws\nSTACK:\n - monitoring\n - app1\n - app2\n - PROVIDER: [gcp, vultr]\nSTACK: [data, processing]\nenvironment: $PROVIDER/$STACK\n```\n\nThe example generates 7 parallel `deploystacks` jobs, each with different values for `PROVIDER` and `STACK`:\n\n- `deploystacks: [aws, monitoring]`- `deploystacks: [aws, app1]`- `deploystacks: [aws, app2]`- `deploystacks: [gcp, data]`- `deploystacks: [gcp, processing]`- `deploystacks: [vultr, data]`- `deploystacks: [vultr, processing]`\n\n**Additional details**:\n\n- `parallel:matrix` jobs add the matrix values to the job names to differentiate the jobs from each other, but [large values can cause names to exceed limits](https://gitlab.com/gitlab-org/gitlab/-/issues/362262):\n - [Job names](https://docs.gitlab.com/ci/jobs/#job-names)must be 255 characters or fewer.- When using [needs](https://docs.gitlab.com/ci/yaml/#needs), job names must be 128 characters or fewer.- You cannot use the matrix values as variables for [`rules:if`](https://docs.gitlab.com/ci/yaml/#rulesif).- You cannot create multiple matrix configurations with the same values but different names. Job names are generated from the matrix values, not the names, so matrix entries with identical values generate identical job names that overwrite each other. For example, this `test` configuration would try to create two series of identical jobs, but the `OS2` versions overwrite the `OS` versions: ```python\ntest:\nparallel:\nmatrix:\n - OS: [ubuntu]\nPROVIDER: [aws, gcp]\n - OS2: [ubuntu]\nPROVIDER: [aws, gcp]\n```\n\n**Related topics**:\n\n- [Run a one-dimensional matrix of parallel jobs](https://docs.gitlab.com/ci/jobs/job_control/#run-a-one-dimensional-matrix-of-parallel-jobs).- [Run a matrix of triggered parallel jobs](https://docs.gitlab.com/ci/jobs/job_control/#run-a-matrix-of-parallel-trigger-jobs).- [Select different runner tags for each parallel matrix job](https://docs.gitlab.com/ci/jobs/job_control/#select-different-runner-tags-for-each-parallel-matrix-job).- [Matrix expressions in needs:parallel:matrix](https://docs.gitlab.com/ci/yaml/matrix_expressions/#matrix-expressions-in-needsparallelmatrix).\n\n* * *",
					"tokensEstimate": 713,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_103",
					"content": "#### `release`\n\nUse `release` to create a [release](https://docs.gitlab.com/user/project/releases/).\n\nThe release job must have access to the [`glab` CLI](https://gitlab.com/gitlab-org/cli), which must be in the `$PATH`.\n\nIf you use the [Docker executor](https://docs.gitlab.com/runner/executors/docker.html), you can use this image from the GitLab container registry: `registry.gitlab.com/gitlab-org/cli:latest`\n\nIf you use the [Shell executor](https://docs.gitlab.com/runner/executors/shell.html) or similar, [install `glab` CLI](https://gitlab.com/gitlab-org/cli#installation) on the server where the runner is registered.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: The `release` subkeys:\n\n- [tag_name](https://docs.gitlab.com/ci/yaml/#releasetag_name)\n- [tag_message](https://docs.gitlab.com/ci/yaml/#releasetag_message)(optional)- [name](https://docs.gitlab.com/ci/yaml/#releasename)(optional)- [description](https://docs.gitlab.com/ci/yaml/#releasedescription)\n- [ref](https://docs.gitlab.com/ci/yaml/#releaseref)(optional)- [milestones](https://docs.gitlab.com/ci/yaml/#releasemilestones)(optional)- [released_at](https://docs.gitlab.com/ci/yaml/#releasereleased_at)(optional)- [assets:links](https://docs.gitlab.com/ci/yaml/#releaseassetslinks)(optional)\n\n**Example of `release` keyword**:\n\n```python\nrelease_job:\nstage: release\nimage: registry.gitlab.com/gitlab-org/cli:latest\nrules:\n - if: $CI_COMMIT_TAG # Run this job when a tag is created manually\nscript:\n - echo \"Running the release job.\"\nrelease:\ntag_name: $CI_COMMIT_TAG\nname: 'Release $CI_COMMIT_TAG'\ndescription: 'Release created using the CLI.'\n```\n\nThis example creates a release:\n\n- When you push a Git tag.- When you add a Git tag in the UI at **Code**> **Tags**.\n\n**Additional details**:\n\n- All release jobs, except [trigger](https://docs.gitlab.com/ci/yaml/#trigger) jobs, must include the `script` keyword. A release job can use the output from script commands. If you don’t need the script, you can use a placeholder: ```python\nscript:\n - echo \"release job\"\n``` An [issue](https://gitlab.com/gitlab-org/gitlab/-/issues/223856) exists to remove this requirement.- The `release` section executes after the `script` keyword and before the `after_script`.- A release is created only if the job’s main script succeeds.- If the release already exists, it is not updated and the job with the `release` keyword fails.\n\n**Related topics**:\n\n- [CI/CD example of the release keyword](https://docs.gitlab.com/user/project/releases/#creating-a-release-by-using-a-cicd-job).- [Create multiple releases in a single pipeline](https://docs.gitlab.com/user/project/releases/#create-multiple-releases-in-a-single-pipeline).- [Use a custom SSL CA certificate authority](https://docs.gitlab.com/user/project/releases/#use-a-custom-ssl-ca-certificate-authority).\n\n* * *",
					"tokensEstimate": 714,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_104",
					"content": "##### `release:tag_name`\n\nRequired. The Git tag for the release.\n\nIf the tag does not exist in the project yet, it is created at the same time as the release. New tags use the SHA associated with the pipeline.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A tag name.\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `release:tag_name`**:\n\nTo create a release when a new tag is added to the project:\n\n- Use the `$CI_COMMIT_TAG`CI/CD variable as the `tag_name`.- Use [rules:if](https://docs.gitlab.com/ci/yaml/#rulesif)to configure the job to run only for new tags.\n\n```python\njob:\nscript: echo \"Running the release job for the new tag.\"\nrelease:\ntag_name: $CI_COMMIT_TAG\ndescription: 'Release description'\nrules:\n - if: $CI_COMMIT_TAG\n```\n\nTo create a release and a new tag at the same time, your [`rules`](https://docs.gitlab.com/ci/yaml/#rules) should **not** configure the job to run only for new tags. A semantic versioning example:\n\n```python\njob:\nscript: echo \"Running the release job and creating a new tag.\"\nrelease:\ntag_name: ${MAJOR}_${MINOR}_${REVISION}\ndescription: 'Release description'\nrules:\n - if: $CI_PIPELINE_SOURCE == \"schedule\"\n```\n\n* * *",
					"tokensEstimate": 320,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_105",
					"content": "##### `release:tag_message`\n\nIf the tag does not exist, the newly created tag is annotated with the message specified by `tag_message`. If omitted, a lightweight tag is created.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A text string.\n\n**Example of `release:tag_message`**:\n\n```python\nrelease_job:\nstage: release\nrelease:\ntag_name: $CI_COMMIT_TAG\ndescription: 'Release description'\ntag_message: 'Annotated tag message'\n```\n\n* * *\n\n##### `release:name`\n\nThe release name. If omitted, it is populated with the value of `release: tag_name`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A text string.\n\n**Example of `release:name`**:\n\n```python\nrelease_job:\nstage: release\nrelease:\nname: 'Release $CI_COMMIT_TAG'\n```\n\n* * *",
					"tokensEstimate": 203,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_106",
					"content": "##### `release:description`\n\nThe long description of the release.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A string with the long description.- The path to a file that contains the description.\n - The file location must be relative to the project directory ( `$CI_PROJECT_DIR`).- If the file is a symbolic link, it must be in the `$CI_PROJECT_DIR`.- The `./path/to/file`and filename can’t contain spaces.\n\n**Example of `release:description`**:\n\n```python\njob:\nrelease:\ntag_name: ${MAJOR}_${MINOR}_${REVISION}\ndescription: './path/to/CHANGELOG.md'\n```\n\n**Additional details**:\n\n- The `description`is evaluated by the shell that runs `glab`. You can use CI/CD variables to define the description, but some shells [use different syntax](https://docs.gitlab.com/ci/variables/job_scripts/)to reference variables. Similarly, some shells might require special characters to be escaped. For example, backticks ( `` ` ``) might need to be escaped with a backslash ( `\\`).\n\n* * *\n\n##### `release:ref`\n\nThe `ref` for the release, if the `release: tag_name` doesn’t exist yet.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A commit SHA, another tag name, or a branch name.\n\n* * *\n\n##### `release:milestones`\n\nThe title of each milestone the release is associated with.\n\n* * *\n\n##### `release:released_at`\n\nThe date and time when the release is ready.\n\n**Supported values**:\n\n- A date enclosed in quotes and expressed in ISO 8601 format.\n\n**Example of `release:released_at`**:\n\n```text\nreleased_at: '2021-03-15T08:00:00Z'\n```\n\n**Additional details**:\n\n- If it is not defined, the current date and time is used.\n\n* * *",
					"tokensEstimate": 421,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_107",
					"content": "##### `release:assets:links`\n\nUse `release:assets:links` to include [asset links](https://docs.gitlab.com/user/project/releases/release_fields/#release-assets) in the release.\n\n**Example of `release:assets:links`**:\n\n```python\nassets:\nlinks:\n - name: 'asset1'\nurl: 'https://example.com/assets/1'\n - name: 'asset2'\nurl: 'https://example.com/assets/2'\nfilepath: '/pretty/url/1' # optional\nlink_type: 'other' # optional\n```\n\n* * *",
					"tokensEstimate": 106,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_108",
					"content": "#### `resource_group`\n\nUse `resource_group` to create a [resource group](https://docs.gitlab.com/ci/resource_groups/) that ensures a job is mutually exclusive across different pipelines for the same project.\n\nFor example, if multiple jobs that belong to the same resource group are queued simultaneously, only one of the jobs starts. The other jobs wait until the `resource_group` is free.\n\nResource groups behave similar to semaphores in other programming languages.\n\nYou can choose a [process mode](https://docs.gitlab.com/ci/resource_groups/#process-modes) to strategically control the job concurrency for your deployment preferences. The default process mode is `unordered`. To change the process mode of a resource group, use the [API](https://docs.gitlab.com/api/resource_groups/#edit-an-existing-resource-group) to send a request to edit an existing resource group.\n\nYou can define multiple resource groups per environment. For example, when deploying to physical devices, you might have multiple physical devices. Each device can be deployed to, but only one deployment can occur per device at any given time.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- Only letters, digits, `-`, `_`, `/`, `$`, `{`, `}`, `.`, and spaces. It can’t start or end with `/`. CI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `resource_group`**:\n\n```python\ndeploy-to-production:\nscript: deploy\nresource_group: production\n```\n\nIn this example, two `deploy-to-production` jobs in two separate pipelines can never run at the same time. As a result, you can ensure that concurrent deployments never happen to the production environment.\n\n**Related topics**:\n\n- [Pipeline-level concurrency control with cross-project/parent-child pipelines](https://docs.gitlab.com/ci/resource_groups/#pipeline-level-concurrency-control-with-cross-projectparent-child-pipelines).\n\n* * *",
					"tokensEstimate": 493,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_109",
					"content": "#### `retry`\n\nUse `retry` to configure how many times a job is retried if it fails. If not defined, defaults to `0` and jobs do not retry.\n\nWhen a job fails, the job is processed up to two more times, until it succeeds or reaches the maximum number of retries.\n\nBy default, all failure types cause the job to be retried. Use [`retry:when`](https://docs.gitlab.com/ci/yaml/#retrywhen) or [`retry:exit_codes`](https://docs.gitlab.com/ci/yaml/#retryexit_codes) to select which failures to retry on.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- `0`(default), `1`, or `2`.\n\n**Example of `retry`**:\n\n```python\ntest:\nscript: rspec\nretry: 2\n\ntest_advanced:\nscript:\n - echo \"Run a script that results in exit code 137.\"\n - exit 137\nretry:\nmax: 2\nwhen: runner_system_failure\nexit_codes: 137\n```\n\n`test_advanced` will be retried up to 2 times if the exit code is `137` or if it had a runner system failure.\n\n* * *",
					"tokensEstimate": 253,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_110",
					"content": "##### `retry:when`\n\nUse `retry:when` with `retry:max` to retry jobs for only specific failure cases. `retry:max` is the maximum number of retries, like [`retry`](https://docs.gitlab.com/ci/yaml/#retry), and can be `0`, `1`, or `2`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A single failure type, or an array of one or more failure types:\n\n- `always`: Retry on any failure (default).- `unknown_failure`: Retry when the failure reason is unknown.- `script_failure`: Retry when:\n - The script failed.- The runner failed to pull the Docker image. For `docker`, `docker+machine`, `kubernetes` [executors](https://docs.gitlab.com/runner/executors/).- `api_failure`: Retry on API failure.- `stuck_or_timeout_failure`: Retry when the job got stuck or timed out.- `runner_system_failure`: Retry if there is a runner system failure (for example, job setup failed).- `runner_unsupported`: Retry if the runner is unsupported.- `stale_schedule`: Retry if a delayed job could not be executed.- `job_execution_timeout`: Retry if the script exceeded the maximum execution time set for the job.- `archived_failure`: Retry if the job is archived and can’t be run.- `unmet_prerequisites`: Retry if the job failed to complete prerequisite tasks.- `scheduler_failure`: Retry if the scheduler failed to assign the job to a runner.- `data_integrity_failure`: Retry if there is an unknown job problem.\n\n**Example of `retry:when`** (single failure type):\n\n```python\ntest:\nscript: rspec\nretry:\nmax: 2\nwhen: runner_system_failure\n```\n\nIf there is a failure other than a runner system failure, the job is not retried.\n\n**Example of `retry:when`** (array of failure types):\n\n```python\ntest:\nscript: rspec\nretry:\nmax: 2\nwhen:\n - runner_system_failure\n - stuck_or_timeout_failure\n```\n\n* * *",
					"tokensEstimate": 468,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_111",
					"content": "##### `retry:exit_codes`\n\nUse `retry:exit_codes` with `retry:max` to retry jobs for only specific failure cases. `retry:max` is the maximum number of retries, like [`retry`](https://docs.gitlab.com/ci/yaml/#retry), and can be `0`, `1`, or `2`.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A single exit code.- An array of exit codes.\n\n**Example of `retry:exit_codes`**:\n\n```python\ntest_job_1:\nscript:\n - echo \"Run a script that results in exit code 1. This job isn't retried.\"\n - exit 1\nretry:\nmax: 2\nexit_codes: 137\n\ntest_job_2:\nscript:\n - echo \"Run a script that results in exit code 137. This job will be retried.\"\n - exit 137\nretry:\nmax: 1\nexit_codes:\n - 255\n - 137\n```\n\n**Related topics**:\n\nYou can specify the number of [retry attempts for certain stages of job execution](https://docs.gitlab.com/ci/runners/configure_runners/#job-stages-attempts) using variables.\n\n* * *",
					"tokensEstimate": 246,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_112",
					"content": "#### `rules`\n\nUse `rules` to include or exclude jobs in pipelines.\n\nRules are evaluated when the pipeline is created, and evaluated in order. When a match is found, no more rules are checked and the job is either included or excluded from the pipeline depending on the configuration. If no rules match, the job is not added to the pipeline.\n\n`rules` accepts an array of rules. Each rules must have at least one of:\n\n- `if`- `changes`- `exists`- `when`\n\nRules can also optionally be combined with:\n\n- `allow_failure`- `needs`- `variables`- `interruptible`\n\nYou can combine multiple keywords together for [complex rules](https://docs.gitlab.com/ci/jobs/job_rules/#complex-rules).\n\nThe job is added to the pipeline:\n\n- If an `if`, `changes`, or `exists`rule matches, and is configured with `when: on_success`(default if not defined), `when: delayed`, or `when: always`.- If a rule is reached that is only `when: on_success`, `when: delayed`, or `when: always`.\n\nThe job is not added to the pipeline:\n\n- If no rules match.- If a rule matches and has `when: never`.\n\nFor additional examples, see [Specify when jobs run with `rules`](https://docs.gitlab.com/ci/jobs/job_rules/).\n\n* * *",
					"tokensEstimate": 292,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_113",
					"content": "##### `rules:if`\n\nUse `rules:if` clauses to specify when to add a job to a pipeline:\n\n- If an `if`statement is true, add the job to the pipeline.- If an `if`statement is true, but it’s combined with `when: never`, do not add the job to the pipeline.- If an `if`statement is false, check the next `rules`item (if any more exist).\n\n`if` clauses are evaluated:\n\n- Based on the values of [CI/CD variables](https://docs.gitlab.com/ci/variables/)or [predefined CI/CD variables](https://docs.gitlab.com/ci/variables/predefined_variables/), with [some exceptions](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).- In order, following [rules execution flow](https://docs.gitlab.com/ci/yaml/#rules).\n\n**Keyword type**: Job-specific and pipeline-specific. You can use it as part of a job to configure the job behavior, or with [`workflow`](https://docs.gitlab.com/ci/yaml/#workflow) to configure the pipeline behavior.\n\n**Supported values**:\n\n- A [CI/CD variable expression](https://docs.gitlab.com/ci/jobs/job_rules/#cicd-variable-expressions).\n\n**Example of `rules:if`**:\n\n```python\njob:\nscript: echo \"Hello, Rules!\"\nrules:\n - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^feature/ && $CI_MERGE_REQUEST_TARGET_BRANCH_NAME != $CI_DEFAULT_BRANCH\nwhen: never\n - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^feature/\nwhen: manual\nallow_failure: true\n - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME\n```\n\n**Additional details**:\n\n- You cannot use [nested variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#nested-variable-expansion)with `if`. See [issue 327780](https://gitlab.com/gitlab-org/gitlab/-/issues/327780)for more details.- If a rule matches and has no `when`defined, the rule uses the `when`defined for the job, which defaults to `on_success`if not defined.- You can [mix when at the job-level with when in rules](https://gitlab.com/gitlab-org/gitlab/-/issues/219437). `when`configuration in `rules`takes precedence over `when`at the job-level.- Unlike variables in [script](https://docs.gitlab.com/ci/variables/job_scripts/)sections, variables in rules expressions are always formatted as `$VARIABLE`.\n - You can use `rules:if`with `include`to [conditionally include other configuration files](https://docs.gitlab.com/ci/yaml/includes/#use-rules-with-include).- CI/CD variables on the right side of `=~`and `!~`expressions are [evaluated as regular expressions](https://docs.gitlab.com/ci/jobs/job_rules/#store-a-regular-expression-in-a-variable).\n\n**Related topics**:\n\n- [Common if expressions for rules](https://docs.gitlab.com/ci/jobs/job_rules/#common-if-clauses-with-predefined-variables).- [Avoid duplicate pipelines](https://docs.gitlab.com/ci/jobs/job_rules/#avoid-duplicate-pipelines).- [Use rules to run merge request pipelines](https://docs.gitlab.com/ci/pipelines/merge_request_pipelines/#configure-merge-request-pipelines).\n\n* * *",
					"tokensEstimate": 721,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_114",
					"content": "##### `rules:changes`\n\n\n\nUse `rules:changes` to specify when to add a job to a pipeline by checking for changes to specific files.\n\nFor new branch pipelines or when there is no Git `push` event, `rules: changes` always evaluates to true and the job always runs. Pipelines like tag pipelines, scheduled pipelines, and manual pipelines, all do **not** have a Git `push` event associated with them. To cover these cases, use [`rules: changes: compare_to`](https://docs.gitlab.com/ci/yaml/#ruleschangescompare_to) to specify the branch to compare against the pipeline ref.\n\nIf you do not use `compare_to`, you should use `rules: changes` only with [branch pipelines](https://docs.gitlab.com/ci/pipelines/pipeline_types/#branch-pipeline) or [merge request pipelines](https://docs.gitlab.com/ci/pipelines/merge_request_pipelines/), though `rules: changes` still evaluates to true when creating a new branch. With:\n\n- Merge request pipelines, `rules:changes`compares the changes with the target MR branch.- Branch pipelines, `rules:changes`compares the changes with the previous commit on the branch.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\nAn array including any number of:\n\n- Paths to files. The file paths can include [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).- Wildcard paths for:\n - Single directories, for example `path/to/directory/*`.- A directory and all its subdirectories, for example `path/to/directory/**/*`.- Wildcard [glob](https://en.wikipedia.org/wiki/Glob_%28programming%29)paths for all files with the same extension or multiple extensions, for example `*.md`or `path/to/directory/*.{rb,py,sh}`.- Wildcard paths to files in the root directory, or all directories, wrapped in double quotes. For example `\"*.json\"`or `\"**/*.json\"`.\n\n**Example of `rules:changes`**:\n\n```bash\ndocker build:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nchanges:\n - Dockerfile\nwhen: manual\nallow_failure: true\n\ndocker build alternative:\nvariables:\nDOCKERFILES_DIR: 'path/to/dockerfiles'\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nchanges:\n - $DOCKERFILES_DIR/**/*\n```\n\nIn this example:",
					"tokensEstimate": 578,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_115",
					"content": "- If the pipeline is a merge request pipeline, check `Dockerfile`and the files in `$DOCKERFILES_DIR/**/*`for changes.- If `Dockerfile`has changed, add the job to the pipeline as a manual job, and the pipeline continues running even if the job is not triggered ( `allow_failure: true`).- If a file in `$DOCKERFILES_DIR/**/*`has changed, add the job to the pipeline.- If no listed files have changed, do not add either job to any pipeline (same as `when: never`).\n\n**Additional details**:\n\n- Glob patterns are interpreted with Ruby’s [File.fnmatch](https://docs.ruby-lang.org/en/master/File.html#method-c-fnmatch)with the [flags](https://docs.ruby-lang.org/en/master/File/Constants.html#module-File::Constants-label-Filename+Globbing+Constants+-28File-3A-3AFNM_-2A-29) `File::FNM_PATHNAME | File::FNM_DOTMATCH | File::FNM_EXTGLOB`.- For performance reasons, GitLab performs a maximum of 50,000 checks against `changes`patterns or file paths. After the 50,000th check, rules with patterned globs always match. In other words, the `changes`rule always assumes a match when more than 50,000 files changed, or if there are fewer than 50,000 changed files but the `changes`rules are checked more than 50,000 times.- A maximum of 50 patterns or file paths can be defined per `rules:changes`section.- `changes`resolves to `true`if any of the matching files are changed (an `OR`operation).- For additional examples, see [Specify when jobs run with rules](https://docs.gitlab.com/ci/jobs/job_rules/).- You can use the `$`character for both variables and paths. For example, if the `$VAR`variable exists, its value is used. If it does not exist, the `$`is interpreted as being part of a path.- Do not use `./`, double slashes ( `//`), or any other kind of relative path. Paths are matched with exact string comparison, they are not evaluated like in a shell.\n\n**Related topics**:\n\n- [Jobs or pipelines can run unexpectedly when using rules: changes](https://docs.gitlab.com/ci/jobs/job_troubleshooting/#jobs-or-pipelines-run-unexpectedly-when-using-changes).\n\n* * *",
					"tokensEstimate": 512,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_116",
					"content": "###### `rules:changes:paths`\n\nUse `rules:changes` to specify that a job only be added to a pipeline when specific files are changed, and use `rules:changes:paths` to specify the files.\n\n`rules:changes:paths` is the same as using [`rules:changes`](https://docs.gitlab.com/ci/yaml/#ruleschanges) without any subkeys. All additional details and related topics are the same.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- Same as `rules:changes`.\n\n**Example of `rules:changes:paths`**:\n\n```python\ndocker-build-1:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nchanges:\n - Dockerfile\n\ndocker-build-2:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nchanges:\npaths:\n - Dockerfile\n```\n\nIn this example, both jobs have the same behavior.\n\n* * *",
					"tokensEstimate": 226,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_117",
					"content": "###### `rules:changes:compare_to`\n\nUse `rules:changes:compare_to` to specify which ref to compare against for changes to the files listed under [`rules:changes:paths`](https://docs.gitlab.com/ci/yaml/#ruleschangespaths).\n\n**Keyword type**: Job keyword. You can use it only as part of a job, and it must be combined with `rules:changes:paths`.\n\n**Supported values**:\n\n- A branch name, like `main`, `branch1`, or `refs/heads/branch1`.- A tag name, like `tag1`or `refs/tags/tag1`.- A commit SHA, like `2fg31ga14b`.\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `rules:changes:compare_to`**:\n\n```bash\ndocker build:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nchanges:\npaths:\n - Dockerfile\ncompare_to: 'refs/heads/branch1'\n```\n\nIn this example, the `docker build` job is only included when the `Dockerfile` has changed relative to `refs/heads/branch1` and the pipeline source is a merge request event.\n\n**Additional details**:\n\n- Using `compare_to`in some situation can cause unexpected results:\n - With [merged results pipelines](https://docs.gitlab.com/ci/pipelines/merged_results_pipelines/#troubleshooting), because the comparison base is an internal commit that GitLab creates.- In a forked project, see [issue 424584](https://gitlab.com/gitlab-org/gitlab/-/issues/424584).\n\n**Related topics**:\n\n- You can use `rules:changes:compare_to`to [skip a job if the branch is empty](https://docs.gitlab.com/ci/jobs/job_rules/#skip-jobs-if-the-branch-is-empty).\n\n* * *",
					"tokensEstimate": 400,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_118",
					"content": "##### `rules:exists`\n\nUse `exists` to run a job when certain files or directories exist in the repository.\n\n**Keyword type**: Job keyword. You can use it as part of a job or an [`include`](https://docs.gitlab.com/ci/yaml/#include).\n\n**Supported values**:\n\n- An array of file or directory paths. Paths are relative to the project directory ( `$CI_PROJECT_DIR`) and can’t directly link outside it. File paths can use glob patterns and [CI/CD variables](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `rules:exists`**:\n\n```python\njob1:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - exists:\n - Dockerfile\n\njob2:\nvariables:\nDOCKERPATH: \"**/Dockerfile\"\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - exists:\n - $DOCKERPATH\n```\n\nIn this example:\n\n- `job1`runs if a `Dockerfile`exists in the root directory of the repository.- `job2`runs if a `Dockerfile`exists anywhere in the repository.\n\n**Additional details**:\n\n- Glob patterns are interpreted with Ruby’s [File.fnmatch](https://docs.ruby-lang.org/en/master/File.html#method-c-fnmatch)with the [flags](https://docs.ruby-lang.org/en/master/File/Constants.html#module-File::Constants-label-Filename+Globbing+Constants+-28File-3A-3AFNM_-2A-29) `File::FNM_PATHNAME | File::FNM_DOTMATCH | File::FNM_EXTGLOB`.- For performance reasons, GitLab performs a maximum of 50,000 checks against `exists`patterns or file paths. After the 50,000th check, rules with patterned globs always match. In other words, the `exists`rule always assumes a match in projects with more than 50,000 files, or if there are fewer than 50,000 files but the `exists`rules are checked more than 50,000 times.\n - If there are multiple patterned globs, the limit is 50,000 divided by the number of globs. For example, a rule with 5 patterned globs has file limit of 10,000.- A maximum of 50 patterns or file paths can be defined per `rules:exists`section.- `exists`resolves to `true`if any of the listed files are found (an `OR`operation).- With job-level `rules:exists`, GitLab searches for the files in the project and ref that runs the pipeline. When using [include with rules:exists](https://docs.gitlab.com/ci/yaml/includes/#include-with-rulesexists), GitLab searches for the files or directories in the project and ref of the file that contains the `include`section. The project containing the `include`section can be different than the project running the pipeline when using:\n - [Nested includes](https://docs.gitlab.com/ci/yaml/includes/#use-nested-includes).- [Compliance pipelines](https://docs.gitlab.com/user/compliance/compliance_pipelines/).- `rules:exists`cannot search for the presence of [artifacts](https://docs.gitlab.com/ci/jobs/job_artifacts/), because `rules`evaluation happens before jobs run and artifacts are fetched.- To test the existence of a directory, the path must end with a forward slash (/)\n\n* * *",
					"tokensEstimate": 729,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_119",
					"content": "###### `rules:exists:paths`\n\n`rules:exists:paths` is the same as using [`rules:exists`](https://docs.gitlab.com/ci/yaml/#rulesexists) without any subkeys. All additional details are the same.\n\n**Keyword type**: Job keyword. You can use it as part of a job or an [`include`](https://docs.gitlab.com/ci/yaml/#include).\n\n**Supported values**:\n\n- An array of file paths.\n\n**Example of `rules:exists:paths`**:\n\n```python\ndocker-build-1:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nexists:\n - Dockerfile\n\ndocker-build-2:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - if: $CI_PIPELINE_SOURCE == \"merge_request_event\"\nexists:\npaths:\n - Dockerfile\n```\n\nIn this example, both jobs have the same behavior.\n\n* * *",
					"tokensEstimate": 195,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_120",
					"content": "###### `rules:exists:project`\n\nUse `rules:exists:project` to specify the location in which to search for the files listed under [`rules:exists:paths`](https://docs.gitlab.com/ci/yaml/#rulesexistspaths). Must be used with `rules:exists:paths`.\n\n**Keyword type**: Job keyword. You can use it as part of a job or an [`include`](https://docs.gitlab.com/ci/yaml/#include), and it must be combined with `rules:exists:paths`.\n\n**Supported values**:\n\n- `exists:project`: A full project path, including namespace and group.- `exists:ref`: Optional. The commit ref to use to search for the file. The ref can be a tag, branch name, or SHA. Defaults to the `HEAD`of the project when not specified.\n\n**Example of `rules:exists:project`**:\n\n```bash\ndocker build:\nscript: docker build -t my-image:$CI_COMMIT_REF_SLUG .\nrules:\n - exists:\npaths:\n - Dockerfile\nproject: my-group/my-project\nref: v1.0.0\n```\n\nIn this example, the `docker build` job is only included when the `Dockerfile` exists in the project `my-group/my-project` on the commit tagged with `v1.0.0`.\n\n* * *",
					"tokensEstimate": 261,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_121",
					"content": "##### `rules:when`\n\nUse `rules:when` alone or as part of another rule to control conditions for adding a job to a pipeline. `rules:when` is similar to [`when`](https://docs.gitlab.com/ci/yaml/#when), but with slightly different input options.\n\nIf a `rules:when` rule is not combined with `if`, `changes`, or `exists`, it always matches if reached when evaluating a job’s rules.\n\n**Keyword type**: Job-specific. You can use it only as part of a job.\n\n**Supported values**:\n\n- `on_success`(default): Run the job only when no jobs in earlier stages fail.- `on_failure`: Run the job only when at least one job in an earlier stage fails.- `never`: Don’t run the job regardless of the status of jobs in earlier stages.- `always`: Run the job regardless of the status of jobs in earlier stages.- `manual`: Add the job to the pipeline as a [manual job](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually). The default value for [allow_failure](https://docs.gitlab.com/ci/yaml/#allow_failure)changes to `false`.- `delayed`: Add the job to the pipeline as a [delayed job](https://docs.gitlab.com/ci/jobs/job_control/#run-a-job-after-a-delay).\n\n**Example of `rules:when`**:\n\n```python\njob1:\nrules:\n - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH\n - if: $CI_COMMIT_REF_NAME =~ /feature/\nwhen: delayed\n - when: manual\nscript:\n - echo\n```\n\nIn this example, `job1` is added to pipelines:\n\n- For the default branch, with `when: on_success`which is the default behavior when `when`is not defined.- For feature branches as a delayed job.- In all other cases as a manual job.\n\n**Additional details**:\n\n- When evaluating the status of jobs for `on_success`and `on_failure`:\n - Jobs with [allow_failure: true](https://docs.gitlab.com/ci/yaml/#allow_failure)in earlier stages are considered successful, even if they failed.- Skipped jobs in earlier stages, for example [manual jobs that have not been started](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually), are considered successful.- When using `rules:when: manual`to [add a manual job](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually):\n - [allow_failure](https://docs.gitlab.com/ci/yaml/#allow_failure)becomes `false`by default. This default is the opposite of using [when: manual](https://docs.gitlab.com/ci/yaml/#when)to add a manual job.- To achieve the same behavior as `when: manual`defined outside of `rules`, set [rules: allow_failure](https://docs.gitlab.com/ci/yaml/#rulesallow_failure)to `true`.\n\n* * *",
					"tokensEstimate": 634,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_122",
					"content": "##### `rules:allow_failure`\n\nUse [`allow_failure: true`](https://docs.gitlab.com/ci/yaml/#allow_failure) in `rules` to allow a job to fail without stopping the pipeline.\n\nYou can also use `allow_failure: true` with a manual job. The pipeline continues running without waiting for the result of the manual job. `allow_failure: false` combined with `when: manual` in rules causes the pipeline to wait for the manual job to run before continuing.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`or `false`. Defaults to `false`if not defined.\n\n**Example of `rules:allow_failure`**:\n\n```python\njob:\nscript: echo \"Hello, Rules!\"\nrules:\n - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == $CI_DEFAULT_BRANCH\nwhen: manual\nallow_failure: true\n```\n\nIf the rule matches, then the job is a manual job with `allow_failure: true`.\n\n**Additional details**:\n\n- The rule-level `rules:allow_failure`overrides the job-level [allow_failure](https://docs.gitlab.com/ci/yaml/#allow_failure), and only applies when the specific rule triggers the job.\n\n* * *",
					"tokensEstimate": 268,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_123",
					"content": "##### `rules:needs`\n\nUse `needs` in rules to update a job’s [`needs`](https://docs.gitlab.com/ci/yaml/#needs) for specific conditions. When a condition matches a rule, the job’s `needs` configuration is completely replaced with the `needs` in the rule.\n\n**Keyword type**: Job-specific. You can use it only as part of a job.\n\n**Supported values**:\n\n- An array of job names as strings.- A hash with a job name, optionally with additional attributes.- An empty array ( `[]`), to set the job needs to none when the specific condition is met.\n\n**Example of `rules:needs`**:\n\n```python\nbuild-dev:\nstage: build\nrules:\n - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\nscript: echo \"Feature branch, so building dev version...\"\n\nbuild-prod:\nstage: build\nrules:\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nscript: echo \"Default branch, so building prod version...\"\n\ntests:\nstage: test\nrules:\n - if: $CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH\nneeds: ['build-dev']\n - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH\nneeds: ['build-prod']\nscript: echo \"Running dev specs by default, or prod specs when default branch...\"\n```\n\nIn this example:\n\n- If the pipeline runs on a branch that is not the default branch, and therefore the rule matches the first condition, the `specs`job needs the `build-dev`job.- If the pipeline runs on the default branch, and therefore the rule matches the second condition, the `specs`job needs the `build-prod`job.\n\n**Additional details**:\n\n- `needs`in rules override any `needs`defined at the job-level. When overridden, the behavior is same as [job-level needs](https://docs.gitlab.com/ci/yaml/#needs).- `needs`in rules can accept [artifacts](https://docs.gitlab.com/ci/yaml/#needsartifacts)and [optional](https://docs.gitlab.com/ci/yaml/#needsoptional).\n\n* * *",
					"tokensEstimate": 439,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_124",
					"content": "##### `rules:variables`\n\nUse [`variables`](https://docs.gitlab.com/ci/yaml/#variables) in `rules` to define variables for specific conditions.\n\n**Keyword type**: Job-specific. You can use it only as part of a job.\n\n**Supported values**:\n\n- A hash of variables in the format `VARIABLE-NAME: value`.\n\n**Example of `rules:variables`**:\n\n```python\njob:\nvariables:\nDEPLOY_VARIABLE: \"default-deploy\"\nrules:\n - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH\nvariables: # Override DEPLOY_VARIABLE defined\nDEPLOY_VARIABLE: \"deploy-production\" # at the job level.\n - if: $CI_COMMIT_REF_NAME =~ /feature/\nvariables:\nIS_A_FEATURE: \"true\" # Define a new variable.\nscript:\n - echo \"Run script with $DEPLOY_VARIABLE as an argument\"\n - echo \"Run another script if $IS_A_FEATURE exists\"\n```\n\n* * *",
					"tokensEstimate": 192,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_125",
					"content": "##### `rules:interruptible`\n\nUse `interruptible` in rules to update a job’s [`interruptible`](https://docs.gitlab.com/ci/yaml/#interruptible) value for specific conditions.\n\n**Keyword type**: Job-specific. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`or `false`.\n\n**Example of `rules:interruptible`**:\n\n```python\njob:\nscript: echo \"Hello, Rules!\"\ninterruptible: true\nrules:\n - if: $CI_COMMIT_REF_NAME == $CI_DEFAULT_BRANCH\ninterruptible: false # Override interruptible defined at the job level.\n - when: on_success\n```\n\n**Additional details**:\n\n- The rule-level `rules:interruptible`overrides the job-level [interruptible](https://docs.gitlab.com/ci/yaml/#interruptible), and only applies when the specific rule triggers the job.\n\n* * *",
					"tokensEstimate": 188,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_126",
					"content": "#### `run`\n\n- Status: Experiment\n\nThis feature is available for testing, but not ready for production use.\n\nUse `run` to define a series of [steps](https://docs.gitlab.com/ci/steps/) to be executed in a job. Each step can be either a script or a predefined step.\n\nYou can also provide optional environment variables and inputs.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- An array of hashes, where each hash represents a step with the following possible keys:\n - `name`: A string representing the name of the step.- `script`: A string containing shell commands to execute.- `step`: A string identifying a predefined step to run.- `env`: Optional. A hash of environment variables specific to this step.- `inputs`: Optional. A hash of input parameters for predefined steps.\n\nEach array entry must have a `name`, and one `script` or `step` (but not both).\n\n**Example of `run`**:\n\n```python\njob:\nrun:\n - name: 'hello_steps'\nscript: 'echo \"hello from step1\"'\n - name: 'bye_steps'\nstep: gitlab.com/gitlab-org/ci-cd/runner-tools/echo-step@main\ninputs:\necho: 'bye steps!'\nenv:\nvar1: 'value 1'\n```\n\nIn this example, the job has two steps:\n\n- `hello_steps`runs the `echo`shell command.- `bye_steps`uses a predefined step with an environment variable and an input parameter.\n\n**Additional details**:\n\n- A step can have either a `script`or a `step`key, but not both.- A `run`configuration cannot be used together with existing [script](https://docs.gitlab.com/ci/yaml/#script), [after_script](https://docs.gitlab.com/ci/yaml/#after_script)or [before_script](https://docs.gitlab.com/ci/yaml/#before_script)keywords.- Multi-line scripts can be defined using [YAML block scalar syntax](https://docs.gitlab.com/ci/yaml/script/#split-long-commands).\n\n* * *",
					"tokensEstimate": 444,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_127",
					"content": "#### `script`\n\nUse `script` to specify commands for the runner to execute.\n\nAll jobs except [trigger jobs](https://docs.gitlab.com/ci/yaml/#trigger) require a `script` keyword.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: An array including:\n\n- Single line commands.- Long commands [split over multiple lines](https://docs.gitlab.com/ci/yaml/script/#split-long-commands).- [YAML anchors](https://docs.gitlab.com/ci/yaml/yaml_optimization/#yaml-anchors-for-scripts).\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `script`**:\n\n```python\njob1:\nscript: \"bundle exec rspec\"\n\njob2:\nscript:\n - uname -a\n - bundle exec rspec\n```\n\n**Additional details**:\n\n- When you use [these special characters in script](https://docs.gitlab.com/ci/yaml/script/#use-special-characters-with-script), you must use single quotes ( `'`) or double quotes ( `\"`).\n\n**Related topics**:\n\n- You can [ignore non-zero exit codes](https://docs.gitlab.com/ci/yaml/script/#ignore-non-zero-exit-codes).- [Use color codes with script](https://docs.gitlab.com/ci/yaml/script/#add-color-codes-to-script-output)to make job logs easier to review.- [Create custom collapsible sections](https://docs.gitlab.com/ci/jobs/job_logs/#custom-collapsible-sections)to simplify job log output.\n\n* * *",
					"tokensEstimate": 342,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_128",
					"content": "#### `secrets`\n\n- Tier: Premium, Ultimate- Offering: GitLab.com, GitLab Self-Managed, GitLab Dedicated\n\nUse `secrets` to specify [CI/CD secrets](https://docs.gitlab.com/ci/secrets/) to:\n\n- Retrieve from an external secrets provider.- Make available in the job as [CI/CD variables](https://docs.gitlab.com/ci/variables/)( [file type](https://docs.gitlab.com/ci/variables/#use-file-type-cicd-variables)by default).\n\n* * *",
					"tokensEstimate": 104,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_129",
					"content": "##### `secrets:vault`\n\nUse `secrets:vault` to specify secrets provided by a [HashiCorp Vault](https://www.vaultproject.io/).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `engine:name`: Name of the secrets engine. Can be one of `kv-v2`(default), `kv-v1`, or `generic`.- `engine:path`: Path to the secrets engine.- `path`: Path to the secret.- `field`: Name of the field where the password is stored.\n\n**Example of `secrets:vault`**:\n\nTo specify all details explicitly and use the [KV-V2](https://developer.hashicorp.com/vault/docs/secrets/kv/kv-v2) secrets engine:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD: # Store the path to the secret in this CI/CD variable\nvault: # Translates to secret: `ops/data/production/db`, field: `password`\nengine:\nname: kv-v2\npath: ops\npath: production/db\nfield: password\n```\n\nYou can shorten this syntax. With the short syntax, `engine:name` and `engine:path` both default to `kv-v2`:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD: # Store the path to the secret in this CI/CD variable\nvault: production/db/password # Translates to secret: `kv-v2/data/production/db`, field: `password`\n```\n\nTo specify a custom secrets engine path in the short syntax, add a suffix that starts with `@`:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD: # Store the path to the secret in this CI/CD variable\nvault: production/db/password@ops # Translates to secret: `ops/data/production/db`, field: `password`\n```\n\n* * *",
					"tokensEstimate": 367,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_130",
					"content": "##### `secrets:gcp_secret_manager`\n\nUse `secrets:gcp_secret_manager` to specify secrets provided by [GCP Secret Manager](https://cloud.google.com/security/products/secret-manager).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `name`: Name of the secret.- `version`: Version of the secret.\n\n**Example of `secrets:gcp_secret_manager`**:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD:\ngcp_secret_manager:\nname: 'test'\nversion: 2\n```\n\n**Related topics**:\n\n- [Use GCP Secret Manager secrets in GitLab CI/CD](https://docs.gitlab.com/ci/secrets/gcp_secret_manager/).\n\n* * *",
					"tokensEstimate": 152,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_131",
					"content": "##### `secrets:azure_key_vault`\n\nUse `secrets:azure_key_vault` to specify secrets provided by a [Azure Key Vault](https://azure.microsoft.com/en-us/products/key-vault/).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `name`: Name of the secret.- `version`: Version of the secret.\n\n**Example of `secrets:azure_key_vault`**:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD:\nazure_key_vault:\nname: 'test'\nversion: 'test'\n```\n\n**Related topics**:\n\n- [Use Azure Key Vault secrets in GitLab CI/CD](https://docs.gitlab.com/ci/secrets/azure_key_vault/).\n\n* * *",
					"tokensEstimate": 147,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_132",
					"content": "##### `secrets:file`\n\nUse `secrets:file` to configure the secret to be stored as either a [`file` or `variable` type CI/CD variable](https://docs.gitlab.com/ci/variables/#use-file-type-cicd-variables)\n\nBy default, the secret is passed to the job as a `file` type CI/CD variable. The value of the secret is stored in the file and the variable contains the path to the file.\n\nIf your software can’t use `file` type CI/CD variables, set `file: false` to store the secret value directly in the variable.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- `true`(default) or `false`.\n\n**Example of `secrets:file`**:\n\n```python\njob:\nsecrets:\nDATABASE_PASSWORD:\nvault: production/db/password@ops\nfile: false\n```\n\n**Additional details**:\n\n- The `file`keyword is a setting for the CI/CD variable and must be nested under the CI/CD variable name, not in the `vault`section.\n\n* * *",
					"tokensEstimate": 226,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_133",
					"content": "##### `secrets:token`\n\nUse `secrets:token` to explicitly select a token to use when authenticating with the external secrets provider by referencing the token’s CI/CD variable.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- The name of an ID token\n\n**Example of `secrets:token`**:\n\n```python\njob:\nid_tokens:\nAWS_TOKEN:\naud: https://aws.example.com\nVAULT_TOKEN:\naud: https://vault.example.com\nsecrets:\nDB_PASSWORD:\nvault: gitlab/production/db\ntoken: $VAULT_TOKEN\n```\n\n**Additional details**:\n\n- When the `token`keyword is not set and there is only one token defined, the defined token will automatically be used.- If there is more than one token defined, you should specify which token to use by setting the `token`keyword. If you do not specify which token to use, it is not possible to predict which token is used each time the job runs.\n\n* * *",
					"tokensEstimate": 222,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_134",
					"content": "#### `services`\n\nUse `services` to specify any additional Docker images that your scripts require to run successfully. The [`services` image](https://docs.gitlab.com/ci/services/) is linked to the image specified in the [`image`](https://docs.gitlab.com/ci/yaml/#image) keyword.\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:services`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `services`, the job configuration takes precedence and the default configuration is not used.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: The name of the services image, including the registry path if needed, in one of these formats:\n\n- `<image-name>`(Same as using `<image-name>`with the `latest`tag)- `<image-name>:<tag>`- `<image-name>@<digest>`\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file), but [not for `alias`](https://gitlab.com/gitlab-org/gitlab/-/issues/19561).\n\n**Example of `services`**:\n\n```python\ndefault:\nimage:\nname: ruby:2.6\nentrypoint: [\"/bin/bash\"]\n\nservices:\n - name: my-postgres:11.7\nalias: db-postgres\nentrypoint: [\"/usr/local/bin/db-postgres\"]\ncommand: [\"start\"]\n\nbefore_script:\n - bundle install\n\ntest:\nscript:\n - bundle exec rake spec\n```\n\nIn this example, GitLab launches two containers for the job:\n\n- A Ruby container that runs the `script`commands.- A PostgreSQL container. The `script`commands in the Ruby container can connect to the PostgreSQL database at the `db-postgres`hostname.\n\n**Additional details**:\n\n- Using `services`at the top level, but not in the `default`section, is [deprecated](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#globally-defined-image-services-cache-before_script-after_script).\n\n**Related topics**:\n\n- [Available settings for services](https://docs.gitlab.com/ci/services/#available-settings-for-services).- [Define services in the .gitlab-ci.yml file](https://docs.gitlab.com/ci/services/#define-services-in-the-gitlab-ciyml-file).- [Run your CI/CD jobs in Docker containers](https://docs.gitlab.com/ci/docker/using_docker_images/).- [Use Docker to build Docker images](https://docs.gitlab.com/ci/docker/using_docker_build/).\n\n* * *",
					"tokensEstimate": 584,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_135",
					"content": "##### `services:name`\n\nThe full name of the image to use for the service.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: The name of the service image, including the registry path if needed, in one of these formats:\n\n- `<image-name>`(Same as using `<image-name>`with the `latest`tag)- `<image-name>:<tag>`- `<image-name>@<digest>`\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `services:name`**:\n\n```python\nservices:\n - name: postgres:11.7\n - name: registry.example.com/my-org/custom-service:latest\n```\n\n**Additional details**:\n\n- Use [alias](https://docs.gitlab.com/ci/yaml/#servicesalias)to define unique name aliases when using multiple identical service images, or when the service image name is long.- When used with other service options like `entrypoint`, `command`, or `variables`, the `name`keyword is required.- For more information, see [accessing the services](https://docs.gitlab.com/ci/services/#accessing-the-services).\n\n* * *",
					"tokensEstimate": 284,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_136",
					"content": "##### `services:alias`\n\nAdditional aliases to access the service from the job’s container.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: A string with one or more aliases separated by spaces or commas.\n\n**Example of `services:alias`**:\n\n```python\nservices:\n - name: postgres:11.7\nalias: db,postgres,pg\n - name: mysql:latest\nalias: mysql-1\n```\n\n**Additional details**:\n\n- Multiple aliases can be separated by spaces or commas.- For more information, see [accessing the services](https://docs.gitlab.com/ci/services/#accessing-the-services). and [using aliases as service container names for the Kubernetes executor](https://docs.gitlab.com/ci/services/#using-aliases-as-service-container-names-for-the-kubernetes-executor).\n\n* * *",
					"tokensEstimate": 210,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_137",
					"content": "##### `services:docker`\n\nUse `services:docker` to pass options to the Docker executor of a GitLab Runner.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\nA hash of options for the Docker executor, which can include:\n\n- `platform`: Selects the architecture of the image to pull. When not specified, the default is the same platform as the host runner.- `user`: Specify the username or UID to use when running the container.\n\n**Example of `services:docker`**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests in service container\"\nimage: ruby:2.6\nservices:\n - name: super/sql:experimental\ndocker:\nplatform: arm64/v8\nuser: dave\n```\n\n**Additional details**:\n\n- `services:docker:platform`maps to the [docker pull --platform option](https://docs.docker.com/reference/cli/docker/image/pull/#options).- `services:docker:user`maps to the [docker run --user option](https://docs.docker.com/reference/cli/docker/container/run/#options).\n\n* * *",
					"tokensEstimate": 261,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_138",
					"content": "##### `services:kubernetes`\n\nUse `services:kubernetes` to pass options to the GitLab Runner [Kubernetes executor](https://docs.gitlab.com/runner/executors/kubernetes/).\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\nA hash of options for the Kubernetes executor, which can include:\n\n- `user`: Specify the username or UID to use when the container runs. You can also use it to set GID by using the `UID:GID`format.\n\n**Example of `services:kubernetes` with only UID**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests\"\nimage: ruby:2.6\nservices:\n - name: super/sql:experimental\nkubernetes:\nuser: \"1001\"\n```\n\n**Example of `services:kubernetes` with both UID and GID**:\n\n```python\narm-sql-job:\nscript: echo \"Run sql tests\"\nimage: ruby:2.6\nservices:\n - name: super/sql:experimental\nkubernetes:\nuser: \"1001:1001\"\n```\n\n* * *",
					"tokensEstimate": 232,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_139",
					"content": "##### `services:entrypoint`\n\nA command or script to execute as the container’s entrypoint.\n\nWhen the Docker container is created, the `entrypoint` is translated to the Docker `--entrypoint` option. The syntax is similar to the [Dockerfile `ENTRYPOINT` directive](https://docs.docker.com/reference/dockerfile/#entrypoint), where each shell token is a separate string in the array.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: An array of strings representing the entrypoint command.\n\n**Example of `services:entrypoint`**:\n\n```python\nservices:\n - name: my-postgres:11.7\nentrypoint: [\"/usr/local/bin/db-postgres\"]\n```\n\n* * *",
					"tokensEstimate": 184,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_140",
					"content": "##### `services:command`\n\nCommand or script that should be used as the container’s command.\n\nIt’s translated to arguments passed to Docker after the image’s name. The syntax is similar to the [Dockerfile `CMD`](https://docs.docker.com/reference/dockerfile/#cmd) directive, where each shell token is a separate string in the array.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: An array of strings representing the command.\n\n**Example of `services:command`**:\n\n```python\nservices:\n - name: super/sql:latest\ncommand: [\"/usr/bin/super-sql\", \"run\"]\n```\n\n* * *",
					"tokensEstimate": 167,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_141",
					"content": "##### `services:variables`\n\nAdditional environment variables that are passed exclusively to the service. Service variables are passed exclusively to the service container and are not available to the job container.\n\nThe syntax is the same as [job variables](https://docs.gitlab.com/ci/variables/).\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: A hash of environment variable names and values.\n\n**Example of `services:variables`**:\n\n```python\nservices:\n - name: postgres:11.7\nalias: db\nvariables:\nPOSTGRES_DB: \"my_custom_db\"\nPOSTGRES_USER: \"postgres\"\nPOSTGRES_PASSWORD: \"example\"\nPGDATA: \"/var/lib/postgresql/data\"\n```\n\n**Additional details**:\n\n- Service variables cannot reference themselves, they do not support variable expansion or interpolation.- Variables defined at the job or pipeline level are automatically passed to services. See [passing CI/CD variables to services](https://docs.gitlab.com/ci/services/#passing-cicd-variables-to-services)for more information.- Service variables are only available to the specific service they are defined for.\n\n* * *",
					"tokensEstimate": 293,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_142",
					"content": "##### `services:pull_policy`\n\nThe pull policy that the runner uses to fetch the Docker image. Requires GitLab Runner 15.1 or later.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- A single pull policy, or multiple pull policies in an array. Can be `always`, `if-not-present`, or `never`.\n\n**Examples of `services:pull_policy`**:\n\n```python\njob1:\nscript: echo \"A single pull policy.\"\nservices:\n - name: postgres:11.6\npull_policy: if-not-present\n\njob2:\nscript: echo \"Multiple pull policies.\"\nservices:\n - name: postgres:11.6\npull_policy: [always, if-not-present]\n```\n\n**Additional details**:\n\n- If the runner does not support the defined pull policy, the job fails with an error similar to: `ERROR: Job failed (system failure): the configured PullPolicies ([always]) are not allowed by AllowedPullPolicies ([never])`.\n\n**Related topics**:\n\n- [Run your CI/CD jobs in Docker containers](https://docs.gitlab.com/ci/docker/using_docker_images/).- [Configure how runners pull images](https://docs.gitlab.com/runner/executors/docker.html#configure-how-runners-pull-images).- [Set multiple pull policies](https://docs.gitlab.com/runner/executors/docker.html#set-multiple-pull-policies).\n\n* * *",
					"tokensEstimate": 323,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_143",
					"content": "#### `stage`\n\nUse `stage` to define which [stage](https://docs.gitlab.com/ci/yaml/#stages) a job runs in. Jobs in the same `stage` can execute in parallel (see **Additional details**).\n\nIf `stage` is not defined, the job uses the `test` stage by default.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**: A string, which can be a:\n\n- [Default stage](https://docs.gitlab.com/ci/yaml/#stages).- User-defined stages.\n\n**Example of `stage`**:\n\n```python\nstages:\n - build\n - test\n - deploy\n\njob1:\nstage: build\nscript:\n - echo \"This job compiles code.\"\n\njob2:\nstage: test\nscript:\n - echo \"This job tests the compiled code. It runs when the build stage completes.\"\n\njob3:\nscript:\n - echo \"This job also runs in the test stage.\"\n\njob4:\nstage: deploy\nscript:\n - echo \"This job deploys the code. It runs when the test stage completes.\"\nenvironment: production\n```\n\n**Additional details**:\n\n- The stage name must be 255 characters or fewer.- Jobs can run in parallel if they run on different runners.- If you have only one runner, jobs can run in parallel if the runner’s [concurrent setting](https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-global-section)is greater than `1`.\n\n* * *",
					"tokensEstimate": 306,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_144",
					"content": "##### `stage: .pre`\n\nUse the `.pre` stage to make a job run at the start of a pipeline. By default, `.pre` is the first stage in a pipeline. User-defined stages execute after `.pre`. You do not have to define `.pre` in [`stages`](https://docs.gitlab.com/ci/yaml/#stages).\n\nIf a pipeline contains only jobs in the `.pre` or `.post` stages, it does not run. There must be at least one other job in a different stage.\n\n**Keyword type**: You can only use it with a job’s `stage` keyword.\n\n**Example of `stage: .pre`**:\n\n```python\nstages:\n - build\n - test\n\njob1:\nstage: build\nscript:\n - echo \"This job runs in the build stage.\"\n\nfirst-job:\nstage: .pre\nscript:\n - echo \"This job runs in the .pre stage, before all other stages.\"\n\njob2:\nstage: test\nscript:\n - echo \"This job runs in the test stage.\"\n```\n\n**Additional details**:\n\n- If a pipeline has jobs with [needs: []](https://docs.gitlab.com/ci/yaml/#needs)and jobs in the `.pre`stage, they will all start as soon as the pipeline is created. Jobs with `needs: []`start immediately, ignoring any stage configuration.- A [pipeline execution policy](https://docs.gitlab.com/user/application_security/policies/pipeline_execution_policies/)can define a `.pipeline-policy-pre`stage which runs before `.pre`.\n\n* * *",
					"tokensEstimate": 310,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_145",
					"content": "##### `stage: .post`\n\nUse the `.post` stage to make a job run at the end of a pipeline. By default, `.post` is the last stage in a pipeline. User-defined stages execute before `.post`. You do not have to define `.post` in [`stages`](https://docs.gitlab.com/ci/yaml/#stages).\n\nIf a pipeline contains only jobs in the `.pre` or `.post` stages, it does not run. There must be at least one other job in a different stage.\n\n**Keyword type**: You can only use it with a job’s `stage` keyword.\n\n**Example of `stage: .post`**:\n\n```python\nstages:\n - build\n - test\n\njob1:\nstage: build\nscript:\n - echo \"This job runs in the build stage.\"\n\nlast-job:\nstage: .post\nscript:\n - echo \"This job runs in the .post stage, after all other stages.\"\n\njob2:\nstage: test\nscript:\n - echo \"This job runs in the test stage.\"\n```\n\n**Additional details**:\n\n- A [pipeline execution policy](https://docs.gitlab.com/user/application_security/policies/pipeline_execution_policies/)can define a `.pipeline-policy-post`stage which runs after `.post`.\n\n* * *",
					"tokensEstimate": 252,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_146",
					"content": "#### `tags`\n\nUse `tags` to select a specific runner from the list of all runners that are available for the project.\n\nWhen you register a runner, you can specify the runner’s tags, for example `ruby`, `postgres`, or `development`. To pick up and run a job, a runner must be assigned every tag listed in the job.\n\nJob configuration and default configuration does not merge together. If the pipeline has [`default:tags`](https://docs.gitlab.com/ci/yaml/#default) defined, and the job also has `tags`, the job configuration takes precedence and the default configuration is not used.\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**:\n\n- An array of tag names, which are case-sensitive.- CI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of `tags`**:\n\n```python\njob:\ntags:\n - ruby\n - postgres\n```\n\nIn this example, only runners with both the `ruby` and `postgres` tags can run the job.\n\n**Additional details**:\n\n- The number of tags must be less than `50`.\n\n**Related topics**:\n\n- [Use tags to control which jobs a runner can run](https://docs.gitlab.com/ci/runners/configure_runners/#control-jobs-that-a-runner-can-run)\n- [Select different runner tags for each parallel matrix job](https://docs.gitlab.com/ci/jobs/job_control/#select-different-runner-tags-for-each-parallel-matrix-job)- Runner tags for hosted runners:\n - [Hosted runners on Linux](https://docs.gitlab.com/ci/runners/hosted_runners/linux/)\n- [GPU-enabled hosted runners](https://docs.gitlab.com/ci/runners/hosted_runners/gpu_enabled/)\n- [Hosted runners on macOS](https://docs.gitlab.com/ci/runners/hosted_runners/macos/)\n- [Hosted runners on Windows](https://docs.gitlab.com/ci/runners/hosted_runners/windows/)\n\n* * *",
					"tokensEstimate": 465,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_147",
					"content": "#### `timeout`\n\nUse `timeout` to configure a timeout for a specific job. If the job runs for longer than the timeout, the job fails.\n\nThe job-level timeout can be longer than the [project-level timeout](https://docs.gitlab.com/ci/pipelines/settings/#set-a-limit-for-how-long-jobs-can-run), but can’t be longer than the [runner’s timeout](https://docs.gitlab.com/ci/runners/configure_runners/#set-the-maximum-job-timeout).\n\n**Keyword type**: Job keyword. You can use it only as part of a job or in the [`default` section](https://docs.gitlab.com/ci/yaml/#default).\n\n**Supported values**: A period of time written in natural language. For example, these are all equivalent:\n\n- `3600 seconds`- `60 minutes`- `one hour`\n\n**Example of `timeout`**:\n\n```python\nbuild:\nscript: build.sh\ntimeout: 3 hours 30 minutes\n\ntest:\nscript: rspec\ntimeout: 3h 30m\n```\n\n* * *",
					"tokensEstimate": 211,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_148",
					"content": "#### `trigger`\n\n\n\nUse `trigger` to declare that a job is a “trigger job” which starts a [downstream pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/) that is either:\n\n- [A multi-project pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#multi-project-pipelines).- [A child pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines).\n\nTrigger jobs can use only a limited set of GitLab CI/CD configuration keywords. The keywords available for use in trigger jobs are:\n\n- [allow_failure](https://docs.gitlab.com/ci/yaml/#allow_failure).- [extends](https://docs.gitlab.com/ci/yaml/#extends).- [needs](https://docs.gitlab.com/ci/yaml/#needs), but not [needs:project](https://docs.gitlab.com/ci/yaml/#needsproject).- [only and except](https://docs.gitlab.com/ci/yaml/deprecated_keywords/#only--except).- [parallel](https://docs.gitlab.com/ci/yaml/#parallel).- [rules](https://docs.gitlab.com/ci/yaml/#rules).- [stage](https://docs.gitlab.com/ci/yaml/#stage).- [trigger](https://docs.gitlab.com/ci/yaml/#trigger).- [variables](https://docs.gitlab.com/ci/yaml/#variables).- [when](https://docs.gitlab.com/ci/yaml/#when)(only with a value of `on_success`, `on_failure`, or `always`).- [resource_group](https://docs.gitlab.com/ci/yaml/#resource_group).- [environment](https://docs.gitlab.com/ci/yaml/#environment).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- For multi-project pipelines, the path to the downstream project. CI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file)in GitLab 15.3 and later, but not [job-only variables](https://docs.gitlab.com/ci/variables/predefined_variables/#variable-availability). Alternatively, use [trigger:project](https://docs.gitlab.com/ci/yaml/#triggerproject).- For child pipelines, use [trigger:include](https://docs.gitlab.com/ci/yaml/#triggerinclude).\n\n**Example of `trigger`**:\n\n```python\ntrigger-multi-project-pipeline:\ntrigger: my-group/my-project\n```\n\n**Additional details**:",
					"tokensEstimate": 522,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_149",
					"content": "- You can use [when:manual](https://docs.gitlab.com/ci/yaml/#when)in the same job as `trigger`, but you cannot use the API to start `when:manual`trigger jobs. See [issue 284086](https://gitlab.com/gitlab-org/gitlab/-/issues/284086)for more details.- You cannot [manually specify CI/CD variables](https://docs.gitlab.com/ci/jobs/job_control/#specify-variables-when-running-manual-jobs)before running a manual trigger job.- [CI/CD variables](https://docs.gitlab.com/ci/yaml/#variables)defined in a top-level `variables`section (globally) or in the trigger job are forwarded to the downstream pipeline as [trigger variables](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#pass-cicd-variables-to-a-downstream-pipeline).- [Pipeline variables](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence)are not passed to downstream pipelines by default. Use [trigger:forward](https://docs.gitlab.com/ci/yaml/#triggerforward)to forward these variables to downstream pipelines.- [Job-only variables](https://docs.gitlab.com/ci/variables/predefined_variables/#variable-availability)are not available in trigger jobs.- Environment variables [defined in the runner’s config.toml](https://docs.gitlab.com/runner/configuration/advanced-configuration.html#the-runners-section)are not available to trigger jobs and are not passed to downstream pipelines.- You cannot use [needs:pipeline:job](https://docs.gitlab.com/ci/yaml/#needspipelinejob)in a trigger job.\n\n**Related topics**:\n\n- [Multi-project pipeline configuration examples](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#trigger-a-downstream-pipeline-from-a-job-in-the-gitlab-ciyml-file).- To run a pipeline for a specific branch, tag, or commit, you can use a [trigger token](https://docs.gitlab.com/ci/triggers/)to authenticate with the [pipeline triggers API](https://docs.gitlab.com/api/pipeline_triggers/). The trigger token is different than the `trigger`keyword.\n\n* * *\n\n##### `trigger:inputs`\n\nUse `trigger:inputs` to set the [inputs](https://docs.gitlab.com/ci/inputs/) for a multi-project pipeline when the downstream pipeline configuration uses [`spec:inputs`](https://docs.gitlab.com/ci/yaml/#specinputs).\n\n**Example of `trigger:inputs`**:\n\n```python\ntrigger:\n - project: 'my-group/my-project'\ninputs:\nwebsite: \"My website\"\n```\n\n* * *",
					"tokensEstimate": 577,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_150",
					"content": "##### `trigger:include`\n\nUse `trigger:include` to declare that a job is a “trigger job” which starts a [child pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- The path to the child pipeline’s configuration file.\n\n**Example of `trigger:include`**:\n\n```python\ntrigger-child-pipeline:\ntrigger:\ninclude: path/to/child-pipeline.gitlab-ci.yml\n```\n\n**Additional details**:\n\nUse:\n\n- `trigger:include:artifact` to trigger a [dynamic child pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#dynamic-child-pipelines).- `trigger:include:inputs` to set the [inputs](https://docs.gitlab.com/ci/inputs/) when the downstream pipeline configuration uses [`spec:inputs`](https://docs.gitlab.com/ci/yaml/#specinputs).- `trigger:include:local` for a path to a child pipeline configuration file when:\n - Combining [multiple child pipeline configuration files](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#combine-multiple-child-pipeline-configuration-files).- Combined with `trigger:include:inputs` to pass inputs to the child pipeline. For example: ```python\nstaging-job:\ntrigger:\ninclude:\n - local: path/to/child-pipeline.yml\ninputs:\nenvironment: staging\n ```- `trigger:include:project` to trigger a child pipeline [with a configuration file in a different project](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#use-a-child-pipeline-configuration-file-in-a-different-project). If the file contains additional [`include`](https://docs.gitlab.com/ci/yaml/#include) entries, GitLab looks for the files in the project running the pipeline, not the project hosting the file.- `trigger:include:template` to trigger a child pipeline with a CI/CD template.\n\n**Related topics**:\n\n- [Child pipeline configuration examples](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#trigger-a-downstream-pipeline-from-a-job-in-the-gitlab-ciyml-file).\n\n* * *\n\n##### `trigger:include:inputs`\n\nUse `trigger:include:inputs` to set the [inputs](https://docs.gitlab.com/ci/inputs/) for a child pipeline when the downstream pipeline configuration uses [`spec:inputs`](https://docs.gitlab.com/ci/yaml/#specinputs).\n\n**Example of `trigger:inputs`**:\n\n```python\ntrigger-job:\ntrigger:\ninclude:\n - local: path/to/child-pipeline.yml\ninputs:\nwebsite: \"My website\"\n```\n\n* * *",
					"tokensEstimate": 599,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_151",
					"content": "##### `trigger:project`\n\nUse `trigger:project` to declare that a job is a “trigger job” which starts a [multi-project pipeline](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#multi-project-pipelines).\n\nBy default, the multi-project pipeline triggers for the default branch. Use `trigger:branch` to specify a different branch.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- The path to the downstream project. CI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file)in GitLab 15.3 and later, but not [job-only variables](https://docs.gitlab.com/ci/variables/predefined_variables/#variable-availability).\n\n**Example of `trigger:project`**:\n\n```python\ntrigger-multi-project-pipeline:\ntrigger:\nproject: my-group/my-project\n```\n\n**Example of `trigger:project` for a different branch**:\n\n```python\ntrigger-multi-project-pipeline:\ntrigger:\nproject: my-group/my-project\nbranch: development\n```\n\n**Related topics**:\n\n- [Multi-project pipeline configuration examples](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#trigger-a-downstream-pipeline-from-a-job-in-the-gitlab-ciyml-file).- To run a pipeline for a specific branch, tag, or commit, you can also use a [trigger token](https://docs.gitlab.com/ci/triggers/)to authenticate with the [pipeline triggers API](https://docs.gitlab.com/api/pipeline_triggers/). The trigger token is different than the `trigger`keyword.\n\n* * *",
					"tokensEstimate": 372,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_152",
					"content": "##### `trigger:strategy`\n\nUse `trigger:strategy` to force the `trigger` job to wait for the downstream pipeline to complete before it is marked as **success**.\n\nThis behavior is different than the default, which is for the `trigger` job to be marked as **success** as soon as the downstream pipeline is created.\n\nThis setting makes your pipeline execution linear rather than parallel.\n\n**Supported values**:\n\n- `mirror`: Mirrors the status of the downstream pipeline exactly.- `depend`: Not recommended, use `mirror`instead. The trigger job status shows **failed**, **success**, or **running**, depending on the downstream pipeline status. See additional details.\n\n**Example of `trigger:strategy`**:\n\n```python\ntrigger_job:\ntrigger:\ninclude: path/to/child-pipeline.yml\nstrategy: mirror\n```\n\nIn this example, jobs from subsequent stages wait for the triggered pipeline to successfully complete before starting.\n\n**Additional details**:\n\n- [Optional manual jobs](https://docs.gitlab.com/ci/jobs/job_control/#types-of-manual-jobs)in the downstream pipeline do not affect the status of the downstream pipeline or the upstream trigger job. The downstream pipeline can complete successfully without running any optional manual jobs.- By default, jobs in later stages do not start until the trigger job completes.- [Blocking manual jobs](https://docs.gitlab.com/ci/jobs/job_control/#types-of-manual-jobs)in the downstream pipeline must run before the trigger job is marked as successful or failed.- When using `strategy:depend`(no longer recommended, use `strategy:mirror`instead):\n - The trigger job shows **running**( status\\_running) if the downstream pipeline status is **waiting for manual action**( status\\_manual) due to manual jobs.- If the downstream pipeline has a failed job, but the job uses [allow_failure: true](https://docs.gitlab.com/ci/yaml/#allow_failure), the downstream pipeline is considered successful and the trigger job shows **success**.\n\n* * *",
					"tokensEstimate": 488,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_153",
					"content": "##### `trigger:forward`\n\nUse `trigger:forward` to specify what to forward to the downstream pipeline. You can control what is forwarded to both [parent-child pipelines](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#parent-child-pipelines) and [multi-project pipelines](https://docs.gitlab.com/ci/pipelines/downstream_pipelines/#multi-project-pipelines).\n\nForwarded variables do not get forwarded again in nested downstream pipelines by default, unless the nested downstream trigger job also uses `trigger:forward`.\n\n**Supported values**:\n\n- `yaml_variables`: `true`(default), or `false`. When `true`, variables defined in the trigger job are passed to downstream pipelines.- `pipeline_variables`: `true`or `false`(default). When `true`, [pipeline variables](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence)are passed to the downstream pipeline.\n\n**Example of `trigger:forward`**:\n\n[Run this pipeline manually](https://docs.gitlab.com/ci/pipelines/#run-a-pipeline-manually), with the CI/CD variable `MYVAR = my value`:\n\n```python\nvariables: # default variables for each job\nVAR: value\n\n---\n\n## Default behavior:\n\n---\n\n## - VAR is passed to the child\n\n---\n\n## - MYVAR is not passed to the child child1: trigger: include: .child-pipeline.yml\n\n---\n\n## Forward pipeline variables:\n\n---\n\n## - VAR is passed to the child\n\n---\n\n## - MYVAR is passed to the child child2: trigger: include: .child-pipeline.yml forward: pipeline_variables: true\n\n---\n\n## Do not forward YAML variables:\n\n---\n\n## - VAR is not passed to the child\n\n---",
					"tokensEstimate": 381,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_154",
					"content": "## - MYVAR is not passed to the child child3: trigger: include: .child-pipeline.yml forward: yaml_variables: false\n\n```\n\n**Additional details**:\n\n- CI/CD variables forwarded to downstream pipelines with `trigger:forward`are [pipeline variables](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence), which have high precedence. If a variable with the same name is defined in the downstream pipeline, that variable is usually overwritten by the forwarded variable.\n\n* * *",
					"tokensEstimate": 119,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_155",
					"content": "#### `when`\n\nUse `when` to configure the conditions for when jobs run. If not defined in a job, the default value is `when: on_success`.\n\n**Keyword type**: Job keyword. You can use it as part of a job. `when: always` and `when: never` can also be used in [`workflow:rules`](https://docs.gitlab.com/ci/yaml/#workflow).\n\n**Supported values**:\n\n- `on_success`(default): Run the job only when no jobs in earlier stages fail.- `on_failure`: Run the job only when at least one job in an earlier stage fails.- `never`: Don’t run the job regardless of the status of jobs in earlier stages. Can only be used in a [rules](https://docs.gitlab.com/ci/yaml/#ruleswhen)section or [workflow: rules](https://docs.gitlab.com/ci/yaml/#workflowrules).- `always`: Run the job regardless of the status of jobs in earlier stages.- `manual`: Add the job to the pipeline as a [manual job](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually).- `delayed`: Add the job to the pipeline as a [delayed job](https://docs.gitlab.com/ci/jobs/job_control/#run-a-job-after-a-delay).\n\n**Example of `when`**:\n\n```python\nstages:\n - build\n - cleanup_build\n - test\n - deploy\n - cleanup\n\nbuild_job:\nstage: build\nscript:\n - make build\n\ncleanup_build_job:\nstage: cleanup_build\nscript:\n - cleanup build when failed\nwhen: on_failure\n\ntest_job:\nstage: test\nscript:\n - make test\n\ndeploy_job:\nstage: deploy\nscript:\n - make deploy\nwhen: manual\nenvironment: production\n\ncleanup_job:\nstage: cleanup\nscript:\n - cleanup after jobs\nwhen: always\n```\n\nIn this example, the script:\n\n- Executes `cleanup_build_job`only when `build_job`fails.- Always executes `cleanup_job`as the last step in pipeline regardless of success or failure.- Executes `deploy_job`when you run it manually in the GitLab UI.\n\n**Additional details**:\n\n- When evaluating the status of jobs for `on_success`and `on_failure`:\n - Jobs with [allow_failure: true](https://docs.gitlab.com/ci/yaml/#allow_failure)in earlier stages are considered successful, even if they failed.- Skipped jobs in earlier stages, for example [manual jobs that have not been started](https://docs.gitlab.com/ci/jobs/job_control/#create-a-job-that-must-be-run-manually), are considered successful.- The default value for [allow_failure](https://docs.gitlab.com/ci/yaml/#allow_failure)is `true`with `when: manual`. The default value changes to `false`with [rules:when: manual](https://docs.gitlab.com/ci/yaml/#ruleswhen).\n\n**Related topics**:\n\n- `when`can be used with [rules](https://docs.gitlab.com/ci/yaml/#rules)for more dynamic job control.- `when`can be used with [workflow](https://docs.gitlab.com/ci/yaml/#workflow)to control when a pipeline can start.\n\n* * *",
					"tokensEstimate": 665,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_156",
					"content": "##### `manual_confirmation`\n\nUse `manual_confirmation` with [`when: manual`](https://docs.gitlab.com/ci/yaml/#when) to define a custom confirmation message for manual jobs. If no manual job is defined with `when: manual`, this keyword has no effect.\n\nManual confirmation works with all manual jobs, including environment stop jobs that use [`environment:action: stop`](https://docs.gitlab.com/ci/yaml/#environmentaction).\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Supported values**:\n\n- A string with the confirmation message.\n\n**Example of `manual_confirmation`**:\n\n```python\ndelete_job:\nstage: post-deployment\nscript:\n - make delete\nwhen: manual\nmanual_confirmation: 'Are you sure you want to delete this environment?'\n\nstop_production:\nstage: cleanup\nscript:\n - echo \"Stopping production environment\"\nenvironment:\nname: production\naction: stop\nwhen: manual\nmanual_confirmation: \"Are you sure you want to stop the production environment?\"\n```\n\n* * *",
					"tokensEstimate": 243,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_157",
					"content": "#### `start_in`\n\nUse `start_in` to delay the execution of a job for a specified duration after the job is created. You must configure `when: delayed` for the job.\n\n**Keyword type**: Job keyword. You can use it only as part of a job.\n\n**Possible inputs**: A period of time in seconds, minutes, or hours. Must be less than or equal to one week. Examples of valid values:\n\n- `'5'`(5 seconds)- `'10 seconds'`- `'30 minutes'`- `'1 hour'`- `'1 day'`\n\n**Example of `start_in`**:\n\n```python\ndeploy_production:\nstage: deploy\nscript:\n - echo \"Deploying to production\"\nwhen: delayed\nstart_in: 30 minutes\n```\n\nIn this example, the `deploy_production` job starts 30 minutes after the previous stage completes.\n\n**Additional details**:\n\n- The timer starts when the job’s stage begins, not when the previous job finishes.- To manually start a delayed job immediately, select **Play**( play) in the pipeline view.- The minimum delay period is one second and the maximum delay is one week.- `start_in`only works when [when](https://docs.gitlab.com/ci/yaml/#when)is set to `delayed`. If you use any other value for `when`, the configuration is invalid. If a job uses `rules`, `start_in`and `when`must be defined in the `rules`, not at the job level. Otherwise, you receive a validation error: `config key may not be used with 'rules': start_in`.- `start_in`is not supported with `workflow:rules`, but does not cause any syntax violation.\n\n**Related topics**:\n\n- [Run a job after a delay](https://docs.gitlab.com/ci/jobs/job_control/#run-a-job-after-a-delay)\n\n* * *",
					"tokensEstimate": 384,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_158",
					"content": "### `variables`\n\nUse `variables` to define [CI/CD variables](https://docs.gitlab.com/ci/variables/#define-a-cicd-variable-in-the-gitlab-ciyml-file).\n\nVariables can be [defined in a CI/CD job](https://docs.gitlab.com/ci/yaml/#job-variables), or as a top-level (global) keyword to define [default CI/CD variables](https://docs.gitlab.com/ci/yaml/#default-variables) for all jobs.\n\n**Additional details**:\n\n- All YAML-defined variables are also set to any linked [Docker service containers](https://docs.gitlab.com/ci/services/).- YAML-defined variables are meant for non-sensitive project configuration. Store sensitive information in [protected variables](https://docs.gitlab.com/ci/variables/#protect-a-cicd-variable)or [CI/CD secrets](https://docs.gitlab.com/ci/secrets/).- [Manual pipeline variables](https://docs.gitlab.com/ci/variables/#use-pipeline-variables)and [scheduled pipeline variables](https://docs.gitlab.com/ci/pipelines/schedules/#create-a-pipeline-schedule)are not passed to downstream pipelines by default. Use [trigger:forward](https://docs.gitlab.com/ci/yaml/#triggerforward)to forward these variables to downstream pipelines.\n\n**Related topics**:\n\n- [Predefined variables](https://docs.gitlab.com/ci/variables/predefined_variables/)are variables the runner automatically creates and makes available in the job.- You can [configure runner behavior with variables](https://docs.gitlab.com/ci/runners/configure_runners/#configure-runner-behavior-with-variables).\n\n* * *",
					"tokensEstimate": 370,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_159",
					"content": "#### Job `variables`\n\nYou can use job variables in commands in the job’s `script`, `before_script`, or `after_script` sections, and also with some [job keywords](https://docs.gitlab.com/ci/yaml/#job-keywords). Check the **Supported values** section of each job keyword to see if it supports variables.\n\nYou cannot use job variables as values for [global keywords](https://docs.gitlab.com/ci/yaml/#global-keywords) like [`include`](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Supported values**: Variable name and value pairs:\n\n- The name can use only numbers, letters, and underscores ( `_`). In some shells, the first character must be a letter.- The value must be a string.\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Example of job `variables`**:\n\n```python\nreview_job:\nvariables:\nDEPLOY_SITE: \"https://dev.example.com/\"\nREVIEW_PATH: \"/review\"\nscript:\n - deploy-review-script --url $DEPLOY_SITE --path $REVIEW_PATH\n```\n\nIn this example:\n\n- `review_job`has `DEPLOY_SITE`and `REVIEW_PATH`job variables defined. Both job variables can be used in the `script`section.\n\n* * *",
					"tokensEstimate": 293,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_160",
					"content": "#### Default `variables`\n\nVariables defined in a top-level `variables` section act as default variables for all jobs.\n\nEach default variable is made available to every job in the pipeline, except when the job already has a variable defined with the same name. The variable defined in the job [takes precedence](https://docs.gitlab.com/ci/variables/#cicd-variable-precedence), so the value of the default variable with the same name cannot be used in the job.\n\nLike job variables, you cannot use default variables as values for other global keywords, like [`include`](https://docs.gitlab.com/ci/yaml/includes/#use-variables-with-include).\n\n**Supported values**: Variable name and value pairs:\n\n- The name can use only numbers, letters, and underscores ( `_`). In some shells, the first character must be a letter.- The value must be a string.\n\nCI/CD variables [are supported](https://docs.gitlab.com/ci/variables/where_variables_can_be_used/#gitlab-ciyml-file).\n\n**Examples of `variables`**:\n\n```python\nvariables:\nDEPLOY_SITE: \"https://example.com/\"\n\ndeploy_job:\nstage: deploy\nscript:\n - deploy-script --url $DEPLOY_SITE --path \"/\"\nenvironment: production\n\ndeploy_review_job:\nstage: deploy\nvariables:\nDEPLOY_SITE: \"https://dev.example.com/\"\nREVIEW_PATH: \"/review\"\nscript:\n - deploy-review-script --url $DEPLOY_SITE --path $REVIEW_PATH\nenvironment: production\n```\n\nIn this example:\n\n- `deploy_job`has no variables defined. The default `DEPLOY_SITE`variable is copied to the job and can be used in the `script`section.- `deploy_review_job`already has a `DEPLOY_SITE`variable defined, so the default `DEPLOY_SITE`is not copied to the job. The job also has a `REVIEW_PATH`job variable defined. Both job variables can be used in the `script`section.\n\n* * *",
					"tokensEstimate": 434,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_161",
					"content": "##### `variables:description`\n\nUse the `description` keyword to define a description for a default variable. The description displays with [the prefilled variable name when running a pipeline manually](https://docs.gitlab.com/ci/pipelines/#prefill-variables-in-manual-pipelines).\n\n**Keyword type**: You can only use this keyword with default `variables`, not job `variables`.\n\n**Supported values**:\n\n- A string. You can use Markdown.\n\n**Example of `variables:description`**:\n\n```python\nvariables:\nDEPLOY_NOTE:\ndescription: \"The deployment note. Explain the reason for this deployment.\"\n```\n\n**Additional details**:\n\n- When used without `value`, the variable exists in pipelines that were not triggered manually, and the default value is an empty string ( `''`).\n\n* * *",
					"tokensEstimate": 190,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_162",
					"content": "##### `variables:value`\n\nUse the `value` keyword to define a pipeline-level (default) variable’s value. When used with [`variables: description`](https://docs.gitlab.com/ci/yaml/#variablesdescription), the variable value is [prefilled when running a pipeline manually](https://docs.gitlab.com/ci/pipelines/#prefill-variables-in-manual-pipelines).\n\n**Keyword type**: You can only use this keyword with default `variables`, not job `variables`.\n\n**Supported values**:\n\n- A string.\n\n**Example of `variables:value`**:\n\n```python\nvariables:\nDEPLOY_ENVIRONMENT:\nvalue: \"staging\"\ndescription: \"The deployment target. Change this variable to 'canary' or 'production' if needed.\"\n```\n\n**Additional details**:\n\n- If used without [variables: description](https://docs.gitlab.com/ci/yaml/#variablesdescription), the behavior is the same as [variables](https://docs.gitlab.com/ci/yaml/#variables).\n\n* * *",
					"tokensEstimate": 221,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_163",
					"content": "##### `variables:options`\n\nUse `variables:options` to define an array of values that are [selectable in the UI when running a pipeline manually](https://docs.gitlab.com/ci/pipelines/#configure-a-list-of-selectable-prefilled-variable-values).\n\nMust be used with `variables: value`, and the string defined for `value`:\n\n- Must also be one of the strings in the `options`array.- Is the default selection.\n\nIf there is no [`description`](https://docs.gitlab.com/ci/yaml/#variablesdescription), this keyword has no effect.\n\n**Keyword type**: You can only use this keyword with default `variables`, not job `variables`.\n\n**Supported values**:\n\n- An array of strings.\n\n**Example of `variables:options`**:\n\n```python\nvariables:\nDEPLOY_ENVIRONMENT:\nvalue: \"staging\"\noptions:\n - \"production\"\n - \"staging\"\n - \"canary\"\ndescription: \"The deployment target. Set to 'staging' by default.\"\n```\n\n* * *",
					"tokensEstimate": 218,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				},
				{
					"id": "ci_yaml_chunk_164",
					"content": "#### `variables:expand`\n\nUse the `expand` keyword to configure a variable to be expandable or not.\n\n**Keyword type**: You can use this keyword with both default and job `variables`.\n\n**Supported values**:\n\n- `true`(default): The variable is expandable.- `false`: The variable is not expandable.\n\n**Example of `variables:expand`**:\n\n```python\nvariables:\nVAR1: value1\nVAR2: value2 $VAR1\nVAR3:\nvalue: value3 $VAR1\nexpand: false\n```\n\n- The result of `VAR2`is `value2 value1`.- The result of `VAR3`is `value3 $VAR1`.\n\n**Additional details**:\n\n- The `expand`keyword can only be used with default and job `variables`keywords. You can’t use it with [rules:variables](https://docs.gitlab.com/ci/yaml/#rulesvariables)or [workflow:rules:variables](https://docs.gitlab.com/ci/yaml/#workflowrulesvariables).",
					"tokensEstimate": 197,
					"sourceUrl": "https://docs.gitlab.com/ci/yaml",
					"pageTitle": "CI/CD YAML syntax reference | GitLab Docs"
				}
			],
			"metadata": {
				"url": "https://docs.gitlab.com/ci/yaml",
				"title": "CI/CD YAML syntax reference | GitLab Docs",
				"depth": 1,
				"crawledAt": "2026-02-02T06:03:23.171Z",
				"tokensEstimate": 58010
			}
		}
	]
}